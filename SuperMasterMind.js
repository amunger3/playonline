
// ***************************************************
// ********** Main Super Master Mind script **********
// ***************************************************

"use strict";

console.log("Running SuperMasterMind.js...");

// *************************************************************************
// *************************************************************************
// Global variables
// *************************************************************************
// *************************************************************************

// Main game variables
// *******************

let version = "v2.56";

let emptyColor = 0; // (0 is also the Java default table init value)
let nbMinColors = 5;
let nbMaxColors = 10;
let nbMinColumns = 3;
let nbMaxColumns = 7;
let overallNbMinAttempts = 4;
let overallNbMaxAttempts = 15;

let nominalGameNbColumns = 5; // classical Super Master Mind game
let nominalGameNbColors = 8; // classical Super Master Mind game
let nominalGameNbMaxAttempts = 12; // classical Super Master Mind game

let defaultNbColumns = 5;

let nbColumns = -1; // N.A.
let nbColors = -1; // N.A.
let nbMaxAttempts = -1; // N.A.

let simpleCodeHandler = null;

let showPossibleCodesMode = false;
let showPossibleCodesOffsetMode = false;
let nbMinPossibleCodesShown = -1; // N.A.
let nbMaxPossibleCodesShown = -1; // N.A.
let nbPossibleCodesShown = -1; // N.A. (only valid if showPossibleCodesMode is true)
let currentPossibleCodeShown = -1; // N.A. (only valid if showPossibleCodesMode is true)
let disableMouseMoveEffects = false;
let atLeastOneAttemptSelection = false;
let currentPossibleCodeShownBeforeMouseMove = -1; // N.A. (only valid if showPossibleCodesMode is true)
let lastidxBeforeMouseMove = -1;

let currentCode = -1;
let codesPlayed;
let marks;
let nbOfPossibleCodes;
let colorsFoundCodes;
let minNbColorsTables;
let maxNbColorsTables;
let obviouslyImpossibleColors;
let relative_performances_of_codes_played;
let global_best_performances;
let relativePerformancesEvaluationDone;
let performancesDisplayed;
let possibleCodesLists;
let possibleCodesListsSizes;
let globalPerformancesList; // (same size as possibleCodesLists)
let PerformanceLOW = -0.25;
let PerformanceVERYLOW = -0.50;
let PerformanceNA = -3.00; // (duplicated in GameSolver.js)
let PerformanceUNKNOWN = -2.00; // (duplicated in GameSolver.js)
let PerformanceMinValidValue = -1.30; // (a valid relative performance can be < -1.00 in some extremely rare (impossible code) cases - duplicated in GameSolver.js)
let PerformanceMaxValidValue = +1.30; // (a valid relative performance can be > 0.00 in some rare (impossible code) cases - duplicated in GameSolver.js)
let nbOfStatsFilled_NbPossibleCodes = 0;
let nbOfStatsFilled_ListsOfPossibleCodes = 0;
let nbOfStatsFilled_Perfs = 0;
let currentAttemptNumber = 1;

let gameWon = false;
let timeStr = ""; // (only valid if game over)
let score = -1.0;  // (only valid if game over)
let sumPerfs = 0.00;  // (only valid if game over and all performances filled)
let nbUnknownPerfs = 0;  // (only valid if game over and all performances filled)

let sCode = -1;
let sCodeRevealed = -1;
let loadTime = (new Date()).getTime(); // time in milliseconds
let startTime = -1; // N.A.
let stopTime = -1; // N.A.
let newGameEvent = true;
let nbOnGoingGamesAborted = 0;
let nbGamesAbortedWithOnGoingWorker = 0;
let lastGameWasAbortedWithOnGoingWorker = false;
let nbNewGameEvents = 1;
let nbNewGameEventsCancelled = 0;
let playerWasHelped = false;

let gameErrorStr = "";
let gameErrorCnt = 0;
let globalErrorCnt = 0;

let nb_random_codes_played = 0;
let at_least_one_useless_code_played = false;

let game_cnt = 0;

let gameSolver = undefined;
let gameSolverDbg = -1; // (debug value)

let gameSolverInitMsgContents = null;
let gameSolverConfigDbg = null;
let game_id_for_gameSolverConfig = -1;
let game_id_for_initGameSolver = -1;

let isWorkerAlive = -2; // (debug value)
let workerCreationTime = -1; // (debug value)

// GUI variables
// *************

let newGameButtonIniName = document.getElementById("newGameButton").value;
let nbColumnsRadioObjectIniNames = new Array(nbMaxColumns-nbMinColumns+1);
for (let i = nbMinColumns; i <= nbMaxColumns; i++) {
  nbColumnsRadioObjectIniNames[i-nbMinColumns] = document.getElementById("columnslabel_" + i).innerHTML;
}
let resetCurrentCodeButtonIniName = document.getElementById("resetCurrentCodeButton").value;
let playRandomCodeButtonIniName = document.getElementById("playRandomCodeButton").value;
let revealSecretColorButtonIniName = document.getElementById("revealSecretColorButton").value;
let showPossibleCodesButtonIniName = document.getElementById("showPossibleCodesButton").value;
let showPossibleCodesButtonCompressedName = "\u2606";
let showPossibleCodesButtonBackToGameName = "Back to game";
let showPossibleCodesButtonBackToGameCompressedName = "\u25c0";

let randomCodesHintToBeDisplayed = true;

let tableIniWidth = document.getElementById("my_table").style.width;
let tableIniLeft = document.getElementById("my_table").style.left;
let tableIniHeight = document.getElementById("my_table").style.height;
let tableIniTop = document.getElementById("my_table").style.top;
let tableIniBorder = document.getElementById("my_table").style.border;
let tableIniBorderRadius = document.getElementById("my_table").style["border-radius"];
let myCanvasIniWidth = document.getElementById("my_canvas").style.width;
let myCanvasIniHeight = document.getElementById("my_canvas").style.height;

let CompressedDisplayMode = false;
let CompressedDisplayMode_compressWidth = 477;
let CompressedDisplayMode_uncompressWidth = 944;

// Widths and heights
// ******************

let left_border_margin_x = -1.0;   // N.A. - Left border margin for x axis in %
let right_border_margin_x = -1.0;  // N.A. - Right border margin for x axis in %
let bottom_border_margin_y = -1.0; // N.A. - Bottom border margin for y axis in %
let top_border_margin_y = -1.0;    // N.A. - Top border margin for y axis in %

let current_width = -1; // N.A.
let width_shift;
let reduced_width;
let current_height = -1; // N.A.
let height_shift;
let reduced_height;
let x_axis_height;

let x_min = 0.0;
let x_max = 100.0;
let y_min = 0.0;
let y_max = 100.0;

let x_step = 1.0; // N.A.
let y_step = 1.0; // N.A.

let attempt_nb_width = 2;
let nb_possible_codes_width = 5;
let optimal_width = 4;
let tick_width = 3;
let transition_height = 1;
let scode_height = 1;
let nb_attempts_not_displayed = 0;

// Colors
// ******

let greenColor = "#008200"; // Green
let orangeColor = "#FF7700"; // Orange
let redColor = "#F00000"; // Red
let backgroundColorTable =
    [
    "#0000A8",   // Blue
    greenColor,  // Green
    redColor,    // Red
    orangeColor, // Orange
    "#954400",   // Brown
    "#000000",   // Black
    "#F0F0F0",   // White (gray)
    "#EAEA00",   // Yellow
    "#C900A1",   // Purple
    "#2DB7E5"    // Cyan
    ];
let foregroundColorTable =
    [ "white",
      "white",
      "white",
      "white",
      "white",
      "white",
      "black",
      "black",
      "white",
      "white"
    ];

let backgroundColor_2 = document.getElementById("my_table").style.backgroundColor; // (may be modified later on)
let backgroundColor_3 = "#D0D0D0"; // (may be modified later on)
let lightGray = "#909090"; // (shall be significantly darker than backgroundColor_2)
let darkGray = "#000000"; // (shall be significantly darker than lightGray)
let highlightColor = "#FFFF00"; // Yellow

// Fonts
// *****

let fontFamily = "Verdana";
let defaultFont = "10px " + fontFamily;
let min_font_size = 7; // (font size below 7 may not be easily readable in canvas)
let max_font_size = 222;
let basic_font = defaultFont;
let basic_bold_font = defaultFont;
let basic_bold_italic_font = defaultFont;
let small_basic_font = defaultFont;
let small_bold_font = defaultFont;
let small_italic_font = defaultFont;
let very_small_italic_font = defaultFont;
let medium_basic_font = defaultFont;
let medium_bold_font = defaultFont;
let medium2_bold_font = defaultFont;
let medium_bold_italic_font = defaultFont;
let stats_font = defaultFont;
let error_font = defaultFont;
let font_size = min_font_size;
let star_font_size = min_font_size;

// Other variables
// ****************

let main_graph_update_needed = true;
let color_selection_code = 0;
let color_cnt = 0;

let tickChar = "\u2714"; /* (check mark/tick) */
let crossChar = "\u2716"; /* (cross) */

let firefoxMode = (navigator.userAgent.toUpperCase().search("FIREFOX") != -1);
let edgeMode = (navigator.userAgent.toUpperCase().search("EDGE/") != -1);

// Precalculated table for 5 columns
// *********************************

let precalculated_games_5columns_1st_level = new Array(nbMaxColumns+1);
for (let i = 0; i < nbMaxColumns+1; i++) {
  precalculated_games_5columns_1st_level[i] = new Array(nbMaxColumns+1);
}
precalculated_games_5columns_1st_level[3][0] =
  "1|11112:3B0W|N:438|11133:637,11134:5B9,11222:66D,11232:5C9,11332:61F,11342:5B0,11111:750,11113:6B5,11121:6FF,11122:6BE,11123:659,11131:665,11132:689,11221:699,11223:5C5,11231:647,11233:5F7,11234:587,11331:619,11333:640,11334:59A,11341:598,11343:59B,11345:54C,12221:68C,12222:68C,12223:5D6,12231:5DB,12232:5C4,12233:5B6,12234:55C,12331:60E,12332:5B4,12333:60F,12334:57B,12341:5A6,12342:560,12343:577,12345:53C,13331:656,13332:63A,13333:65C,13334:5B6,13341:5B5,13342:594,13343:5B3,13344:58F,13345:548,13451:569,13452:558,13453:548,13456:531,22221:6CD,22222:6CD,22223:623,22231:60B,22232:60E,22233:5E6,22234:58F,22331:5F1,22332:5E3,22333:5F4,22334:57A,22341:59E,22342:587,22343:57A,22345:54B,23331:652,23332:5FC,23333:658,23334:5BB,23341:5B8,23342:579,23343:5AE,23344:594,23345:55D,23451:586,23452:559,23453:560,23456:550,33331:6A6,33332:689,33333:6AC,33334:5F7,33341:5ED,33342:5D4,33343:5ED,33344:5CA,33345:577,33441:5CF,33442:5B3,33443:5CD,33445:568,33451:585,33452:568,33453:580,33454:569,33456:54D,34561:578,34562:558,34563:562,34567:572." +
  "1|11122:3B0W|N:412|11111:683,11113:5E2,11133:5D6,11134:565,11323:58B,11324:522,12222:629,12322:581,13322:59C,13422:53A,11112:680,11123:5E9,11211:651,11212:659,11213:5B2,11222:654,11223:5B9,11233:587,11234:51F,11311:5AD,11312:5B2,11313:590,11314:522,11322:5F1,11333:5A8,11334:513,11344:513,11345:4CE,12211:658,12212:62C,12213:5B0,12223:567,12233:571,12234:519,12311:59E,12312:5AE,12313:57A,12314:519,12323:56C,12324:50A,12333:5A3,12334:518,12344:51C,12345:4D9,13311:583,13312:57F,13313:597,13314:50D,13323:5A3,13324:517,13333:5DD,13334:540,13344:52F,13345:4E5,13411:51F,13412:517,13413:50C,13415:4CE,13423:517,13425:4D4,13433:543,13434:52C,13435:4E4,13455:4E6,13456:4D5,22211:659,22212:63D,22213:5A2,22222:65A,22223:59C,22233:58D,22234:535,22311:5CC,22312:588,22313:586,22314:538,22322:5A5,22323:56D,22324:50A,22333:59B,22334:523,22344:523,22345:4F0,23311:59E,23312:58E,23313:5BC,23314:542,23322:588,23323:599,23324:511,23333:5D4,23334:543,23344:52C,23345:4F9,23411:540,23412:52E,23413:539,23415:508,23422:522,23423:50D,23425:4CF,23433:53B,23434:52A,23435:4F4,23455:4F4,23456:4E8,33311:5C6,33312:5BC,33313:5F3,33314:566,33322:5D3,33323:5CB,33324:537,33333:60F,33334:56F,33344:55C,33345:513,33411:534,33412:52D,33413:55E,33414:542,33415:50C,33422:533,33423:52F,33424:512,33425:4D1,33433:56B,33434:551,33435:50B,33444:551,33445:4FE,33455:4FF,33456:4EF,34511:508,34512:4EE,34513:508,34516:4FA,34522:4FA,34523:4D2,34526:4CA,34533:50A,34534:4FD,34536:4EF,34566:4F2,34567:511.";
precalculated_games_5columns_1st_level[2][0] =
  "1|11111:2B0W|N:3430|11222:3729,11223:336B,11234:32AB,11112:39B9,11122:3757,11123:34C7,12222:3896,12223:3407,12233:332C,12234:322A,12345:3218,22222:3BA2,22223:364A,22233:34B3,22234:33A9,22334:32C6,22345:329A,23456:3332.";
precalculated_games_5columns_1st_level[2][1] =
  "1|11112:2B1W|N:684|11223:912,11233:910,11234:87F,11331:935,11341:897,11111:AF9,11113:A17,11121:AAD,11122:A7D,11123:9C2,11131:99F,11132:9E9,11133:95D,11134:8DD,11221:A43,11222:A23,11231:980,11232:90A,11332:92D,11333:96B,11334:89B,11342:89B,11343:892,11345:835,12221:A5E,12222:A5E,12223:94C,12231:923,12232:927,12233:8EA,12234:860,12331:927,12332:8F2,12333:92F,12334:86D,12341:88B,12342:86E,12343:867,12345:808,13331:97E,13332:969,13333:9A9,13334:8D4,13341:8A0,13342:89C,13343:8C2,13344:897,13345:84C,13451:850,13452:857,13453:846,13456:839,22221:AC0,22222:AC0,22223:9CC,22231:987,22232:97B,22233:93F,22234:8B4,22331:921,22332:924,22333:924,22334:86E,22341:89B,22342:89F,22343:86D,22345:81B,23331:97E,23332:93F,23333:984,23334:8B9,23341:89A,23342:882,23343:8AA,23344:87F,23345:831,23451:85D,23452:855,23453:833,23456:829,33331:9CF,33332:9CF,33333:A17,33334:93C,33341:8E8,33342:8EE,33343:928,33344:8F2,33345:89F,33441:8BB,33442:8C4,33443:8E6,33445:887,33451:873,33452:88D,33453:892,33454:878,33456:86F,34561:883,34562:89B,34563:875,34567:8B6." +
  "1|11122:2B1W|N:1026|11233:DD3,11234:D03,11311:E2A,11313:DA9,11314:CF0,12223:DA6,12323:D7E,12324:CB3,13312:DA6,13412:CEB,11111:1033,11112:FE6,11113:E64,11123:EBC,11133:E4C,11134:D75,11211:FB2,11212:FC9,11213:E1D,11222:FA3,11223:E31,11312:E11,11322:EA5,11323:DD0,11324:D13,11333:E09,11334:CFA,11344:CFE,11345:C91,12211:FED,12212:F68,12213:E29,12222:F7F,12233:D9C,12234:CBF,12311:E21,12312:E15,12313:DAE,12314:CE2,12322:DC7,12333:DF5,12334:CD1,12344:CCE,12345:C58,13311:DAE,13313:DE1,13314:CD6,13322:DC0,13323:DFC,13324:CE3,13333:E85,13334:D4B,13344:D26,13345:CAF,13411:CE5,13413:CD6,13415:C6D,13422:D05,13423:CD6,13425:C61,13433:D4C,13434:D16,13435:CA1,13455:CAC,13456:C95,22211:1046,22212:FB5,22213:E6D,22222:1021,22223:E2F,22233:E23,22234:D35,22311:EA3,22312:DD9,22313:DD3,22314:D11,22322:E3C,22323:D95,22324:CCF,22333:DF5,22334:CD1,22344:CD7,22345:C68,23311:DEF,23312:DA3,23313:E25,23314:D00,23322:DCA,23323:DC5,23324:CB9,23333:E64,23334:D2A,23344:CF9,23345:C90,23411:D34,23412:CDD,23413:CF7,23415:C82,23422:D0D,23423:CB0,23425:C40,23433:D26,23434:CF1,23435:C87,23455:C8F,23456:C8B,33311:E51,33312:E2C,33313:EA4,33314:D80,33322:E54,33323:E6C,33324:D4C,33333:F24,33334:DDD,33344:DAF,33345:D26,33411:D2D,33412:CF4,33413:D61,33414:D23,33415:CC8,33422:D16,33423:D32,33424:CF6,33425:C8F,33433:DD8,33434:D86,33435:D0B,33444:D83,33445:CEE,33455:CF5,33456:CEA,34511:CC3,34512:C8C,34513:CBD,34516:CBF,34522:CC8,34523:C88,34526:C89,34533:D0E,34534:CEC,34536:CE5,34566:CED,34567:D42.";
precalculated_games_5columns_1st_level[2][0] =
  "1|11112:2B0W|N:2668|11333:27A5,11334:2544,11343:2529,11345:24B6,12222:2AB1,12232:273F,12332:26C8,12342:25C7,13332:2893,13342:25EE,13452:258B,11111:2E9D,11113:2B1E,11121:2CD6,11122:2BFE,11123:2956,11131:295A,11132:2A20,11133:2864,11134:26CC,11221:2B18,11222:2ADF,11223:27D1,11231:28E0,11232:27EA,11233:27E8,11234:2655,11331:27C9,11332:288D,11341:262A,11342:26EA,12221:2B8B,12223:279D,12231:2840,12233:26AD,12234:25AA,12331:2867,12333:27BC,12334:257B,12341:26B5,12343:257C,12345:2525,13331:283A,13333:291B,13334:2634,13341:258E,13343:25F8,13344:2558,13345:24B8,13451:2522,13453:24BA,13456:24BB,22221:2CAB,22222:2CAB,22223:2964,22231:28D4,22232:2885,22233:27AB,22234:26B5,22331:27FD,22332:278F,22333:27BB,22334:25FE,22341:2700,22342:2656,22343:25EF,22345:256E,23331:293D,23332:27F3,23333:295B,23334:26AC,23341:26B6,23342:25DF,23343:2651,23344:25CF,23345:253E,23451:2655,23452:258C,23453:2540,23456:2546,33331:2AA2,33332:2A97,33333:2B28,33334:27AA,33341:2742,33342:26EA,33343:273B,33344:2672,33345:25A3,33441:268F,33442:263C,33443:264F,33445:2514,33451:25DB,33452:2571,33453:258C,33454:24FE,33456:24E1,34561:25DD,34562:256D,34563:24E7,34567:2551." +
  "1|11122:2B0W|N:2287|11333:20EA,11334:1EF4,11344:1F0F,11345:1E99,13323:20CA,13324:1EDE,13423:1ECC,13425:1E7C,22222:256B,22322:222B,23322:2170,23422:2026,33322:220D,33422:1FC5,34522:1F53,11111:2603,11112:25F5,11113:22D6,11123:22CA,11133:21F2,11134:2097,11211:2537,11212:255C,11213:2210,11222:25AF,11223:2245,11233:213A,11234:2006,11311:21E6,11312:221A,11313:2102,11314:1FD4,11322:22FF,11323:213C,11324:200F,12211:25C7,12212:2501,12213:2287,12222:2489,12223:2154,12233:20FF,12234:1FE7,12311:224B,12312:2238,12313:2167,12314:2049,12322:21AF,12323:20C2,12324:1FB0,12333:20AE,12334:1ED2,12344:1EE6,12345:1E9F,13311:210F,13312:2124,13313:20DE,13314:1F05,13322:2146,13333:21A5,13334:1F4C,13344:1ED0,13345:1E44,13411:1FF5,13412:1FF7,13413:1EF5,13415:1EA2,13422:2019,13433:1F54,13434:1EBB,13435:1E34,13455:1E4A,13456:1E66,22211:26CC,22212:253C,22213:22DD,22223:21FB,22233:2172,22234:208F,22311:23A9,22312:221E,22313:21E4,22314:20F2,22323:20FA,22324:1FD6,22333:2171,22334:1FC1,22344:1FDD,22345:1F78,23311:224C,23312:218E,23313:21A1,23314:1FE9,23323:2132,23324:1F5D,23333:2210,23334:1FC2,23344:1F35,23345:1EDF,23411:2144,23412:2050,23413:1FD9,23415:1FA7,23423:1F4B,23425:1EE6,23433:1FAE,23434:1F36,23435:1ED2,23455:1ED9,23456:1F02,33311:21D0,33312:215E,33313:22A0,33314:201B,33323:21F1,33324:1FA1,33333:23CF,33334:20A6,33344:2001,33345:1F57,33411:1FD2,33412:1F5A,33413:2007,33414:1F6F,33415:1F02,33423:1F75,33424:1EE5,33425:1E6D,33433:209E,33434:1FD0,33435:1F35,33444:1FCC,33445:1EC5,33455:1EC5,33456:1EC2,34511:1FA8,34512:1F16,34513:1F15,34516:1F27,34523:1E67,34526:1E85,34533:1F2B,34534:1EC9,34536:1EC0,34566:1ED0,34567:1F4E.";
precalculated_games_5columns_1st_level[1][2] =
  "1|11112:1B2W|N:508|12221:7B1,12231:6E0,12331:729,12341:6AF,11113:829,11121:834,11122:7C7,11123:77E,11131:7A5,11132:7A5,11133:776,11134:702,11221:7C3,11222:7AD,11223:6F9,11231:74F,11232:6DE,11233:71A,11234:698,11331:74D,11332:74D,11333:74D,11334:6A3,11341:6BD,11342:6BD,11343:693,11345:650,12222:7B2,12223:6F2,12232:6D0,12233:6B9,12234:64A,12332:6C9,12333:72A,12334:68A,12342:664,12343:683,12345:645,13331:776,13332:776,13333:776,13334:6D9,13341:6BC,13342:6BC,13343:6BC,13344:69D,13345:659,13451:673,13452:673,13453:65C,13456:651,22221:844,22222:844,22223:7AB,22231:727,22232:727,22233:6F9,22234:69C,22331:6DD,22332:6D0,22333:6DD,22334:656,22341:66E,22342:662,22343:64E,22345:629,23331:77E,23332:709,23333:77E,23334:6D5,23341:6BA,23342:673,23343:6BA,23344:69C,23345:65D,23451:67B,23452:64D,23453:663,23456:651,33331:801,33332:801,33333:801,33334:77B,33341:722,33342:722,33343:722,33344:705,33345:6C2,33441:6F8,33442:6F8,33443:6F8,33445:69D,33451:6A7,33452:6A7,33453:6A7,33454:693,33456:682,34561:69F,34562:69F,34563:690,34567:6A8." +
  "1|11122:1B2W|N:902|12233:BDB,12234:B32,12313:BCD,12314:B1D,13311:C1E,13411:B69,22212:DB4,22312:BFB,23312:BD4,23412:B26,11111:E43,11112:E0A,11113:CA4,11123:D08,11133:C85,11134:BD4,11211:DC0,11212:DB4,11213:C2D,11222:DB4,11223:C79,11233:C00,11234:B3D,11311:C88,11312:C6A,11313:BEA,11314:B47,11322:CDA,11323:C2A,11324:B87,11333:C3F,11334:B44,11344:B47,11345:AE4,12211:DF7,12212:D85,12213:C5D,12222:D85,12223:BFB,12311:C52,12312:C5B,12322:C09,12323:BD4,12324:B2A,12333:C25,12334:B2B,12344:B2B,12345:ACB,13312:BF3,13313:C13,13314:B28,13322:C1B,13323:C59,13324:B62,13333:CB5,13334:B97,13344:B6F,13345:B07,13412:B40,13413:B1E,13415:AB7,13422:B78,13423:B58,13425:B03,13433:B98,13434:B64,13435:B01,13455:B0A,13456:AFF,22211:E51,22213:C6D,22222:E16,22223:C95,22233:C47,22234:B9E,22311:CDF,22313:BD8,22314:B3B,22322:C59,22323:BE4,22324:B43,22333:C0A,22334:B26,22344:B2C,22345:AD3,23311:C2E,23313:C3B,23314:B44,23322:BF0,23323:C0F,23324:B2A,23333:C82,23334:B78,23344:B4F,23345:AF7,23411:B7B,23413:B3A,23415:AE1,23422:B3F,23423:B24,23425:ABE,23433:B75,23434:B3E,23435:AEC,23455:AF8,23456:AF2,33311:C90,33312:C7F,33313:CC7,33314:BC7,33322:C7E,33323:CC3,33324:BC5,33333:D4B,33334:C24,33344:BFD,33345:B8C,33411:B61,33412:B50,33413:B9D,33414:B69,33415:B16,33422:B76,33423:BA8,33424:B6F,33425:B2B,33433:C11,33434:BD0,33435:B6B,33444:BD0,33445:B53,33455:B5B,33456:B56,34511:B1C,34512:AF7,34513:B11,34516:B07,34522:B20,34523:B2A,34526:B28,34533:B6D,34534:B4B,34536:B4C,34566:B59,34567:BA2.";
precalculated_games_5columns_1st_level[1][1] =
  "1|11112:1B1W|N:3912|12223:3AC6,12233:3917,12234:37B4,12333:3AB3,12334:37E8,12343:37BC,12345:377E,13331:3C26,13341:38CF,13451:386F,11111:4562,11113:4111,11121:420E,11122:4078,11123:3D6D,11131:3DA7,11132:3EE0,11133:3C61,11134:3A66,11221:3F87,11222:3F61,11223:3AE4,11231:3C74,11232:3B19,11233:3B38,11234:391E,11331:3B6F,11332:3C61,11333:3B3D,11334:381D,11341:393F,11342:3A2B,11343:3803,11345:3773,12221:4053,12222:3F49,12231:3B2D,12232:3A33,12331:3B92,12332:396B,12341:3984,12342:3837,13332:3C20,13333:3D60,13334:3989,13342:38E5,13343:3933,13344:3833,13345:37AB,13452:38A2,13453:3790,13456:37E2,22221:439A,22222:439A,22223:3E89,22231:3C5F,22232:3C5A,22233:3AF3,22234:3989,22331:3A15,22332:3A45,22333:3A40,22334:37E4,22341:38E3,22342:38FD,22343:37CD,22345:3777,23331:3C44,23332:3AE5,23333:3CE0,23334:3964,23341:38E9,23342:3889,23343:390A,23344:3820,23345:37B6,23451:38AC,23452:3855,23453:37A6,23456:380B,33331:3F36,33332:3F36,33333:418A,33334:3CB1,33341:3A95,33342:3AD7,33343:3BE8,33344:3A3D,33345:398B,33441:3981,33442:39B2,33443:3A28,33445:38B5,33451:38E8,33452:3942,33453:3936,33454:386D,33456:387F,34561:3988,34562:39F7,34563:3882,34567:3957." +
  "1|11122:1B1W|N:4548|12333:4375,12334:4081,12344:40A2,12345:4023,13313:431D,13314:4008,13413:3FFB,13415:3F99,22223:4523,22323:4292,22324:40C6,23323:4303,23324:4012,23423:4000,23425:3F91,33312:4489,33412:4109,34512:40D4,11111:4D05,11112:4BBB,11113:4620,11123:47A2,11133:4470,11134:427A,11211:4A9B,11212:4B54,11213:4476,11222:4C04,11223:45D2,11233:4363,11234:4193,11311:456B,11312:44F3,11313:435A,11314:4159,11322:4884,11323:444B,11324:4277,11333:4331,11334:4013,11344:4041,11345:3FA7,12211:4CB5,12212:4A6D,12213:45C3,12222:49C4,12223:43D0,12233:436A,12234:418C,12311:44D7,12312:4581,12313:4334,12314:416E,12322:4456,12323:434B,12324:418E,13311:4367,13312:439A,13322:4457,13323:4372,13324:40C2,13333:4563,13334:4186,13344:40C0,13345:4002,13411:4180,13412:41B7,13422:4285,13423:4098,13425:4050,13433:4171,13434:40A3,13435:3FF4,13455:400E,13456:4043,22211:504A,22212:4AC5,22213:46B6,22222:4C38,22233:439D,22234:41BB,22311:4816,22312:443C,22313:4421,22314:424D,22322:449F,22333:42FD,22334:3FF4,22344:4018,22345:3F73,23311:4419,23312:4394,23313:4360,23314:40BA,23322:42B4,23333:4584,23334:4199,23344:40E3,23345:4027,23411:4248,23412:41C6,23413:4090,23415:4044,23422:4105,23433:418B,23434:40BE,23435:400B,23455:4025,23456:405C,33311:4431,33313:4598,33314:41BF,33322:443A,33323:45B2,33324:41F5,33333:4AC7,33334:4470,33344:436F,33345:423E,33411:40AC,33413:4184,33414:40AB,33415:402B,33422:40B4,33423:41BC,33424:40D0,33425:4044,33433:4459,33434:42F3,33435:41FB,33444:42F3,33445:413E,33455:4167,33456:4156,34511:409A,34513:4022,34516:4079,34522:40A3,34523:403A,34526:408C,34533:4205,34534:4134,34536:414B,34566:4173,34567:4239.";
precalculated_games_5columns_1st_level[1][0] =
  "1|11111:1B0W|N:12005|12222:D2F7,12223:C5F8,12233:C277,12234:C1BF,12345:C394,11112:D7AB,11122:CE0C,11123:C8A5,11222:CD81,11223:C39F,11234:C325,22222:DFAE,22223:CD3D,22233:C783,22234:C56E,22334:C2F9,22345:C377,23456:C649." +
  "1|11112:1B0W|N:7585|13333:794D,13334:72C0,13343:7237,13344:7073,13345:7047,13453:7042,13456:7191,22222:8719,22232:7C46,22332:78C7,22342:768A,23332:798C,23342:7421,23452:7457,33332:7EF9,33342:75B7,33442:73FE,33452:72E6,34562:7418,11111:8B14,11113:80BD,11121:8752,11122:8600,11123:7D1F,11131:7D2A,11132:7F40,11133:7938,11134:76A2,11221:83B6,11222:82EC,11223:7A85,11231:7C3F,11232:7A9A,11233:7864,11234:75CE,11331:7819,11332:7944,11333:77A1,11334:7271,11341:757A,11342:7688,11343:723F,11345:7298,12221:8511,12222:8389,12223:7B82,12231:7BE1,12232:79D7,12233:77B8,12234:75E9,12331:79A8,12332:7733,12333:7911,12334:73B4,12341:7722,12342:7565,12343:7360,12345:73DA,13331:78B8,13332:797F,13341:7316,13342:739A,13451:739C,13452:73DA,22221:898C,22223:7DB6,22231:7ECF,22233:7926,22234:7720,22331:7ADD,22333:78E1,22334:7412,22341:7919,22343:73D5,22345:7400,23331:7C8C,23333:7BD4,23334:751A,23341:763C,23343:7488,23344:732E,23345:7268,23451:7678,23453:7263,23456:7344,33331:7D17,33333:8230,33334:782B,33341:7477,33343:770C,33344:73F0,33345:72F4,33441:72A9,33443:73B5,33445:7188,33451:7213,33453:7298,33454:7125,33456:71D9,34561:73B1,34563:71C8,34567:73E1." +
  "1|11122:1B0W|N:6480|13333:6449,13334:5EE6,13344:5D8B,13345:5D5F,13433:5EFA,13434:5D9A,13435:5D36,13455:5D58,13456:5E72,33323:65DD,33324:5FF7,33423:5FB6,33424:5E62,33425:5DD6,34523:5DB3,34526:5E9F,11111:7201,11112:7363,11113:6909,11123:6A2D,11133:6570,11134:6328,11211:7187,11212:717E,11213:6876,11222:735F,11223:684A,11233:64D5,11234:62B8,11311:67A0,11312:6847,11313:641B,11314:61F9,11322:6A07,11323:6496,11324:627A,11333:63CD,11334:5F3A,11344:5F5B,11345:5F4E,12211:735F,12212:717E,12213:6A0F,12222:7187,12223:6864,12233:6624,12234:644D,12311:69F8,12312:6843,12313:661A,12314:641A,12322:686F,12323:649F,12324:62A0,12333:65A3,12334:60F1,12344:60E1,12345:6110,13311:6434,13312:64A1,13313:63AE,13314:5FBC,13322:64C3,13323:642C,13324:5FB3,13411:62C2,13412:62BB,13413:5FAB,13415:5FF7,13422:62BA,13423:5F98,13425:5FDC,22212:7363,22213:6D2D,22222:7201,22223:6928,22233:666F,22234:651F,22311:6D1B,22312:6A24,22313:68CA,22314:66DC,22322:6905,22323:6575,22324:638D,22333:6525,22334:6166,22344:617F,22345:619E,23311:68C3,23312:6632,23313:6855,23314:6367,23322:6590,23323:6510,23324:60B0,23333:6593,23334:602D,23344:5F04,23345:5EB5,23411:66E7,23412:645F,23413:6339,23415:6341,23422:6347,23423:607D,23425:6065,23433:601D,23434:5F0E,23435:5E7F,23455:5E95,23456:5F6A,33311:64FE,33312:65D4,33313:6585,33314:603E,33322:65F4,33333:6C29,33334:62E9,33344:6053,33345:5F75,33411:614B,33412:610E,33413:5FED,33414:5E8C,33415:5E92,33422:6083,33433:6299,33434:6032,33435:5F27,33444:6000,33445:5E2B,33455:5E0C,33456:5EBE,34511:61DC,34512:6168,34513:5E8D,34516:5FE3,34522:6078,34533:5F12,34534:5E0D,34536:5E76,34566:5E8C,34567:6079.";
precalculated_games_5columns_1st_level[0][3] =
  "1|11122:0B3W|N:336|22213:48B,22313:447,22314:3FE,23311:456,23411:40B,11111:533,11112:526,11113:4A5,11123:4B4,11133:493,11134:459,11211:50A,11212:512,11213:472,11222:51C,11223:4AC,11233:45C,11234:420,11311:4AC,11312:498,11313:473,11314:426,11322:4D1,11323:482,11324:44B,11333:486,11334:42F,11344:42E,11345:407,12211:52C,12212:503,12213:491,12222:503,12223:476,12233:468,12234:419,12311:47A,12312:492,12313:444,12314:3FF,12322:477,12323:457,12324:416,12333:47E,12334:40F,12344:414,12345:3E4,13311:486,13312:472,13313:473,13314:408,13322:485,13323:4A3,13324:440,13333:4AD,13334:43D,13344:425,13345:402,13411:430,13412:422,13413:400,13415:3D4,13422:43E,13423:438,13425:410,13433:433,13434:421,13435:3FC,13455:3F9,13456:3F6,22211:542,22212:514,22222:528,22223:4A4,22233:482,22234:42D,22311:4B1,22312:460,22322:477,22323:44E,22324:401,22333:466,22334:3F3,22344:3F4,22345:3BE,23312:446,23313:46B,23314:3F3,23322:451,23323:456,23324:3F1,23333:487,23334:40D,23344:3FE,23345:3CC,23412:3FF,23413:3F4,23415:3C3,23422:404,23423:3EF,23425:3C5,23433:40A,23434:3F7,23435:3C9,23455:3C9,23456:3C7,33311:493,33312:48C,33313:492,33314:41C,33322:493,33323:4B1,33324:445,33333:4BA,33334:443,33344:430,33345:3FF,33411:418,33412:413,33413:411,33414:3F8,33415:3CB,33422:41A,33423:434,33424:41F,33425:3FC,33433:437,33434:421,33435:3F2,33444:41F,33445:3EA,33455:3E5,33456:3E6,34511:3EE,34512:3E2,34513:3C8,34516:3C8,34522:3FC,34523:3F7,34526:3F2,34533:3ED,34534:3E6,34536:3E1,34566:3E1,34567:407.";
precalculated_games_5columns_1st_level[0][2] =
  "1|11112:0B2W|N:1105|22221:124B,22231:100D,22331:F9B,22341:EF4,23331:10A1,23341:F38,23451:EF9,11113:11F2,11121:129D,11122:11B5,11123:113B,11131:11A4,11132:11A4,11133:1148,11134:10AD,11221:1165,11222:1149,11223:101F,11231:1102,11232:103F,11233:10A4,11234:FF0,11331:111E,11332:111E,11333:110E,11334:1006,11341:1054,11342:1054,11343:FEC,11345:FAB,12221:1191,12222:118B,12223:1038,12231:FF7,12232:FD2,12233:F97,12234:F1D,12331:108D,12332:FC2,12333:107C,12334:F63,12341:FC2,12342:F36,12343:F4F,12345:F15,13331:1135,13332:1135,13333:1135,13334:1006,13341:FBE,13342:FBE,13343:FB1,13344:F69,13345:F1E,13451:F7B,13452:F7B,13453:F25,13456:F1E,22222:124C,22223:10E2,22232:1009,22233:FAC,22234:F2A,22332:F7C,22333:F8A,22334:E9B,22342:ECF,22343:E9E,22345:E6E,23332:FBE,23333:10A2,23334:F60,23342:EC2,23343:F2C,23344:EE3,23345:E91,23452:E93,23453:E9B,23456:E97,33331:1191,33332:1191,33333:1191,33334:1050,33341:FC4,33342:FC4,33343:FC4,33344:F72,33345:F07,33441:F6B,33442:F6B,33443:F5E,33445:EBD,33451:EF9,33452:EF9,33453:EEE,33454:EB7,33456:EA6,34561:F00,34562:F00,34563:EB5,34567:EE6." +
  "1|11122:0B2W|N:2196|22233:2024,22234:1EE3,22333:1F60,22334:1D71,22344:1D8B,22345:1D17,23313:1F1B,23314:1D5E,23413:1D43,23415:1CFF,33311:2040,33411:1E20,34511:1DC4,11111:242E,11112:23FE,11113:20E7,11123:21BE,11133:2066,11134:1F9D,11211:235B,11212:23BA,11213:2021,11222:2439,11223:213B,11233:1F95,11234:1E9A,11311:2118,11312:20F1,11313:1FCD,11314:1EC4,11322:2262,11323:2093,11324:1FAF,11333:2012,11334:1E7B,11344:1E8C,11345:1E30,12211:2461,12212:2394,12213:20BD,12222:236E,12223:207B,12233:1FD3,12234:1EAC,12311:2070,12312:20C5,12313:1F42,12314:1E3D,12322:20C9,12323:200E,12324:1EF3,12333:1F44,12334:1D7C,12344:1D8E,12345:1D48,13311:2031,13312:2017,13313:1FAB,13314:1DEE,13322:20E2,13323:2027,13324:1E96,13333:2085,13334:1E65,13344:1DCE,13345:1D87,13411:1EF8,13412:1EF8,13413:1DE2,13415:1D7E,13422:1FF6,13423:1E88,13425:1E57,13433:1E49,13434:1DCB,13435:1D77,13455:1D79,13456:1DA4,22211:256A,22212:23FC,22213:210F,22222:240A,22223:2104,22311:2154,22312:205F,22313:1FA6,22314:1E7D,22322:2028,22323:1F47,22324:1E29,23311:1F98,23312:1F90,23322:1F56,23323:1F4B,23324:1D90,23333:2015,23334:1DD1,23344:1D58,23345:1CDE,23411:1E7D,23412:1E77,23422:1E61,23423:1D7C,23425:1D36,23433:1DD7,23434:1D44,23435:1CCC,23455:1CE5,23456:1D06,33312:1FB0,33313:203E,33314:1E0B,33322:2021,33323:20F7,33324:1EA3,33333:220D,33334:1F18,33344:1E73,33345:1DD0,33412:1DDC,33413:1DE3,33414:1D58,33415:1CEC,33422:1E5D,33423:1E8F,33424:1E01,33425:1D9E,33433:1F0E,33434:1E40,33435:1DB0,33444:1E3F,33445:1D4E,33455:1D4D,33456:1D50,34512:1DB2,34513:1CEC,34516:1D0E,34522:1E46,34523:1DB5,34526:1DDD,34533:1DAA,34534:1D4E,34536:1D53,34566:1D67,34567:1DEB.";
precalculated_games_5columns_1st_level[0][1] =
  "1|11112:0B1W|N:7926|22223:8269,22233:7B3E,22234:7961,22333:7A54,22334:7645,22343:7619,22345:7655,23333:7FC5,23334:78A3,23343:7820,23344:7620,23345:760B,23453:75F9,23456:77B2,33331:84BD,33341:7B42,33441:78ED,33451:7841,34561:79A4,11111:9225,11113:888E,11121:8EDC,11122:8B55,11123:857E,11131:8749,11132:89CF,11133:8366,11134:80D6,11221:8912,11222:8890,11223:7FE8,11231:8418,11232:8207,11233:80EC,11234:7DF7,11331:830C,11332:84E5,11333:82A5,11334:7C6D,11341:8018,11342:8204,11343:7C27,11345:7BE6,12221:8AC2,12222:894B,12223:7F88,12231:7FE7,12232:7F31,12233:7BDD,12234:7A1F,12331:7FE9,12332:7DA2,12333:8065,12334:7A0D,12341:7CFB,12342:7C26,12343:79CB,12345:79FC,13331:82C3,13332:8478,13333:8389,13334:7B5F,13341:7BEF,13342:7D8D,13343:7AE5,13344:78F9,13345:7850,13451:7BE0,13452:7DA7,13453:7834,13456:795A,22221:8F71,22222:8CFF,22231:80FA,22232:7EF6,22331:7BD6,22332:7A32,22341:7A4B,22342:78A0,23331:7F7E,23332:7B40,23341:7927,23342:775E,23451:798F,23452:77FC,33332:836A,33333:88E6,33334:7E2D,33342:7B1B,33343:7D28,33344:7986,33345:789C,33442:78C6,33443:792A,33445:7707,33452:78B6,33453:782E,33454:767E,33456:7773,34562:7AB9,34563:7760,34567:79B9." +
  "1|11122:0B1W|N:6480|23333:6449,23334:5EE6,23344:5D8B,23345:5D5F,23433:5EFA,23434:5D9A,23435:5D36,23455:5D58,23456:5E72,33313:65DD,33314:5FF7,33413:5FB6,33414:5E62,33415:5DD6,34513:5DB3,34516:5E9F,11111:7201,11112:7363,11113:6928,11123:6D2D,11133:666F,11134:651F,11211:7187,11212:717E,11213:6864,11222:735F,11223:6A0F,11233:6624,11234:644D,11311:6905,11312:6A24,11313:6575,11314:638D,11322:6D1B,11323:68CA,11324:66DC,11333:6525,11334:6166,11344:617F,11345:619E,12211:735F,12212:717E,12213:684A,12222:7187,12223:6876,12233:64D5,12234:62B8,12311:686F,12312:6843,12313:649F,12314:62A0,12322:69F8,12323:661A,12324:641A,12333:65A3,12334:60F1,12344:60E1,12345:6110,13311:6590,13312:6632,13313:6510,13314:60B0,13322:68C3,13323:6855,13324:6367,13333:6593,13334:602D,13344:5F04,13345:5EB5,13411:6347,13412:645F,13413:607D,13415:6065,13422:66E7,13423:6339,13425:6341,13433:601D,13434:5F0E,13435:5E7F,13455:5E95,13456:5F6A,22212:7363,22213:6A2D,22222:7201,22223:6909,22233:6570,22234:6328,22311:6A07,22312:6847,22313:6496,22314:627A,22322:67A0,22323:641B,22324:61F9,22333:63CD,22334:5F3A,22344:5F5B,22345:5F4E,23311:64C3,23312:64A1,23313:642C,23314:5FB3,23322:6434,23323:63AE,23324:5FBC,23411:62BA,23412:62BB,23413:5F98,23415:5FDC,23422:62C2,23423:5FAB,23425:5FF7,33311:65F4,33312:65D4,33322:64FE,33323:6585,33324:603E,33333:6C29,33334:62E9,33344:6053,33345:5F75,33411:6083,33412:610E,33422:614B,33423:5FED,33424:5E8C,33425:5E92,33433:6299,33434:6032,33435:5F27,33444:6000,33445:5E2B,33455:5E0C,33456:5EBE,34511:6078,34512:6168,34522:61DC,34523:5E8D,34526:5FE3,34533:5F12,34534:5E0D,34536:5E76,34566:5E8C,34567:6079.";
precalculated_games_5columns_1st_level[0][0] =
  "1|11111:0B0W|N:16807|22222:1362C,22223:11D1C,22233:1149F,22234:112BB,22334:10F57,22345:1109B,23456:11503." +
  "1|11112:0B0W|N:7776|33333:83D5,33334:77CB,33343:77CB,33344:73D4,33345:730E,33443:73D4,33445:71D8,33453:730E,33454:71D8,33456:72D3,34563:72D3,34567:7649.";

// *************************************************************************
// *************************************************************************
// Error handling
// *************************************************************************
// *************************************************************************

function getExtraDebugInfo() {
  return "(currentattempt:" + currentAttemptNumber
         + ", nbcodesfilled:" + nbOfStatsFilled_NbPossibleCodes
         + ", nbstatsfilled:" + nbOfStatsFilled_Perfs
         + ", gameduration:" + ((startTime > 0) ? ((new Date()).getTime() - startTime) : "NA") + "ms"
         + ", workeralive:" + isWorkerAlive + ", timesinceworkercreation: " + ((isWorkerAlive >= 0) ? (new Date()).getTime() - workerCreationTime : "NA")
         + ", currentcode:" + currentCode
         + ", nbnewgames:" + nbNewGameEvents
         + ", nbgamesplayed:" + nbGamesPlayed
         + ", nbgameswon:" + nbGamesPlayedAndWon
         + ", nbongoinggamesaborted: " + nbOnGoingGamesAborted
         + ", nbgamesabortedwithongoingworker:" + nbGamesAbortedWithOnGoingWorker
         + ", lastgamewasabortedwithongoingworker:" + lastGameWasAbortedWithOnGoingWorker
         + ", gamesolverdbg:" + gameSolverDbg + ")";
}

function displayGUIError(GUIErrorStr, errStack) {

  let completedGUIErrorStr = (GUIErrorStr + " " + getExtraDebugInfo()).trim();

  // Display error in Javascript console
  // ***********************************

  if (gameErrorCnt < 50) {
    console.log("***** ERROR (" + version + ") *****: " + completedGUIErrorStr + " / " + errStack + "\n");
    console.log("Stack:");
    let stack = new Error().stack;
    console.log(stack);
    console.log("\n");
  }
  gameErrorCnt++;

  // Submit form if very first error
  // *******************************

  let maxGlobalErrors = 5;
  if (globalErrorCnt < maxGlobalErrors) {
    try {
      var errorStr = "";
      if (typeof(Storage) !== 'undefined') {
        if (localStorage.firstname) {
          errorStr = errorStr + " for " + localStorage.firstname;
        }
        if (localStorage.firstaccessid) {
          errorStr = errorStr + " for first access id " + localStorage.firstaccessid;
        }
        if (localStorage.countryname) {
          errorStr = errorStr + " in " + localStorage.countryname;
        }
        if (localStorage.cityname) {
          errorStr = errorStr + " in " + localStorage.cityname;
        }
        if (localStorage.gamesok) {
          errorStr = errorStr + " after " + localStorage.gamesok + " game(s)";
        }
        try {
          errorStr = errorStr + " for game version " + html_compatibility_game_version;
        }
        catch (exc_gv) {}
        if (gameSolverConfigDbg != null) {
          errorStr = errorStr + " with gameSolver config " + gameSolverConfigDbg;
        }
      }

      let strGame = "";
      try {
        errorStr = errorStr + " on " + navigator.platform + " / " + navigator.userAgent + " / " + decodeURI(location.href);
        for (let i = 1; i < currentAttemptNumber; i++) {
          strGame = strGame + simpleCodeHandler.markToString(marks[i-1]) + " " + simpleCodeHandler.codeToString(codesPlayed[i-1]) + " (" + nbOfPossibleCodes[i-1]
                            + "|" + (Math.round(relative_performances_of_codes_played[i-1] * 100.0) / 100.0).toFixed(2) /* 0.01 precision */ + ") ";
        }
        strGame = strGame + "SCODE " + simpleCodeHandler.codeToString(simpleCodeHandler.convert(sCode));
        strGame = strGame.trim();
      }
      catch (game_exc) {
        strGame = strGame.trim() + " " + game_exc;
      }
      errorStr = errorStr + " for game " + strGame;

      submitForm("game error (" + (globalErrorCnt+1) + "/" + maxGlobalErrors + ")" + errorStr + ": ***** ERROR MESSAGE ***** " + completedGUIErrorStr + " / " + errStack, true);
    }
    catch (exc) {
      console.log("internal error at error form submission: " + exc);
    }
  }
  globalErrorCnt++;

  // Alert
  // *****

  if (gameErrorStr == "") { // Only one error alert is displayed per game
    gameErrorStr = "***** ERROR (" + version + ") *****: " + GUIErrorStr + " / " + errStack + "\n";
    alert(gameErrorStr);
  }

}

function displayGUIError__windowonerror(GUIErrorStr, errStack) {
  displayGUIError("window error: " + GUIErrorStr, errStack);
}
function displayGUIError__windowonmessageerror(GUIErrorStr, errStack) {
  displayGUIError("window MESSAGE error: " + GUIErrorStr, errStack);
}

window.onerror = displayGUIError__windowonerror;
window.onmessageerror = displayGUIError__windowonmessageerror;

// Function called on gameSolver worker's error
function onGameSolverError(e) {
  displayGUIError("gameSolver error: " + e.message + " at line " + e.lineno + " in " + e.filename, new Error().stack);
}

// Function called on gameSolver worker's MESSAGE error
function onGameSolverMessageError(e) {
  displayGUIError("gameSolver MESSAGE error: " + e.message + " at line " + e.lineno + " in " + e.filename, new Error().stack);
}

// *************************************************************************
// *************************************************************************
// New methods
// *************************************************************************
// *************************************************************************

// String.replaceAll() method definition
String.prototype.replaceAll = function(search, replacement) {
  let target = this;
  return target.replace(new RegExp(search, 'g'), replacement);
};

// *************************************************************************
// *************************************************************************
// Classes
// *************************************************************************
// *************************************************************************

// *************************************************************************
// "Simple" Code handler class
// *************************************************************************

class SimpleCodeHandler { // NOTE: the code of this class is partially duplicated in GameSolver.js script

  constructor(nbColumns_p, nbColors_p, nbMinColumns_p, nbMaxColumns_p, emptyColor_p) {
    if ( (nbColumns_p < Math.max(nbMinColumns_p,3)) || (nbColumns_p > Math.min(nbMaxColumns_p,7)) /* 3 and 7 is hardcoded in some methods of this class for better performances */ ) {
      throw new Error("SimpleCodeHandler: invalid nb of columns (" + nbColumns_p + ", " + nbMinColumns_p + "," + nbMaxColumns_p + ")");
    }
    if (nbColors_p < 0) {
      throw new Error("SimpleCodeHandler: invalid nb of colors: (" + nbColors_p + ")");
    }
    this.nbColumns = nbColumns_p;
    this.nbColors = nbColors_p;
    this.nbMaxColumns = nbMaxColumns_p;
    this.emptyColor = emptyColor_p;

    this.code1_colors = new Array(this.nbMaxColumns);
    this.code2_colors = new Array(this.nbMaxColumns);
    this.colors_int = new Array(this.nbMaxColumns);
  }

  getNbColumns() {
    return this.nbColumns;
  }

  getColor(code, column) {
    switch (column) {
      case 1:
        return (code & 0x0000000F);
      case 2:
        return ((code >> 4) & 0x0000000F);
      case 3:
        return ((code >> 8) & 0x0000000F);
      case 4:
        return ((code >> 12) & 0x0000000F);
      case 5:
        return ((code >> 16) & 0x0000000F);
      case 6:
        return ((code >> 20) & 0x0000000F);
      case 7:
        return ((code >> 24) & 0x0000000F);
      default:
        throw new Error("SimpleCodeHandler: getColor (" + column + ")");
    }
  }

  setColor(code, color, column)  {
    switch (column) {
      case 1:
        return ((code & 0xFFFFFFF0) | color);
      case 2:
        return ((code & 0xFFFFFF0F) | (color << 4));
      case 3:
        return ((code & 0xFFFFF0FF) | (color << 8));
      case 4:
        return ((code & 0xFFFF0FFF) | (color << 12));
      case 5:
        return ((code & 0xFFF0FFFF) | (color << 16));
      case 6:
        return ((code & 0xFF0FFFFF) | (color << 20));
      case 7:
        return ((code & 0xF0FFFFFF) | (color << 24));
      default:
        throw new Error("SimpleCodeHandler: setColor (" + column + ")");
    }
  }

  setAllColors(color1, color2, color3, color4, color5, color6, color7) {
    return color1
           | (color2 << 4)
           | (color3 << 8)
           | (color4 << 12)
           | (color5 << 16)
           | (color6 << 20)
           | (color7 << 24);
  }

  setAllColorsIdentical(color) {
    let res_code = 0;
    for (let col = 0; col < this.nbColumns; col++) {
      res_code = this.setColor(res_code, color, col+1);
    }
    return res_code;
  }

  codeToString(code) {
    let res = "[ ";
    for (let col = 0; col < this.nbColumns; col++) {
      let color = this.getColor(code, col+1);
      res = res + color + " ";
    }
    res = res + "]";
    return res;
  }

  createRandomCode(codeRevealed = 0 /* (empty code) */) {
    let nbObviouslyImpossibleColors = 0;
    for (let color = 1; color < this.nbColors+1; color++) {
      if (obviouslyImpossibleColors[color]) {
        nbObviouslyImpossibleColors++;
      }
    }
    let code = 0;
    for (let col = 0; col < this.nbColumns; col++) {
      let colorRevealed = this.getColor(codeRevealed, col+1);
      if ( (colorRevealed >= 1) && (colorRevealed <= this.nbColors)
           && (colorRevealed != this.emptyColor) ) {
        code = this.setColor(code, colorRevealed, col+1);
      }
      else {
        let color_idx = Math.floor(Math.random() * (this.nbColors - nbObviouslyImpossibleColors) + 1); // in 1 .. nb possible colors
        let selected_color = -1;
        let color_cnt = 1;
        let possiblecolor_cnt = 0;
        while (true) { // look for the color_idx th possible color
          if (!obviouslyImpossibleColors[color_cnt]) {
            possiblecolor_cnt++;
            if (possiblecolor_cnt == color_idx) {
              selected_color = color_cnt;
              break;
            }
          }
          color_cnt++;
          if (color_cnt > this.nbColors) {
            throw new Error("SimpleCodeHandler: createRandomCode (1) (" + codeRevealed + ")");
          }
        }
        if (selected_color == -1) {
          throw new Error("SimpleCodeHandler: createRandomCode (2) (" + codeRevealed + ")");
        }
        if ((nbObviouslyImpossibleColors == 0) && (selected_color != color_idx)) {
          throw new Error("SimpleCodeHandler: createRandomCode (3) (" + codeRevealed + ")");
        }
        code = this.setColor(code, selected_color, col+1);
      }
    }
    for (let col = this.nbColumns+1; col <= this.nbMaxColumns; col++) {
      code = this.setColor(code, this.emptyColor, col);
    }
    return code;
  }

  isValid(code) {
    for (let col = 0; col < this.nbColumns; col++) {
      let color = this.getColor(code, col+1);
      if ( ((color < 1) || (color > this.nbColors))
           && (color != this.emptyColor) ) {
        return false;
      }
    }
    for (let col = this.nbColumns+1; col <= this.nbMaxColumns; col++) {
      let color = this.getColor(code, col);
      if (color != this.emptyColor) {
        return false;
      }
    }
    return true;
  }

  isFullAndValid(code) {
    for (let col = 0; col < this.nbColumns; col++) {
      let color = this.getColor(code, col+1);
      if ( (color < 1) || (color > this.nbColors)
           || (color == this.emptyColor) ) {
        return false;
      }
    }
    for (let col = this.nbColumns+1; col <= this.nbMaxColumns; col++) {
      let color = this.getColor(code, col);
      if (color != this.emptyColor) {
        return false;
      }
    }
    return true;
  }

  nbEmptyColors(code) {
    let cnt = 0;
    for (let col = 0; col < this.nbColumns; col++) {
      if (this.getColor(code, col+1) == this.emptyColor) {
        cnt++;
      }
    }
    return cnt;
  }

  isEmpty(code) {
    return (code == 0); // only emptyColor in the code
  }

  replaceEmptyColor(code, emptyColorIdx, code2) {
    let cnt = 0;
    for (let col = 0; col < this.nbColumns; col++) {
      if (this.getColor(code, col+1) == this.emptyColor) {
        if (cnt == emptyColorIdx) {
          return this.setColor(code, this.getColor(code2, col+1), col+1);
        }
        cnt++;
      }
    }
    return code;
  }

  // Get a mark between 2 codes
  getMark(code1, code2) {
    let mark = {nbBlacks:0, nbWhites:0};
    this.fillMark(code1, code2, mark);
    return mark;
  }

  // Fill a mark between 2 codes in a fast way
  fillMark(code1, code2, mark) {

    let nbBlacks = 0;
    let nbWhites = 0;
    let col1, col2;

    // The below operations are unrolled for better performances
    this.colors_int[0] = true;
    this.colors_int[1] = true;
    this.colors_int[2] = true;
    this.colors_int[3] = true;
    this.colors_int[4] = true;
    this.colors_int[5] = true;
    this.colors_int[6] = true;
    this.code1_colors[0] = (code1 & 0x0000000F);
    this.code1_colors[1] = ((code1 >> 4) & 0x0000000F);
    this.code1_colors[2] = ((code1 >> 8) & 0x0000000F);
    this.code1_colors[3] = ((code1 >> 12) & 0x0000000F);
    this.code1_colors[4] = ((code1 >> 16) & 0x0000000F);
    this.code1_colors[5] = ((code1 >> 20) & 0x0000000F);
    this.code1_colors[6] = ((code1 >> 24) & 0x0000000F);
    this.code2_colors[0] = (code2 & 0x0000000F);
    this.code2_colors[1] = ((code2 >> 4) & 0x0000000F);
    this.code2_colors[2] = ((code2 >> 8) & 0x0000000F);
    this.code2_colors[3] = ((code2 >> 12) & 0x0000000F);
    this.code2_colors[4] = ((code2 >> 16) & 0x0000000F);
    this.code2_colors[5] = ((code2 >> 20) & 0x0000000F);
    this.code2_colors[6] = ((code2 >> 24) & 0x0000000F);

    for (col1 = 0; col1 < this.nbColumns; col1++) {
      if (this.code1_colors[col1] == this.code2_colors[col1]) {
        nbBlacks++;
      }
      else {
        for (col2 = 0; col2 < this.nbColumns; col2++) {
          if ((this.code1_colors[col1] == this.code2_colors[col2]) && (this.code1_colors[col2] != this.code2_colors[col2]) && this.colors_int[col2]) {
            this.colors_int[col2] = false;
            nbWhites++;
            break;
          }
        }
      }
    }

    mark.nbBlacks = nbBlacks;
    mark.nbWhites = nbWhites;

  }

  marksEqual(mark1, mark2) {
    return ( (mark1.nbBlacks == mark2.nbBlacks) && (mark1.nbWhites == mark2.nbWhites) );
  }

  markToString(mark) {
    return mark.nbBlacks + "B" + mark.nbWhites + "W";
  }

  convert(code) {
    return ~code;
  }

}

// *************************************************************************
// *************************************************************************
// Functions
// *************************************************************************
// *************************************************************************

// ***************************
// GameSolver worker functions
// ***************************

// Function called on gameSolver worker's message reception
function onGameSolverMsg(e) {

  try {

    if (e.data == undefined) {
      displayGUIError("gameSolver msg error: data is undefined", new Error().stack);
      return;
    }
    let data = e.data;

    if (data.rsp_type == undefined) {
      displayGUIError("gameSolver msg error: rsp_type is undefined", new Error().stack);
      return;
    }

    // **************************
    // Check that worker is alive
    // **************************

    if (isWorkerAlive == 0) { // first message received from worker
      if (data.rsp_type == 'I_AM_ALIVE') {
        isWorkerAlive = 1;
      }
      else {
        displayGUIError("gameSolver msg message error: invalid worker initialization (" + data.rsp_type + ")", new Error().stack);
        return;
      }
    }

    // ************************
    // Number of possible codes
    // ************************

    else if (data.rsp_type == 'NB_POSSIBLE_CODES') {

      if (data.nbOfPossibleCodes_p == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: nbOfPossibleCodes_p is undefined", new Error().stack);
      }
      let nbOfPossibleCodes_p = Number(data.nbOfPossibleCodes_p);
      if ( isNaN(nbOfPossibleCodes_p) || (nbOfPossibleCodes_p < 0) ) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid nbOfPossibleCodes_p: " + nbOfPossibleCodes_p, new Error().stack);
      }

      if (data.colorsFoundCode_p == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: colorsFoundCode_p is undefined", new Error().stack);
      }
      let colorsFoundCode_p = Number(data.colorsFoundCode_p);
      if (isNaN(colorsFoundCode_p)) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid colorsFoundCode_p: " + colorsFoundCode_p, new Error().stack);
      }

      if (data.minNbColorsTable_p == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: minNbColorsTable_p is undefined", new Error().stack);
      }
      let minNbColorsTable_p = (data.minNbColorsTable_p).split(",");
      if (minNbColorsTable_p.length != nbColors+1) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid minNbColorsTable_p: " + data.minNbColorsTable_p + ", length is " + minNbColorsTable_p.length, new Error().stack);
      }

      if (data.maxNbColorsTable_p == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: maxNbColorsTable_p is undefined", new Error().stack);
      }
      let maxNbColorsTable_p = (data.maxNbColorsTable_p).split(",");
      if (maxNbColorsTable_p.length != nbColors+1) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid maxNbColorsTable_p: " + data.maxNbColorsTable_p + ", length is " + maxNbColorsTable_p.length, new Error().stack);
      }

      if (data.attempt_nb == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: attempt_nb is undefined", new Error().stack);
      }
      let attempt_nb = Number(data.attempt_nb);
      if ( isNaN(attempt_nb) || (attempt_nb <= 0) ) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid attempt_nb: " + attempt_nb, new Error().stack);
      }

      if (data.game_id == undefined) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: game_id is undefined", new Error().stack);
      }
      let game_id = Number(data.game_id);
      if ( isNaN(game_id) || (game_id < 0) ) {
        displayGUIError("NB_POSSIBLE_CODES / gameSolver msg error: invalid game_id: " + game_id, new Error().stack);
      }

      writeNbOfPossibleCodes(nbOfPossibleCodes_p, colorsFoundCode_p, minNbColorsTable_p, maxNbColorsTable_p, attempt_nb, game_id);

    }

    // **********************
    // List of possible codes
    // **********************

    else if (data.rsp_type == 'LIST_OF_POSSIBLE_CODES') {

      if (data.possibleCodesList_p == undefined) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: possibleCodesList_p is undefined", new Error().stack);
      }
      let possibleCodesList_p = (data.possibleCodesList_p).split(",");
      if ( (possibleCodesList_p.length <= 0) || (possibleCodesList_p.length > nbMaxPossibleCodesShown) ) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: invalid possibleCodesList_p: " + data.possibleCodesList_p + ", length is " + possibleCodesList_p.length, new Error().stack);
      }

      if (data.nb_possible_codes_listed == undefined) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: nb_possible_codes_listed is undefined", new Error().stack);
      }
      let nb_possible_codes_listed = Number(data.nb_possible_codes_listed);
      if ( isNaN(nb_possible_codes_listed) || (nb_possible_codes_listed <= 0) || (nb_possible_codes_listed > nbMaxPossibleCodesShown) ) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: invalid nb_possible_codes_listed: " + nb_possible_codes_listed, new Error().stack);
      }

      if (data.globalPerformancesList_p == undefined) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: globalPerformancesList_p is undefined", new Error().stack);
      }
      let globalPerformancesList_p = (data.globalPerformancesList_p).split(",");
      if ( (globalPerformancesList_p.length <= 0) || (globalPerformancesList_p.length > nbMaxPossibleCodesShown) ) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: invalid globalPerformancesList_p: " + data.globalPerformancesList_p + ", length is " + globalPerformancesList_p.length, new Error().stack);
      }

      if (data.attempt_nb == undefined) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: attempt_nb is undefined", new Error().stack);
      }
      let attempt_nb = Number(data.attempt_nb);
      if ( isNaN(attempt_nb) || (attempt_nb <= 0) ) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: invalid attempt_nb: " + attempt_nb, new Error().stack);
      }

      if (data.game_id == undefined) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: game_id is undefined", new Error().stack);
      }
      let game_id = Number(data.game_id);
      if ( isNaN(game_id) || (game_id < 0) ) {
        displayGUIError("LIST_OF_POSSIBLE_CODES / gameSolver msg error: invalid game_id: " + game_id, new Error().stack);
      }

      writePossibleCodes(possibleCodesList_p, nb_possible_codes_listed, globalPerformancesList_p, attempt_nb, game_id);

    }

    // **************************
    // Performance of code played
    // **************************

    else if (data.rsp_type == 'CODE_PLAYED_PERFORMANCE') {

      if (data.relative_perf_p == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: relative_perf_p is undefined", new Error().stack);
      }
      let relative_perf_p = Number(data.relative_perf_p);

      if (data.best_global_performance_p == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: best_global_performance_p is undefined", new Error().stack);
      }
      let best_global_performance_p = Number(data.best_global_performance_p);

      if (data.relative_perf_evaluation_done_p == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: relative_perf_evaluation_done_p is undefined", new Error().stack);
      }
      let relative_perf_evaluation_done_p = Boolean(data.relative_perf_evaluation_done_p);

      if (data.code_p == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: code_p is undefined", new Error().stack);
      }
      let code_p = Number(data.code_p);

      if (data.attempt_nb == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: attempt_nb is undefined", new Error().stack);
      }
      let attempt_nb = Number(data.attempt_nb);
      if ( isNaN(attempt_nb) || (attempt_nb <= 0) ) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: invalid attempt_nb: " + attempt_nb, new Error().stack);
      }

      if (data.game_id == undefined) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: game_id is undefined", new Error().stack);
      }
      let game_id = Number(data.game_id);
      if ( isNaN(game_id) || (game_id < 0) ) {
        displayGUIError("CODE_PLAYED_PERFORMANCE / gameSolver msg error: invalid game_id: " + game_id, new Error().stack);
      }

      writePerformanceOfCodePlayed(relative_perf_p, relative_perf_evaluation_done_p, best_global_performance_p, code_p, attempt_nb, game_id);

    }

    // ******
    // Traces
    // ******

    else if (data.rsp_type == 'TRACE') {

      if (data.trace_contents == undefined) {
        displayGUIError("TRACE / gameSolver msg error: trace_contents is undefined", new Error().stack);
      }
      let trace_str = data.trace_contents.concat("<br>");

      document.getElementById("traces_id").innerHTML = document.getElementById("traces_id").innerHTML.concat(trace_str);

    }

    // **********
    // Error case
    // **********

    else {
      displayGUIError("gameSolver error: unexpected rsp_type: " + data.rsp_type, new Error().stack);
      return;
    }

  }
  catch (exc) {
    displayGUIError("onGameSolverMsg error: " + exc, exc.stack);
  }

}

// ***********************
// Event-related functions
// ***********************

function newGameButtonClick(nbColumns) {
  if (!document.getElementById("newGameButton").disabled) {
    if ( (nbColumns == 0) // ("NEW GAME" button event)
         || (currentAttemptNumber <= 1) ) { // (radio buttons events)

      if (gameOnGoing() && (currentAttemptNumber > 1)) {

        if (nbNewGameEventsCancelled <= 2) { // Avoid repetitive or endless (in Firefox for example) cancellations
          var rsp = confirm("Do you really want to abort and lose current game?"); // (code duplicated)
          if (!rsp) {
            nbNewGameEventsCancelled++;
            return; // Cancel or "x" (close) button
          }
        }
        nbOnGoingGamesAborted++;

        // Transition effect 1/2
        try {
          $(".game_aborted").fadeIn(3500);
        }
        catch (exc) {
        }

        // Transition effect 2/2
        try {
          $(".game_aborted").fadeOut(3500);
        }
        catch (exc) {
        }

      }

      // Transition effect 1/2
      try {
        $(".page_transition").fadeIn("fast");
      }
      catch (exc) {
      }

      // Debug values
      if (currentAttemptNumber-1 != nbOfStatsFilled_Perfs) {
        nbGamesAbortedWithOnGoingWorker++;
        lastGameWasAbortedWithOnGoingWorker = true;
      }
      else {
        lastGameWasAbortedWithOnGoingWorker = false;
      }

      newGameEvent = true;
      nbNewGameEvents++;
      draw_graphic();

      // Transition effect 2/2
      try {
        $(".page_transition").fadeOut("fast");
      }
      catch (exc) {
      }

    }
  }
}

function resetCurrentCodeButtonClick() {
  if (!document.getElementById("resetCurrentCodeButton").disabled) {
    currentCode = sCodeRevealed;
    draw_graphic(false);
  }
}

function playRandomCodeButtonClick() {
  if (!document.getElementById("playRandomCodeButton").disabled) {
    randomCodesHintToBeDisplayed = false;
    nb_random_codes_played++;
    currentCode = simpleCodeHandler.createRandomCode(sCodeRevealed);
    draw_graphic(false);
  }
}

function displayRandomCodesHintIfNeeded() {
  if (randomCodesHintToBeDisplayed) {
    if (typeof(Storage) !== 'undefined') {
      if (localStorage.gamesok) {
        if ( (Number(localStorage.gamesok) >= 100) && ((Number(localStorage.gamesok) % 50) == 0) ) {
          alert("A little fun?!\nClick on the \"" + document.getElementById("playRandomCodeButton").value + "\" button to play your first codes randomly!");
          randomCodesHintToBeDisplayed = false;
        }
      }
    }
  }
}

function revealSecretColorButtonClick() {
  if ( (!document.getElementById("revealSecretColorButton").disabled)
       && gameOnGoing()
       && (sCode != -1) && (sCodeRevealed != -1) ) {
    let nbEmptyColors = simpleCodeHandler.nbEmptyColors(sCodeRevealed);
    if (nbEmptyColors <= 1) {
      displayGUIError("too many revealed colors", new Error().stack);
    }
    else if ((nbColumns-nbEmptyColors+1) < (nbColumns+1)/2) {
      playerWasHelped = true;
      let revealedColorIdx = Math.floor(Math.random() * nbEmptyColors);
      sCodeRevealed = simpleCodeHandler.replaceEmptyColor(sCodeRevealed, revealedColorIdx, simpleCodeHandler.convert(sCode));
      currentCode = sCodeRevealed;
      main_graph_update_needed = true;
      draw_graphic(false);
    }
  }
}

function showPossibleCodesButtonClick(invertMode = true, newPossibleCodeShown = -1, showModeForced = false, transientMode = false) {
  if (!document.getElementById("showPossibleCodesButton").disabled) {

    if (showModeForced && showPossibleCodesMode) { // (showPossibleCodesMode is already true)
      return;
    }

    // Transition effect 1/2
    if (invertMode || showModeForced) {
      try {
        $(".page_transition").fadeIn("fast");
      }
      catch (exc) {
      }
    }

    if (showModeForced) {
      showPossibleCodesMode = true;
    }
    else if (invertMode) {
      showPossibleCodesMode = !showPossibleCodesMode;
      disableMouseMoveEffects = false;
    }
    if (!showPossibleCodesMode) {
      nbPossibleCodesShown = -1;
      currentPossibleCodeShown = -1;
    }
    else {
      nbPossibleCodesShown = Math.max(nbMinPossibleCodesShown, Math.min(nbMaxPossibleCodesShown/2 /* (half display) */, 20 + (nbMaxAttempts+1 - currentAttemptNumber)));
      if (newPossibleCodeShown == -1) {
        let interesting_attempt_idx = 0;
        for (let i = currentAttemptNumber-2; i >= 0; i--) {
          if ( (nbOfPossibleCodes[i] >= 2)
               && (relative_performances_of_codes_played[i] != -1.00) /* not a useless code (simplified test) */
               && ((nbOfPossibleCodes[i] >= 5) || (relative_performances_of_codes_played[i] <= PerformanceLOW/2))
             ) {
            interesting_attempt_idx = i;
            break;
          }
        }
        currentPossibleCodeShown = interesting_attempt_idx+1;
      }
      else {
        currentPossibleCodeShown = newPossibleCodeShown;
      }
    }
    if (!transientMode) {
      currentPossibleCodeShownBeforeMouseMove = currentPossibleCodeShown;
    }
    updateGameSizes();
    draw_graphic(!transientMode);

    // Transition effect 2/2
    if (invertMode || showModeForced) {
      try {
        $(".page_transition").fadeOut("fast");
      }
      catch (exc) {
      }
    }

  }
}

function mouseClick(e) {

  let event_x_min, event_x_max, event_y_min, event_y_max;
  let rect = canvas.getBoundingClientRect();
  let mouse_x = e.clientX - rect.left - 2.0 /* (correction) */;
  let mouse_y = e.clientY - rect.top - 2.0 /* (correction) */;

  // ***************
  // Color selection
  // ***************

  if (gameOnGoing()) {

    event_x_min = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
    event_x_max = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
    event_y_min = get_y_pixel(y_min+y_step*(nbMaxAttempts-nb_attempts_not_displayed+transition_height+scode_height+transition_height+nbColors));
    event_y_max = get_y_pixel(y_min+y_step*(currentAttemptNumber-1));

    if ( (mouse_x > event_x_min) && (mouse_x < event_x_max)
         && (mouse_y > event_y_min) && (mouse_y < event_y_max) ) {

      try {
        for (let column = 0; column < nbColumns; column++) {
          let x_0, y_0, x_1, y_1;
          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+column*2));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+(column+1)*2));
          if ((mouse_x > x_0) && (mouse_x < x_1)) {
            let colorSelected = false;
            for (let color = 0; color < nbColors; color++) {
              y_0 = get_y_pixel(y_min+y_step*(nbMaxAttempts-nb_attempts_not_displayed+transition_height+scode_height+transition_height+(color+1)));
              y_1 = get_y_pixel(y_min+y_step*(nbMaxAttempts-nb_attempts_not_displayed+transition_height+scode_height+transition_height+color));
              if ((mouse_y > y_0) && (mouse_y < y_1)) {
                colorSelected = true;
                playAColor(color+1, column+1);
                nbColorSelections++;
                break;
              }
            }
            if (!colorSelected) {
              playAColor(emptyColor, column+1);
            }
            break;
          }
        }
      }
      catch (exc) {
        displayGUIError("mouseReleased: " + exc, exc.stack);
      }

    }

  }

  // *****************
  // Attempt selection
  // *****************

  else if ((!gameOnGoing()) && allPossibleCodesFilled()) { // (condition duplicated)

    if (!showPossibleCodesMode) {
      event_y_min = get_y_pixel(y_min+y_step*(nbMaxAttempts-nb_attempts_not_displayed));
    }
    else {
      event_y_min = get_y_pixel(y_min+y_step*(currentAttemptNumber-1));
    }
    event_y_max = get_y_pixel(y_min+y_step*0);

    if ( (mouse_y > event_y_min) && (mouse_y < event_y_max) ) { // (below code duplicated)
      lastidxBeforeMouseMove = -1;
      for (let idx = 0; idx < currentAttemptNumber-1; idx++) {
        let y_0 = get_y_pixel(y_min+y_step*(idx+1));
        let y_1 = get_y_pixel(y_min+y_step*(idx));
        if ((mouse_y > y_0) && (mouse_y < y_1)) {
          showPossibleCodesOffsetMode = false;
          disableMouseMoveEffects = true;
          if (showPossibleCodesMode) {
            atLeastOneAttemptSelection = true;
          }
          showPossibleCodesButtonClick(!showPossibleCodesMode, idx+1);
          break;
        }
      }
    }
    else {
      if (showPossibleCodesMode) {
        disableMouseMoveEffects = false;
        let x_0_half_display = get_x_pixel(x_min);
        let x_1_half_display = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
        let y_0_half_display = get_y_pixel(y_min+y_step*(currentAttemptNumber-1+transition_height+1+0.75/* (margin) */))
        let y_1_half_display = get_y_pixel(y_min+y_step*(currentAttemptNumber-1+transition_height/2/* (margin) */));
        if ( (mouse_x > x_0_half_display) && (mouse_x < x_1_half_display)
             && (mouse_y > y_0_half_display) && (mouse_y < y_1_half_display) ) { // (half display - always tested to simplify)
          atLeastOneAttemptSelection = true;
          showPossibleCodesOffsetMode = !showPossibleCodesOffsetMode;
          main_graph_update_needed = true;
          draw_graphic(false);
        }
        else { // (other zones)
          showPossibleCodesOffsetMode = false;
          lastidxBeforeMouseMove = -1;
          showPossibleCodesButtonClick();
        }
      }
      else {
        lastidxBeforeMouseMove = -1;
      }
    }

  }

}

function mouseMove(e) {
  if (!showPossibleCodesMode) {
    return;
  }
  else if ((!gameOnGoing()) && allPossibleCodesFilled()) { // (condition duplicated)

    let event_x_min, event_x_max, event_y_min, event_y_max;
    let rect = canvas.getBoundingClientRect();
    let mouse_x = e.clientX - rect.left - 2.0 /* (correction) */;
    let mouse_y = e.clientY - rect.top - 2.0 /* (correction) */;

    event_x_min = get_x_pixel(x_min);
    event_x_max = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width+tick_width));
    event_y_min = get_y_pixel(y_min+y_step*(currentAttemptNumber-1));
    event_y_max = get_y_pixel(y_min+y_step*0);

    if (mouse_y < event_y_min) {
      disableMouseMoveEffects = false;
    }

    if (disableMouseMoveEffects) {
      return;
    }

    if ( (mouse_x > event_x_min) && (mouse_x < event_x_max)
          && (mouse_y > event_y_min) && (mouse_y < event_y_max) ) { // (below code duplicated)
      for (let idx = 0; idx < currentAttemptNumber-1; idx++) {
        let y_0 = get_y_pixel(y_min+y_step*(idx+1));
        let y_1 = get_y_pixel(y_min+y_step*(idx));
        if ((mouse_y > y_0) && (mouse_y < y_1)) {
          if (lastidxBeforeMouseMove != idx+1) {
            showPossibleCodesOffsetMode = false;
            showPossibleCodesButtonClick(false, idx+1, false, true);
            lastidxBeforeMouseMove = idx+1;
          }
          break;
        }
      }
    }
    else { // (other zones)
      if (lastidxBeforeMouseMove != currentPossibleCodeShownBeforeMouseMove) {
        showPossibleCodesOffsetMode = false;
        showPossibleCodesButtonClick(false, currentPossibleCodeShownBeforeMouseMove, false, true);
        lastidxBeforeMouseMove = currentPossibleCodeShownBeforeMouseMove;
      }
    }

  }
}

function playAColor(color, column) {
  if (gameOnGoing()) {
    if ((color != emptyColor) && obviouslyImpossibleColors[color]) {
      alert("This color is obviously impossible!");
      return;
    }
    let newCurrentCode = simpleCodeHandler.setColor(currentCode, color, column);
    for (let i = 1; i < currentAttemptNumber; i++) {
      if (newCurrentCode == codesPlayed[i-1]) {
        alert("This code was already played!");
        return;
      }
    }
    currentCode = newCurrentCode;
    draw_graphic(false);
  }
}

let previousNbColumns = -1;
function getNbColumnsSelected() {
  // Check if a radio button is checked
  let nbColumnsRadioObject = document.getElementsByName("nbColumnsSelection");
  for (let i = 0; i < nbColumnsRadioObject.length; i++) {
    if (nbColumnsRadioObject[i].checked) {
     previousNbColumns = parseInt(nbColumnsRadioObject[i].value);
     return previousNbColumns;
    }
  }
  // No radio button checked
  if (previousNbColumns == -1) { // First default setting
    nbColumnsRadioObject[defaultNbColumns-nbMinColumns].checked = "checked";
    previousNbColumns = parseInt(nbColumnsRadioObject[defaultNbColumns-nbMinColumns].value);
    return previousNbColumns;
  }
  else { // Keep current setting
    nbColumnsRadioObject[previousNbColumns-nbMinColumns].checked = "checked";
    return previousNbColumns;
  }
}

// *****************
// General functions
// *****************

function updateGameSizes() {

  main_graph_update_needed = true;

  if (!CompressedDisplayMode) {
    attempt_nb_width = 2;
    nb_possible_codes_width = ((nbColumns>=7)?5:4);
    optimal_width = 4;
    tick_width = 3;

    transition_height = 1;
    scode_height = 1;
  }
  else {
    attempt_nb_width = 0;
    nb_possible_codes_width = ((nbColumns>=7)?4.2:((nbColumns==6)?3.7:3.2));
    optimal_width = (((!gameOnGoing())||showPossibleCodesMode)?2.25:0);
    tick_width = (((nbColumns<=4)||(!gameOnGoing())||showPossibleCodesMode)?1.35:0);

    if (!gameOnGoing()) {
      transition_height = 0.4;
      scode_height = 1;
    }
    else {
      transition_height = 0.15;
      scode_height = 0;
    }
  }

  x_step = (x_max - x_min) / (attempt_nb_width // attempt number
                              +(90*(nbColumns+1))/100 // mark
                              +nbColumns*2 // code
                              +nb_possible_codes_width // number of possible codes
                              +optimal_width // optimal
                              +tick_width); // OK/NOK

  if (!showPossibleCodesMode) {
    if (nbColumns <= 4) {
      nb_attempts_not_displayed = 0;
    }
    else {
      nb_attempts_not_displayed = Math.max(0, nbMaxAttempts - currentAttemptNumber - 1);
      if (nbMaxAttempts-nb_attempts_not_displayed < nbColors) { // Color selection shall not be wider than game
        nb_attempts_not_displayed = Math.max(0, nbMaxAttempts - nbColors);
      }
      if (nbColumns == 5) {
        nb_attempts_not_displayed = Math.min(3, nb_attempts_not_displayed);
      }
      else if (nbColumns == 6) {
        nb_attempts_not_displayed = Math.min(4, nb_attempts_not_displayed);
      }
      else if (nbColumns == 7) {
        nb_attempts_not_displayed = Math.min(5, nb_attempts_not_displayed);
      }
    }
    y_step = (y_max - y_min) / (nbMaxAttempts-nb_attempts_not_displayed // number of attempts displayed
                                +transition_height // margin
                                +scode_height // secret code
                                +transition_height // margin
                                +nbColors); // color selection
  }
  else {
    nb_attempts_not_displayed = 0;
    if ( !((!gameOnGoing()) && allPossibleCodesFilled()) || (currentAttemptNumber <= 0) ) {
      displayGUIError("invalid context for updateGameSizes(): " + gameOnGoing() + ", " + allPossibleCodesFilled(), new Error().stack);
    }
    y_step = (y_max - y_min) / (currentAttemptNumber-1 // number of attempts reached at end of game
                                +transition_height // margin
                                +nbPossibleCodesShown // possible codes
                                +1); // tick display
  }

}

function postInitMessageToGameSolver(cnt_p) {
  try {
    if (game_id_for_gameSolverConfig != cnt_p) { // ignore other threads
      console.log("postInitMessageToGameSolver() call ignored (1): " + game_id_for_gameSolverConfig + ", " + cnt_p);
      return;
    }
    if (game_id_for_gameSolverConfig != game_cnt) { // ignore other threads
      console.log("postInitMessageToGameSolver() call ignored (2): " + game_id_for_gameSolverConfig + ", " + game_cnt);
      return;
    }
    if (game_id_for_initGameSolver != -1) { // 'INIT' message was already posted
      console.log("postInitMessageToGameSolver() call skipped: " + game_id_for_initGameSolver + ", " + game_cnt);
      return;
    }
    if (gameSolverInitMsgContents != null) {
      gameSolverDbg = 99;
      gameSolver.postMessage(gameSolverInitMsgContents);
      gameSolverDbg = 100;
      game_id_for_initGameSolver = game_cnt;
    }
    else {
      throw new Error("internal postInitMessageToGameSolver() error: gameSolverInitMsgContents == null");
    }
  }
  catch (err) {
    displayGUIError("postInitMessageToGameSolver() error: " + err, err.stack);
  }
}

function resetGameAttributes(nbColumnsSelected) {

  let i;
  let first_session_game;
  let debug_mode = '';

  console.clear();

  game_cnt++;
  if (game_cnt > 1000000) {
    game_cnt = 1;
  }

  // Clear gameSolver worker if necessary
  gameSolverDbg = 0;
  if (gameSolver !== undefined) {
    if (game_id_for_initGameSolver != -1) { // 'INIT' message was already posted
      // (code duplicated:)
      isWorkerAlive = -1;
      gameSolverDbg = 1;
      gameSolver.terminate(); gameSolverDbg = 2;
      gameSolver = undefined;
    }
    // else: keep already-created gameSolver worker
  }
  gameSolverInitMsgContents = null;
  gameSolverConfigDbg = null;
  game_id_for_gameSolverConfig = -1;
  game_id_for_initGameSolver = -1;

  if ( ((new Date()).getTime() - loadTime >= 4*3600*1000) // (reload the page from server every 4 hours at next game start: not too short to allow game.html's "last_data_used" benefits and avoid useless reloads (while offline), not too long to allow fast application of changes)
       || (nbGamesPlayedAndWon >= 12) ) { // (reload to avoid potential (firefox) memory leaks issues, with the same arguments as above - can also solve "modal display conditions not fulfilled" issues)
    loadTime = (new Date()).getTime(); // time in milliseconds (this line should be useless)
    location.reload(true);
  }

  main_graph_update_needed = true;
  simpleCodeHandler = null;

  nbColumns = nbColumnsSelected;
  switch (nbColumns) {
    case 3:
      nbColors = Math.max(nbMinColors, nominalGameNbColors - 3);
      nbMaxAttempts = nominalGameNbMaxAttempts - 4;
      document.title = "Very easy";
      break;
    case 4:
      nbColors = Math.max(nbMinColors, nominalGameNbColors - 2);
      nbMaxAttempts = nominalGameNbMaxAttempts - 2;
      document.title = "Master Mind";
      break;
    case 5: // nominalGameNbColumns
      nbColors = nominalGameNbColors;
      nbMaxAttempts = nominalGameNbMaxAttempts;
      document.title = "Super Master Mind";
      break;
    case 6:
      nbColors = Math.min(nbMaxColors, nominalGameNbColors + 1);
      nbMaxAttempts = nominalGameNbMaxAttempts + 2;
      document.title = "Advanced Master Mind";
      break;
    case 7:
      nbColors = Math.min(nbMaxColors, nominalGameNbColors + 2);
      nbMaxAttempts = nominalGameNbMaxAttempts + 3;
      document.title = "Ultra Master Mind";
      break;
    default:
      throw new Error("invalid selection of number of columns: " + nbColumns + " (1)");
  }
  if ( (nbMaxAttempts < overallNbMinAttempts) || (nbMaxAttempts > overallNbMaxAttempts) ) {
    throw new Error("invalid nbMaxAttempts: " + nbMaxAttempts);
  }

  simpleCodeHandler = new SimpleCodeHandler(nbColumns, nbColors, nbMinColumns, nbMaxColumns, emptyColor);

  showPossibleCodesMode = false;
  showPossibleCodesOffsetMode = false;
  nbMinPossibleCodesShown = nbColumns+nbColors+4;
  nbMaxPossibleCodesShown = 60;
  nbPossibleCodesShown = -1;
  currentPossibleCodeShown = -1;
  disableMouseMoveEffects = false;

  currentCode = 0;
  codesPlayed = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    codesPlayed[i] = 0;
  }
  marks = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    marks[i] = {nbBlacks:0, nbWhites:0};
  }
  nbOfPossibleCodes = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    nbOfPossibleCodes[i] = 0;
  }
  colorsFoundCodes = new Array(nbMaxAttempts);
  minNbColorsTables = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    minNbColorsTables[i] = new Array(nbColors+1);
  }
  maxNbColorsTables = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    maxNbColorsTables[i] = new Array(nbColors+1);
  }
  obviouslyImpossibleColors = new Array(nbColors+1);
  for (i = 0; i < nbColors+1; i++) {
    obviouslyImpossibleColors[i] = false;
  }
  relative_performances_of_codes_played = new Array(nbMaxAttempts);
  global_best_performances = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    relative_performances_of_codes_played[i] = PerformanceNA;
    global_best_performances[i] = PerformanceNA;
  }
  relativePerformancesEvaluationDone = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    relativePerformancesEvaluationDone[i] = false;
  }
  performancesDisplayed = new Array(nbMaxAttempts);
  for (i = 0; i < nbMaxAttempts; i++) {
    performancesDisplayed[i] = false;
  }

  possibleCodesLists = new Array(nbMaxAttempts);
  possibleCodesListsSizes = new Array(nbMaxAttempts);
  globalPerformancesList = new Array(nbMaxAttempts); // (same size as possibleCodesLists)
  for (i = 0; i < nbMaxAttempts; i++) {
    possibleCodesLists[i] = new Array(nbMaxPossibleCodesShown);
    possibleCodesListsSizes[i] = 0;
    globalPerformancesList[i] = new Array(nbMaxPossibleCodesShown);
  }

  nbOfStatsFilled_NbPossibleCodes = 0;
  nbOfStatsFilled_ListsOfPossibleCodes = 0;
  nbOfStatsFilled_Perfs = 0;
  currentAttemptNumber = 1;

  gameWon = false;
  timeStr = "";
  score = -1.0;
  sumPerfs = 0.00;
  nbUnknownPerfs = 0;

  sCode = ~(simpleCodeHandler.createRandomCode());
  /* XXX
  let toto = simpleCodeHandler.createRandomCode();
  toto = simpleCodeHandler.setColor(toto, 4, 1);
  toto = simpleCodeHandler.setColor(toto, 4, 2);
  toto = simpleCodeHandler.setColor(toto, 4, 3);
  toto = simpleCodeHandler.setColor(toto, 4, 4);
  toto = simpleCodeHandler.setColor(toto, 4, 5);
  // toto = simpleCodeHandler.setColor(toto, 7, 6);
  // toto = simpleCodeHandler.setColor(toto, 4, 6);
  // toto = simpleCodeHandler.setColor(toto, 4, 7);
  sCode = ~(toto); */

  sCodeRevealed = 0;

  newGameEvent = false;
  playerWasHelped = false;

  gameErrorStr = "";
  gameErrorCnt = 0;

  nb_random_codes_played = 0;
  at_least_one_useless_code_played = false;

  updateGameSizes();

  // Create a new worker for gameSolver if needed
  if (gameSolver == undefined) {
    isWorkerAlive = 0;
    workerCreationTime = (new Date()).getTime();
    gameSolver = new Worker("Game" + "Solver.js"); gameSolverDbg = 3;
  }
  // gameSolver.addEventListener('error', onGameSolverError, false); gameSolverDbg = 4;
  gameSolver.onerror = onGameSolverError; gameSolverDbg = 4;
  Worker.onmessageerror = onGameSolverMessageError; gameSolverDbg = 5;
  gameSolver.onmessageerror = onGameSolverMessageError; gameSolverDbg = 6;
  // gameSolver.addEventListener('message', onGameSolverMsg, false); gameSolverDbg = 7;
  gameSolver.onmessage = onGameSolverMsg; gameSolverDbg = 7;
  // Send a message to the gameSolver worker to initialize it
  if ( (typeof(Storage) !== 'undefined') && (!sessionStorage.first_session_game) ) {
    sessionStorage.first_session_game = 1;
    first_session_game = true;
  }
  else {
    first_session_game = false;
  }
  if (typeof(Storage) !== 'undefined') {
    if (localStorage.debug_mode) {
      debug_mode = localStorage.debug_mode;
    }
  }

  gameSolverInitMsgContents = {'req_type': 'INIT', 'nbColumns': nbColumns, 'nbColors': nbColors, 'nbMaxAttempts': nbMaxAttempts, 'nbMaxPossibleCodesShown': nbMaxPossibleCodesShown, 'first_session_game': first_session_game, 'game_id': game_cnt, 'debug_mode': debug_mode};
  gameSolverConfigDbg = JSON.stringify(gameSolverInitMsgContents);
  game_id_for_gameSolverConfig = game_cnt;
  setTimeout("postInitMessageToGameSolver(" + game_id_for_gameSolverConfig + ");", 2500); // delay number of possible codes display (better than a "blocking while loop" till time has elapsed)

  if (randomCodesHintToBeDisplayed) {
    setTimeout("displayRandomCodesHintIfNeeded();", 888);
  }
  gameSolverDbg = 8;

}

function checkArraySizes() {
  if (codesPlayed.length > nbMaxAttempts) {displayGUIError("array is wider than expected (1)", new Error().stack);}
  if (marks.length > nbMaxAttempts) {displayGUIError("array is wider than expected (2)", new Error().stack);}
  if (nbOfPossibleCodes.length > nbMaxAttempts){displayGUIError("array is wider than expected (3)", new Error().stack);}
  if (colorsFoundCodes.length > nbMaxAttempts){displayGUIError("array is wider than expected (4)", new Error().stack);}
  if (minNbColorsTables.length > nbMaxAttempts){displayGUIError("array is wider than expected (5)", new Error().stack);}
  for (let i = 0; i < nbMaxAttempts; i++) {
    if (minNbColorsTables[i].length > nbColors+1) {displayGUIError("array is wider than expected (6)", new Error().stack);}
  }
  if (maxNbColorsTables.length > nbMaxAttempts){displayGUIError("array is wider than expected (7a)", new Error().stack);}
  for (let i = 0; i < nbMaxAttempts; i++) {
    if (maxNbColorsTables[i].length > nbColors+1){displayGUIError("array is wider than expected (7b)", new Error().stack);}
  }
  if (obviouslyImpossibleColors.length > nbColors+1){displayGUIError("array is wider than expected (8)", new Error().stack);}
  if (relative_performances_of_codes_played.length > nbMaxAttempts){displayGUIError("array is wider than expected (9)", new Error().stack);}
  if (global_best_performances.length > nbMaxAttempts){displayGUIError("array is wider than expected (10)", new Error().stack);}
  if (relativePerformancesEvaluationDone.length > nbMaxAttempts){displayGUIError("array is wider than expected (11)", new Error().stack);}
  if (performancesDisplayed.length > nbMaxAttempts){displayGUIError("array is wider than expected (12)", new Error().stack);}
  if (possibleCodesLists.length > nbMaxAttempts){displayGUIError("array is wider than expected (13)", new Error().stack);}
  if (globalPerformancesList.length > nbMaxAttempts){displayGUIError("array is wider than expected (14)", new Error().stack);}
  if (possibleCodesListsSizes.length > nbMaxAttempts){displayGUIError("array is wider than expected (15)", new Error().stack);}
  for (let i = 0; i < nbMaxAttempts; i++) {
    if (possibleCodesLists[i].length > nbMaxPossibleCodesShown){displayGUIError("array is wider than expected (16)", new Error().stack);}
    if (globalPerformancesList[i].length > nbMaxPossibleCodesShown){displayGUIError("array is wider than expected (17)", new Error().stack);}
  }
}

function gameOnGoing() {
  return ((!gameWon) && (currentAttemptNumber <= nbMaxAttempts));
}

function allPerformancesFilled() {
  return ((!gameOnGoing()) && (currentAttemptNumber-1 == nbOfStatsFilled_Perfs) && (nbOfStatsFilled_Perfs >= 1) && (relative_performances_of_codes_played[nbOfStatsFilled_Perfs-1] != PerformanceNA));
}

function allPossibleCodesFilled() {
  return ( // game on-going and all stats filled
            (gameOnGoing() && (currentAttemptNumber == nbOfStatsFilled_NbPossibleCodes) && (nbOfStatsFilled_NbPossibleCodes >= 1) && (possibleCodesListsSizes[nbOfStatsFilled_NbPossibleCodes-1] > 0))
            ||
            // game over and all stats filled
            ((!gameOnGoing()) && (currentAttemptNumber-1 == nbOfStatsFilled_NbPossibleCodes) && (nbOfStatsFilled_NbPossibleCodes >= 1) && (possibleCodesListsSizes[nbOfStatsFilled_NbPossibleCodes-1] > 0)) );
}

// Check if a code played is possible
function isAttemptPossible(attempt_nb) { // (returns 0 if the attempt_nb th code is possible, returns the first attempt number with which there is a contradiction otherwise)
  if ( (attempt_nb <= 0) || (attempt_nb >= currentAttemptNumber) ) {
    displayGUIError("invalid attempt nb (" + attempt_nb + ")", new Error().stack);
    return 1;
  }
  let mark_tmp = {nbBlacks:0, nbWhites:0};
  for (let i = 1; i <= attempt_nb-1; i++) { // go through all codes previously played
    simpleCodeHandler.fillMark(codesPlayed[attempt_nb-1], codesPlayed[i-1], mark_tmp);
    if (!simpleCodeHandler.marksEqual(mark_tmp, marks[i-1])) {
      return i;
    }
  }
  return 0;
}

// ****************************
// Statistics related functions
// ****************************

// Number of possible codes
function writeNbOfPossibleCodes(nbOfPossibleCodes_p, colorsFoundCode_p, minNbColorsTable_p, maxNbColorsTable_p, attempt_nb, game_id) {
  if (game_id != game_cnt) { // ignore other threads
    console.log("writeNbOfPossibleCodes() call ignored: " + game_id + ", " + game_cnt);
    return false;
  }
  if ( (nbOfPossibleCodes_p <= 0)
       || (attempt_nb != nbOfStatsFilled_NbPossibleCodes + 1) // stats shall be filled consecutively
       || (attempt_nb <= 0) || (attempt_nb > nbMaxAttempts)
       || (nbOfPossibleCodes[attempt_nb-1] != 0 /* initial value */)
       || (!simpleCodeHandler.isValid(colorsFoundCode_p)) ) {
    displayGUIError("invalid stats (" + nbOfPossibleCodes_p + ", " + attempt_nb + ", " + nbOfStatsFilled_NbPossibleCodes + ", " + nbOfPossibleCodes[attempt_nb-1] + ") (1)", new Error().stack);
    return false;
  }
  nbOfPossibleCodes[attempt_nb-1] = nbOfPossibleCodes_p;
  colorsFoundCodes[attempt_nb-1] = colorsFoundCode_p;
  let sum_max = 0;
  for (let color = 1; color <= nbColors; color++) {
    minNbColorsTables[attempt_nb-1][color] = minNbColorsTable_p[color];
    maxNbColorsTables[attempt_nb-1][color] = maxNbColorsTable_p[color];
    sum_max += maxNbColorsTables[attempt_nb-1][color];
  }
  if (sum_max < nbColumns) {
    displayGUIError("invalid stats (sum_max=" + sum_max + ") (2)", new Error().stack);
    return false;
  }
  nbOfStatsFilled_NbPossibleCodes = attempt_nb; // Assumption: the number of possible codes is assumed to be the first stat to be written among all stats

  main_graph_update_needed = true;
  draw_graphic(false);
  return true;
}

// Code performances
function writePerformanceOfCodePlayed(relative_perf_p, relative_perf_evaluation_done_p, best_global_performance_p, code_p, attempt_nb, game_id) {
  if (game_id != game_cnt) { // ignore other threads
    console.log("writePerformanceOfCodePlayed() call ignored: " + game_id + ", " + game_cnt);
    return false;
  }
  if ( ((relative_perf_p < PerformanceMinValidValue) && (relative_perf_p != PerformanceUNKNOWN)) || (relative_perf_p > PerformanceMaxValidValue) /* possible range of relative performances */
       || (relative_perf_p == PerformanceNA)
       || (relative_perf_evaluation_done_p && (relative_perf_p == PerformanceUNKNOWN))
       || (((relative_perf_p <= -1.00) && (relative_perf_p != PerformanceUNKNOWN)) /* useless code */ && (!relative_perf_evaluation_done_p))
       || ((best_global_performance_p <= 0.01) && (best_global_performance_p != PerformanceUNKNOWN))
       || (best_global_performance_p == PerformanceNA)
       || (code_p != codesPlayed[attempt_nb-1])
       || (attempt_nb != nbOfStatsFilled_Perfs + 1) // perfs shall be filled consecutively
       || (attempt_nb > nbOfStatsFilled_NbPossibleCodes) // performances shall be filled after numbers of possible codes
       || (attempt_nb <= 0) || (attempt_nb > nbMaxAttempts)
       || (relative_performances_of_codes_played[attempt_nb-1] != PerformanceNA /* initial value */)
       || (global_best_performances[attempt_nb-1] != PerformanceNA /* initial value */)
       || (relativePerformancesEvaluationDone[attempt_nb-1] /* initial value */) ) {
    displayGUIError("invalid perfs (" + attempt_nb + ", " + nbOfStatsFilled_Perfs + ", " + nbOfStatsFilled_NbPossibleCodes + ", " + relative_perf_p + ", " + best_global_performance_p + ", " + relative_perf_evaluation_done_p + ", " + code_p + ", " + attempt_nb + ")", new Error().stack);
    return false;
  }
  relative_performances_of_codes_played[attempt_nb-1] = relative_perf_p; // may be known or unknown
  global_best_performances[attempt_nb-1] = best_global_performance_p; // may be PerformanceUNKNOWN

  if (relative_perf_p == PerformanceUNKNOWN) {
    nbUnknownPerfs++;
  }
  else {
    sumPerfs = sumPerfs + relative_perf_p;
  }
  if ((relative_perf_p <= -1.00) && (relative_perf_p != PerformanceUNKNOWN)) { // useless code
    at_least_one_useless_code_played = true;
  }
  relativePerformancesEvaluationDone[attempt_nb-1] = relative_perf_evaluation_done_p;
  nbOfStatsFilled_Perfs = attempt_nb;

  main_graph_update_needed = true;
  draw_graphic(false);

  // ***************************************
  // Store player's info distantly if needed
  // ***************************************

  if (gameWon && allPerformancesFilled()) {
    if ((timeStr.length == 0) || (score < 0.0)) {
      displayGUIError("internal error at store_player_info call: " + timeStr.length + ", " + score, new Error().stack);
    }
    else { // (score > 0.0 because game won)
      let nbColorsRevealed = (nbColumns-simpleCodeHandler.nbEmptyColors(sCodeRevealed));

      let strGame = "";
      for (let i = 1; i < currentAttemptNumber; i++) {
        strGame = strGame + simpleCodeHandler.markToString(marks[i-1]) + " " + simpleCodeHandler.codeToString(codesPlayed[i-1]) + " (" + nbOfPossibleCodes[i-1]
                          + "|" + (Math.round(relative_performances_of_codes_played[i-1] * 100.0) / 100.0).toFixed(2) /* 0.01 precision */ + ") ";
      }
      strGame = strGame + "SCODE " + simpleCodeHandler.codeToString(simpleCodeHandler.convert(sCode));
      strGame = strGame.trim();

      store_player_info(game_cnt, nbColumns, score, currentAttemptNumber-1, timeStr, (Math.round(sumPerfs * 100.0) / 100.0).toFixed(2) /* 0.01 precision */, nbUnknownPerfs, (((nbColorsRevealed > 0) || (nb_random_codes_played == 0)) ? nbColorsRevealed + 'x' : Math.min(nb_random_codes_played,9) + 'ra'), strGame);
    }
  }

  return true;
}

// List of possible codes
function writePossibleCodes(possibleCodesList_p, nb_possible_codes_listed, globalPerformancesList_p, attempt_nb, game_id) {
  if (game_id != game_cnt) { // ignore other threads
    console.log("writePossibleCodes() call ignored: " + game_id + ", " + game_cnt);
    return false;
  }
  if ( (nb_possible_codes_listed <= 0) || (possibleCodesList_p.length < nb_possible_codes_listed) || (globalPerformancesList_p.length < nb_possible_codes_listed)
        || (attempt_nb != nbOfStatsFilled_ListsOfPossibleCodes + 1) // lists of possible codes shall be filled consecutively
        || (attempt_nb > nbOfStatsFilled_NbPossibleCodes) // lists of possible codes shall be filled after numbers of possible codes
        || (attempt_nb <= 0) || (attempt_nb > nbMaxAttempts)
        || (possibleCodesListsSizes[attempt_nb-1] != 0 /* initial value */)
        || ((nbOfPossibleCodes[attempt_nb-1] <= nbMaxPossibleCodesShown) && (nb_possible_codes_listed != nbOfPossibleCodes[attempt_nb-1])) // (cf. above assumption on stats writing)
        || ((nbOfPossibleCodes[attempt_nb-1] > nbMaxPossibleCodesShown) && (nb_possible_codes_listed != nbMaxPossibleCodesShown)) ) { // (cf. above assumption on stats writing)
    displayGUIError("invalid stats (" + attempt_nb + ", " + nbOfStatsFilled_NbPossibleCodes + ", " + nbOfPossibleCodes[attempt_nb-1] + ", " + nb_possible_codes_listed + ") (3)", new Error().stack);
    return false;
  }
  for (let i = 0; i < nb_possible_codes_listed; i++) {
    let code = possibleCodesList_p[i];
    let global_perf = globalPerformancesList_p[i];
    if (!simpleCodeHandler.isFullAndValid(code)) {
      displayGUIError("invalid stats (" + attempt_nb + ", " + nbOfStatsFilled_NbPossibleCodes + ", " + i + ", " + code + ") (4)", new Error().stack);
      return false;
    }
   if ( ((global_perf <= 0.01) && (global_perf != PerformanceUNKNOWN))
        || (global_perf == PerformanceNA) ) {
      displayGUIError("invalid stats (unknown code performance(s) after evaluation) (5)", new Error().stack);
      return false;
    }
    possibleCodesLists[attempt_nb-1][i] = code;
    globalPerformancesList[attempt_nb-1][i] = global_perf; // may be PerformanceUNKNOWN
  }
  possibleCodesListsSizes[attempt_nb-1] = nb_possible_codes_listed;
  nbOfStatsFilled_ListsOfPossibleCodes = attempt_nb;

  main_graph_update_needed = true;
  draw_graphic(false);
  return true;
}

// ****************
// Storage function
// ****************

function updateAndStoreNbGamesStarted(offset) {

  try {
    if (typeof(Storage) !== 'undefined') {
      switch (nbColumns) {
        case 3:
          if (localStorage.nbgamesstarted3) {
            localStorage.nbgamesstarted3 = Number(localStorage.nbgamesstarted3) + offset;
          }
          break;
        case 4:
          if (localStorage.nbgamesstarted4) {
            localStorage.nbgamesstarted4 = Number(localStorage.nbgamesstarted4) + offset;
          }
          break;
        case 5:
          if (localStorage.nbgamesstarted5) {
            localStorage.nbgamesstarted5 = Number(localStorage.nbgamesstarted5) + offset;
          }
          break;
        case 6:
          if (localStorage.nbgamesstarted6) {
            localStorage.nbgamesstarted6 = Number(localStorage.nbgamesstarted6) + offset;
          }
          break;
        case 7:
          if (localStorage.nbgamesstarted7) {
            localStorage.nbgamesstarted7 = Number(localStorage.nbgamesstarted7) + offset;
          }
          break;
        default:
          throw new Error("updateAndStoreNbGamesStarted(): invalid number of columns: " + nbColumns);
      }
    }
    else {
      console.log("nbgamesstarted cannot be stored (no storage support)");
    }
  }
  catch (err) {
    displayGUIError("error while storing nbgamesstarted: " + err, new Error().stack);
  }


}

// **************************************
// Translate coordinates from/into pixels
// **************************************

function updateAttributesWidthAndHeightValues(width, height) {

  main_graph_update_needed = true;

  current_width = Math.max(width, 1);
  current_height = Math.max(height, 1);
  width_shift = Math.floor((current_width * left_border_margin_x) / 100.0);
  reduced_width = Math.floor((current_width * (100.0 - left_border_margin_x - right_border_margin_x)) / 100.0);
  height_shift = Math.floor((current_height * top_border_margin_y) / 100.0);
  x_axis_height = 0; // Fixed x axis height
  reduced_height = Math.floor((current_height * (100.0 - top_border_margin_y - bottom_border_margin_y)) / 100.0) - x_axis_height;

}

function get_x_pixel(x) {
  if ( (x < x_min - 0.0000001) || (x > x_max + 0.0000001) ) {
    displayGUIError("out of range x value: " + x, new Error().stack);
    if (x < x_min) x = x_min;
    if (x > x_max) x = x_max;
  }
  return Math.round(width_shift + ((x - x_min) * reduced_width) / (x_max - x_min));
}

function get_x_coordinate(x_pixel) {
  let res;
  if ( (x_pixel < 0) || (x_pixel > current_width) ) {
    displayGUIError("out of range x pixel value: " + x_pixel, new Error().stack);
    if (x_pixel < 0) x_pixel = 0;
    if (x_pixel > current_width) x_pixel = current_width;
  }
  x_pixel_bis = x_pixel;
  if (x_pixel < width_shift) x_pixel_bis = width_shift;
  res = x_min + (((x_pixel_bis - width_shift) * (x_max - x_min)) / reduced_width);
  if (res < x_min) res = x_min;
  if (res > x_max) res = x_max;
  return res;
}

function get_y_pixel(y, ignoreRanges = false) {
  if ( (!ignoreRanges) && ((y < y_min - 0.0000001) || (y > y_max + 0.0000001)) ) {
    displayGUIError("out of range y value: " + y, new Error().stack);
    if (y < y_min) y = y_min;
    if (y > y_max) y = y_max;
  }
  /* if (y < y_min + 1.0) { // x axis height
    return height_shift + reduced_height + x_axis_height - Math.ceil(((y - y_min) * x_axis_height) / 1.0);
  }
  else { */
  return height_shift + reduced_height - Math.ceil(((y - (y_min + 1.0)) * reduced_height) / (y_max - (y_min + 1.0))); // (Math.ceil() is better than Math.floor() to address y grid's rounding issues)
  /* } */
}

function get_y_coordinate(y_pixel) {
  let res;
  if ( (y_pixel < 0) || (y_pixel > current_height) ) {
    displayGUIError("out of range y pixel value: " + y_pixel, new Error().stack);
    if (y_pixel < 0) y_pixel = 0;
    if (y_pixel > current_height) y_pixel = current_height;
  }
  if (y_pixel > height_shift + reduced_height + x_axis_height) {
    res = y_min;
  }
  else if (y_pixel < height_shift) {
    res = y_max;
  }
  /* else if ( (y_pixel > height_shift + reduced_height) && (y_pixel <= height_shift + reduced_height + x_axis_height) ) { // x axis height
    res = y_min + (height_shift + reduced_height + x_axis_height - y_pixel) / x_axis_height;
  } */
  else {
    res = (y_min + 1.0) + ((height_shift + reduced_height - y_pixel) * (y_max - (y_min + 1.0))) / reduced_height;
  }
  if (res < y_min) res = y_min;
  if (res > y_max) res = y_max;
  return res;
}

// ************
// Draw graphic
// ************

// Draw horizontal or vertical lines
function drawLine(ctx, x_0, y_0, x_1, y_1, linewidth = 1) {
  if (x_0 == x_1) {
    ctx.fillRect(x_0,y_0,linewidth,y_1-y_0);
  }
  else {
    ctx.fillRect(x_0,y_0,x_1-x_0,linewidth);
  }
}

/* More general functions to draw lines, but non-integer linewidth is not supported by Chrome) */
function newDrawLinePath(ctx, color, linewidth = 1) {
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = linewidth;
}
function drawLineWithPath(ctx, x_0, y_0, x_1, y_1) {
  ctx.beginPath();
  ctx.moveTo(x_0+0.5,y_0+0.5);
  ctx.lineTo(x_1+0.5,y_1+0.5);
  ctx.stroke();
}

function draw_graphic(fullMode = true) {
  let gameOnGoingIni = gameOnGoing();
  let currentAttemptNumberIni = currentAttemptNumber;
  draw_graphic_bis();
  if ( (gameOnGoingIni != gameOnGoing()) || (currentAttemptNumber != currentAttemptNumberIni) ) {
   updateGameSizes();
   draw_graphic_bis();
  }
  if (fullMode) {
    draw_graphic_bis(); // sometimes improves the display  - not perfect but best solution found
  }
}

function draw_graphic_bis() {

  let canvas = document.getElementById("my_canvas");
  let ctx = canvas.getContext("2d");

  let res;
  let draw_exception = false;

  let nbColorsRevealed = 0;

  let last_attempt_event = false;

  try {

    ctx.imageSmoothingEnabled = false;
    // ctx.mozImageSmoothingEnabled = false; // (obsolete)
    ctx.webkitImageSmoothingEnabled = false;
    ctx.msImageSmoothingEnabled = false;
    ctx.oImageSmoothingEnabled = false;
    ctx.globalAlpha = 1;

    let resize_detected = false;
    let resize_cnt = 0;
    do {

      resize_detected = false;
      let width;
      let height;
      width = canvas.clientWidth;
      height = canvas.clientHeight;
      // (Alternate sizes:
      //  width = canvas.offsetWidth - 2*2; // 2*2px (canvas' border = 2px) (2nd best solution - not perfect)
      //  height = canvas.offsetHeight - 2*2; // 2*2px (canvas' border = 2px) (2nd best solution - not perfect)
      //  width = canvas.scrollWidth; // (3rd best solution found)
      //  height = canvas.scrollHeight; // (3rd best solution found)
      //  width = canvas.offsetWidth;
      //  height = canvas.offsetHeight;
      //  let positionInfo = canvas.getBoundingClientRect();
      //  height = positionInfo.height;
      //  width = positionInfo.width;

      if ( (current_width != width) || (current_height != height) ) {

        resize_detected = true;
        resize_cnt++;

        if (CompressedDisplayMode) {
          if (width >= CompressedDisplayMode_uncompressWidth) {
            CompressedDisplayMode = false; // (transition)
            updateGameSizes();
          }
        }
        else if (width <= CompressedDisplayMode_compressWidth) {
          CompressedDisplayMode = true; // (transition)
          updateGameSizes();
        }
        mobileMode = false;
        androidMode = false;
        if ( (/Mobi/i.test(navigator.userAgent)) || (/Android/i.test(navigator.userAgent)) // (mobile device check 1/2)
             || (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Windows Phone|Opera Mini/i.test(navigator.userAgent)) ) { // (mobile device check 2/2)
          if (!CompressedDisplayMode) {
            CompressedDisplayMode = true; // (transition)
            updateGameSizes();
          }
          mobileMode = true;
          backgroundColor_2 = "#FFFFFF";
          backgroundColor_3 = "#EEEEEE";
          if (/Android/i.test(navigator.userAgent)) {
            androidMode = true;
          }
        }
        if (mobileMode && androidMode) {  // It is not possible to change the \u2714 and \u2716 character color on Android/Chrome
          tickChar = "\u2713"; /* (check mark/tick) */
          crossChar = "\u2715"; /* (cross) */
        }
        else {
          tickChar = "\u2714"; /* (check mark/tick) */
          crossChar = "\u2716"; /* (cross) */
        }
        if (CompressedDisplayMode) {

          for (let i = nbMinColumns; i <= nbMaxColumns; i++) {
            document.getElementById("columnslabel_" + i).innerHTML = nbColumnsRadioObjectIniNames[i-nbMinColumns].replace(" " + i + " columns", i);
          }
          document.getElementById("resetCurrentCodeButton").value = "\u2718";
          document.getElementById("playRandomCodeButton").value = "\u266C";
          document.getElementById("revealSecretColorButton").value = "?";
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonCompressedName;
          document.getElementById("my_table").style.width = "100%";
          document.getElementById("my_table").style.left = "0%";
          document.getElementById("my_table").style.height = "100%";
          document.getElementById("my_table").style.top = "0%";
          document.getElementById("my_table").style.border = "none";
          document.getElementById("my_table").style["border-radius"] = "0%";
          document.getElementById("my_canvas").style.width = myCanvasIniWidth;
          if (firefoxMode) {
            document.getElementById("my_canvas").style.height = "95%";
          }
          else {
            document.getElementById("my_canvas").style.height = "98%"; // (does not work with Firefox)
          }

          try { // (try/catch because optional pictures)
            document.getElementById("img_1").style.display = 'none';
            document.getElementById("img_2").style.display = 'none';
          }
          catch (err) {}

          left_border_margin_x = 1.0;   // Left border margin for x axis in %
          right_border_margin_x = 1.0;  // Right border margin for x axis in %
          bottom_border_margin_y = 1.5; // Bottom border margin for y axis in %
          top_border_margin_y = 1.0;    // Top border margin for y axis in %

        }
        else {

          for (let i = nbMinColumns; i <= nbMaxColumns; i++) {
            document.getElementById("columnslabel_" + i).innerHTML = nbColumnsRadioObjectIniNames[i-nbMinColumns];
          }
          document.getElementById("resetCurrentCodeButton").value = resetCurrentCodeButtonIniName;
          document.getElementById("playRandomCodeButton").value = playRandomCodeButtonIniName;
          document.getElementById("revealSecretColorButton").value = revealSecretColorButtonIniName;
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonIniName;
          document.getElementById("my_table").style.width = tableIniWidth;
          document.getElementById("my_table").style.left = tableIniLeft;
          document.getElementById("my_table").style.height = tableIniHeight;
          document.getElementById("my_table").style.top = tableIniTop;
          document.getElementById("my_table").style.border = tableIniBorder;
          document.getElementById("my_table").style["border-radius"] = tableIniBorderRadius;
          document.getElementById("my_canvas").style.width = myCanvasIniWidth;
          document.getElementById("my_canvas").style.height = myCanvasIniHeight;

          try { // (try/catch because optional pictures)
            document.getElementById("img_1").style.display = 'inline';
            document.getElementById("img_2").style.display = 'inline';
          }
          catch (err) {}

          left_border_margin_x = 5.0;   // Left border margin for x axis in %
          right_border_margin_x = 5.0;  // Right border margin for x axis in %
          bottom_border_margin_y = 2.5; // Bottom border margin for y axis in %
          top_border_margin_y = 2.5;    // Top border margin for y axis in %

        }

        let allButtons = document.getElementsByClassName("button");
        let allRadioButtons = document.getElementsByClassName("radio");
        if (height < 600) {
          for (let i = 0; i < allButtons.length; i++) {
            allButtons[i].style.fontSize = "10px";
          }
          for (let i = 0; i < allRadioButtons.length; i++) {
            allRadioButtons[i].style.fontSize = "10px";
          }
        }
        else {
          for (let i = 0; i < allButtons.length; i++) {
            allButtons[i].style.fontSize = "1.8vh"; // proportional to viewport height
          }
          for (let i = 0; i < allRadioButtons.length; i++) {
            allRadioButtons[i].style.fontSize = "1.67vh"; // proportional to viewport height - 10/(600/100) = 1.67
          }
        }

        canvas.width = width; /* (necessary as canvas may have been expanded to fill its container) */
        canvas.height = height; /* (necessary as canvas may have been expanded to fill its container) */
        ctx.setTransform(1,0,0,1,0,0); // resets the canvas current transform to the identity matrix
        updateAttributesWidthAndHeightValues(width, height);

      }

    } while (resize_detected && (resize_cnt <= 44)); // several iterative calls are necessary to redraw the canvas with proper width and height on window resize

    let nbColumnsSelected = getNbColumnsSelected();
    if ( (nbColumnsSelected < 0) || (nbColumnsSelected > nbMaxColumns) ) { // (error case)
      displayGUIError("inconsistent number of columns selected: " + nbColumnsSelected, new Error().stack);
      nbColumnsSelected = defaultNbColumns;
    }
    if ( newGameEvent
         || (nbColumns != nbColumnsSelected) ) { // Check event "column number change"
      resetGameAttributes(nbColumnsSelected);
    }
    if (simpleCodeHandler.getNbColumns() != nbColumns) {
      throw new Error("invalid nbColumns handling");
    }

    if ((currentAttemptNumber <= 0) || (currentAttemptNumber > nbMaxAttempts+1)) { // Defensive check that currentAttemptNumber is valid
      displayGUIError("inconsistent currentAttemptNumber value: " + currentAttemptNumber, new Error().stack);
    }
    else {
      if ( gameOnGoing() // playing phase
           && simpleCodeHandler.isFullAndValid(currentCode) ) { // New code submitted

        nbCodesPlayed++;

        if (1 == currentAttemptNumber) {
          startTime = (new Date()).getTime(); // time in milliseconds
          stopTime = startTime;
          updateAndStoreNbGamesStarted(+1);
        }
        codesPlayed[currentAttemptNumber-1] = currentCode;
        let sCodeConv = simpleCodeHandler.convert(sCode);
        if (!simpleCodeHandler.isFullAndValid(sCodeConv)) {
          throw new Error("inconsistent code (" + sCodeConv + ")");
        }
        simpleCodeHandler.fillMark(sCodeConv, currentCode, marks[currentAttemptNumber-1]);
        if ((marks[currentAttemptNumber-1].nbBlacks == 0) && (marks[currentAttemptNumber-1].nbWhites == 0)) { // worst mark
          for (let col = 0; col < nbColumns; col++) {
            obviouslyImpossibleColors[simpleCodeHandler.getColor(currentCode, col+1)] = true;
          }
        }
        if (marks[currentAttemptNumber-1].nbBlacks == nbColumns) { // game over (game won)
          stopTime = (new Date()).getTime(); // time in milliseconds
          currentAttemptNumber++;
          currentCode = -1;
          gameWon = true;
          nbGamesPlayed++;
          nbGamesPlayedAndWon++;
        }
        else {
          currentAttemptNumber++;
          if (currentAttemptNumber == nbMaxAttempts+1) { // game over (game lost)
            currentCode = -1;
            stopTime = (new Date()).getTime(); // time in milliseconds
            nbGamesPlayed++;
          }
          else {
            last_attempt_event = (currentAttemptNumber == nbMaxAttempts) /* (last attempt) */
            currentCode = sCodeRevealed;
          }
        }
        main_graph_update_needed = true;

        // Send a message to the gameSolver worker for the new code submitted
        let nbMaxAttemptsForEndOfGame;
        if (gameWon) {
          nbMaxAttemptsForEndOfGame = currentAttemptNumber-1;
        }
        else {
          nbMaxAttemptsForEndOfGame = nbMaxAttempts;
        }

        if (game_id_for_gameSolverConfig != game_cnt) { // ignore other threads
          console.log("next attempt ignored: " + game_id_for_gameSolverConfig + ", " + game_cnt);
        }
        else {
          if (game_id_for_initGameSolver == -1) { // 'INIT' message was not posted yet
            console.log("(anticipated 'INIT' message)");
            postInitMessageToGameSolver(game_id_for_gameSolverConfig);
          }
          if (game_id_for_initGameSolver == game_cnt) {
            if (gameSolver !== undefined) {
              gameSolverDbg++;
              let precalculated_games = "";
              if ((nbColumns == 5) && (currentAttemptNumber == 2)) { // first NEW_ATTEMPT message posted
                precalculated_games = precalculated_games_5columns_1st_level[marks[currentAttemptNumber-2].nbBlacks][marks[currentAttemptNumber-2].nbWhites];
                if (precalculated_games == undefined) {
                  precalculated_games = "";
                }
              }
              gameSolver.postMessage({'req_type': 'NEW_ATTEMPT', 'curAttemptNumber': currentAttemptNumber-1, 'nbMaxAttemptsForEndOfGame': nbMaxAttemptsForEndOfGame, 'code': codesPlayed[currentAttemptNumber-2], 'mark_nbBlacks': marks[currentAttemptNumber-2].nbBlacks, 'mark_nbWhites': marks[currentAttemptNumber-2].nbWhites, 'precalculated_games': precalculated_games, 'game_id': game_cnt});
              gameSolverDbg++;
            }
            else {
              throw new Error("undefined gameSolver (" + currentAttemptNumber + ")");
            }
          }
          else {
            throw new Error("invalid game_id_for_initGameSolver value at next attempt: " + game_id_for_initGameSolver);
          }
        }

      }
    }

    // ***************
    // Full repainting
    // ***************

    let nbMaxAttemptsToDisplay = ((!showPossibleCodesMode) ? nbMaxAttempts-nb_attempts_not_displayed : currentAttemptNumber-1);

    if (main_graph_update_needed) { // Note: no double buffering is needed in javascript (canvas contents do not need to be refilled as during Java's repaint())

      let x_0, y_0, x_1, y_1;

      ctx.fillStyle = backgroundColor_2;
      ctx.fillRect(0,0,current_width,current_height);

      // ***************
      // Adapt font size
      // ***************

      let x_cell_delta = get_x_pixel(x_min+x_step) - get_x_pixel(x_min);
      let y_cell_delta = get_y_pixel(y_min) - get_y_pixel(y_min+y_step);

      font_size = min_font_size;
      let last_valid_font_size = font_size;
      let font_tmp = "bold " + font_size + "px " + fontFamily;
      ctx.font = font_tmp;
      let font_width_1char = ctx.measureText("X").width;
      let font_height = font_size;
      while ((font_height <= Math.min(y_cell_delta-4,y_cell_delta*80.0/100.0) /* (margin + char height imprecision) */) && (font_size <= max_font_size) && (font_width_1char <= x_cell_delta-3)) {
        last_valid_font_size = font_size;
        font_size = font_size + 1;
        font_tmp = "bold " + font_size + "px " + fontFamily;
        ctx.font = font_tmp;
        font_width_1char = ctx.measureText("X").width;
        font_height = font_size;
      }
      font_size = last_valid_font_size;

      star_font_size = min_font_size;
      let last_valid_star_font_size = star_font_size;
      let star_font_tmp = "bold " + star_font_size + "px " + fontFamily;
      ctx.font = star_font_tmp;
      let star_font_width_1char = ctx.measureText("\u2B50").width; // star
      let star_font_height = star_font_size;
      while ((star_font_height <= Math.min(y_cell_delta-6,y_cell_delta*85.0/100.0) /* (margin + char height imprecision) */) && (star_font_size <= max_font_size) && (star_font_width_1char <= x_cell_delta-3)) {
        last_valid_star_font_size = star_font_size;
        star_font_size = star_font_size + 1;
        star_font_tmp = "bold " + star_font_size + "px " + fontFamily;
        ctx.font = star_font_tmp;
        star_font_width_1char = ctx.measureText("\u2B50").width; // star
        star_font_height = star_font_size;
      }
      star_font_size = Math.min(last_valid_star_font_size, font_size);

      basic_font = font_size + "px " + fontFamily;
      basic_bold_font = "bold " + font_size + "px " + fontFamily;
      basic_bold_italic_font = "bold italic " + font_size + "px " + fontFamily;

      small_basic_font = Math.max(Math.floor(font_size/1.4), min_font_size) + "px " + fontFamily;
      small_bold_font = "bold " + Math.max(Math.floor(font_size/1.4), min_font_size) + "px " + fontFamily;
      small_italic_font = "italic " + Math.max(Math.floor(font_size/1.4), min_font_size) + "px " + fontFamily;
      very_small_italic_font = "italic " + Math.max(Math.floor(font_size/2.34), min_font_size) + "px " + fontFamily;

      medium_basic_font = Math.max(Math.floor(font_size/1.5), min_font_size) + "px " + fontFamily;
      medium_bold_font = "bold " + Math.max(Math.floor(font_size/1.5), min_font_size) + "px " + fontFamily;
      medium2_bold_font = "bold " + Math.min(Math.max(Math.floor(font_size/1.5)+2, min_font_size), font_size) + "px " + fontFamily;
      medium_bold_italic_font = "bold italic " + Math.max(Math.floor(font_size/1.5), min_font_size) + "px " + fontFamily;
      if (!showPossibleCodesMode) {
        // (related to medium_bold_font)
        stats_font = "bold " + Math.max(Math.floor(font_size/1.5), min_font_size) + "px " + fontFamily;
      }
      else {
        stats_font = "bold " + Math.max(Math.floor(star_font_size), min_font_size) + "px " + fontFamily;
      }

      error_font = font_size + "px " + fontFamily;

      // Draw main game table
      // ********************

      x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
      y_0 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
      y_1 = get_y_pixel(y_min);
      ctx.fillStyle = backgroundColor_3;
      ctx.fillRect(x_0, y_0, x_1-x_0, y_1-y_0);

      ctx.font = basic_bold_font;
      for (let attempt = 0; attempt <= nbMaxAttemptsToDisplay; attempt++) {
        x_0 = get_x_pixel(x_min);
        y_0 = get_y_pixel(y_min+attempt*y_step);
        x_1 = get_x_pixel(x_max);
        y_1 = get_y_pixel(y_min+attempt*y_step);
        ctx.fillStyle = darkGray;
        drawLine(ctx, x_0, y_0, x_1+1, y_1);
        if (attempt < nbMaxAttemptsToDisplay) {
          let backgroundColor = backgroundColor_2;
          if (attempt+1 == currentPossibleCodeShown) {
            backgroundColor = highlightColor;
          }
          let str_width;
          if (attempt_nb_width == 0) {
            if (attempt+1 <= currentAttemptNumber-1) { // a mark will be displayed at this place
              continue;
            }
            str_width = (90*(nbColumns+1))/100;
          }
          else {
            str_width = attempt_nb_width;
          }
          let attempt_nb_str_to_display = "";
          if ((!showPossibleCodesMode) && (nb_attempts_not_displayed > 0) && (attempt+1 == nbMaxAttemptsToDisplay)) {
            attempt_nb_str_to_display = String(nbMaxAttempts);
          }
          else {
            attempt_nb_str_to_display = String(attempt+1);
          }
          if (gameWon) {
            if (attempt+1 == currentAttemptNumber-1) {
              displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                            darkGray, backgroundColor, ctx, true, 0, true, 0);
            }
            else {
              displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                            lightGray, backgroundColor, ctx, true, 0, true, 0);
            }
          }
          else if (attempt+1 == currentAttemptNumber) {
            if (attempt+1 == nbMaxAttempts) {
              displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                            redColor, backgroundColor, ctx, true, 0, true, 0);
            }
            else if ( (attempt+2 == nbMaxAttempts)
                      || ((attempt+3 == nbMaxAttempts) && (nbColumns >= 6)) ) {
              displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                            orangeColor, backgroundColor, ctx, true, 0, true, 0);
            }
            else {
              displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                            darkGray, backgroundColor, ctx, true, 0, true, 0);
            }
          }
          else {
            displayString(attempt_nb_str_to_display, 0, attempt, str_width,
                          lightGray, backgroundColor, ctx, true, 0, true, 0);
          }
        }
      }

      ctx.fillStyle = darkGray;
      x_0 = get_x_pixel(x_min);
      y_0 = get_y_pixel(y_min);
      x_1 = get_x_pixel(x_min);
      y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      drawLine(ctx, x_0, y_0, x_1, y_1);

      x_0 = get_x_pixel(x_min+x_step*attempt_nb_width);
      y_0 = get_y_pixel(y_min);
      x_1 = get_x_pixel(x_min+x_step*attempt_nb_width);
      y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      drawLine(ctx, x_0, y_0, x_1, y_1);

      for (let col = 0; col <= nbColumns; col++) {
        x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
        y_0 = get_y_pixel(y_min);
        x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
        y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
        drawLine(ctx, x_0, y_0, x_1, y_1);
      }

      x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width));
      y_0 = get_y_pixel(y_min);
      x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width));
      y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      drawLine(ctx, x_0, y_0, x_1, y_1);

      x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width));
      y_0 = get_y_pixel(y_min);
      x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width));
      y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      drawLine(ctx, x_0, y_0, x_1, y_1);

      x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width+tick_width));
      y_0 = get_y_pixel(y_min);
      x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width+tick_width));
      y_1 = get_y_pixel(y_min+y_step*nbMaxAttemptsToDisplay);
      drawLine(ctx, x_0, y_0, x_1, y_1);

      // Draw codes played and associated marks
      // **************************************

      ctx.font = basic_bold_font;
      for (let i = 1; i < currentAttemptNumber; i++) {

        displayCode(codesPlayed[i-1], i-1, ctx);

        let backgroundColor = backgroundColor_2;
        if (i == currentPossibleCodeShown) {
          backgroundColor = highlightColor;
        }
        displayMark(marks[i-1], i-1, backgroundColor, ctx);

      }

      // Draw stats
      // **********

      ctx.font = stats_font;
      let nbMaxHintsDisplayed = 2;

      for (let i = 0; i < nbMaxAttempts; i++) {
        performancesDisplayed[i] = false;
      }

      for (let i = 1 ; i <= nbOfStatsFilled_Perfs; i++) {
        let backgroundColor = backgroundColor_2;
        if (i == currentPossibleCodeShown) {
          backgroundColor = highlightColor;
        }

        if (i < currentAttemptNumber) {
          // Relative performance was filled and may be known or unknown
          displayPerf(relative_performances_of_codes_played[i-1], i-1, backgroundColor, isAttemptPossible(i), showPossibleCodesMode, false, PerformanceNA, ctx);
          if ( relativePerformancesEvaluationDone[i-1]
               && (relative_performances_of_codes_played[i-1] != PerformanceUNKNOWN)
               && (relative_performances_of_codes_played[i-1] <= PerformanceLOW) ) {
            performancesDisplayed[i-1] = true;
          } // else: allow overwriting
        }
      }

      if (optimal_width > 0) { // (the below x_cell values are only valid for (optimal_width > 0), as in displayPerf())
        if (nbOfStatsFilled_NbPossibleCodes > nbOfStatsFilled_Perfs+1) {
          displayString("\u301C" /* clock */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbOfStatsFilled_Perfs+1-1, optimal_width,
                        lightGray, backgroundColor_2, ctx);
        }
        else if (!gameOnGoing() && (nbOfStatsFilled_NbPossibleCodes > nbOfStatsFilled_Perfs)) {
          displayString("\u301C" /* clock */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbOfStatsFilled_Perfs+1-1, optimal_width,
                        lightGray, backgroundColor_2, ctx);
        }
        if (gameOnGoing() && (currentAttemptNumber == 1) && (currentAttemptNumber > nbOfStatsFilled_NbPossibleCodes)) {
          displayString("\u301C" /* clock */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, 0, nb_possible_codes_width,
                        lightGray, backgroundColor_2, ctx);
        }
      }
      else {
        if ( gameOnGoing()
             && ( (currentAttemptNumber > nbOfStatsFilled_NbPossibleCodes + 1 /* (+1 to simplify) */)
                  || ((currentAttemptNumber == 1) && (nbOfStatsFilled_NbPossibleCodes == 0)) )
             && (nbOfStatsFilled_NbPossibleCodes < nbMaxAttempts) ) {
          displayString("\u301C" /* clock */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbOfStatsFilled_NbPossibleCodes+1-1, nb_possible_codes_width,
                        lightGray, backgroundColor_2, ctx);
        }
      }

      for (let i = 1 ; i <= nbOfStatsFilled_NbPossibleCodes; i++) {
        let backgroundColor = backgroundColor_2;
        if (i == currentPossibleCodeShown) {
          backgroundColor = highlightColor;
        }

        if ((optimal_width > 0) || (i == currentAttemptNumber) || (!performancesDisplayed[i-1]) /* (nb of possible codes <-> perf switch) */) {
          let statsColor;
          if ((i == currentAttemptNumber) || (gameWon && (i == currentAttemptNumber-1))) {
            statsColor = darkGray;
          }
          else {
            statsColor = lightGray;
          }
          if (!displayString("\u2009" /* (thin space) */ + nbOfPossibleCodes[i-1] + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, i-1, nb_possible_codes_width,
                             statsColor, backgroundColor, ctx, true, 0, true, 0)) {
            displayString(String(nbOfPossibleCodes[i-1].toExponential(1)).replace("e+","e"), attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, i-1, nb_possible_codes_width,
                                       statsColor, backgroundColor, ctx);
          }
        }
      }

      // Draw whether codes are possible or not
      // **************************************

      if (tick_width > 0) {
        ctx.font = basic_bold_font;
        for (let i = 1 ; i < currentAttemptNumber; i++) {

          let backgroundColor = backgroundColor_2;
          if (i == currentPossibleCodeShown) {
            backgroundColor = highlightColor;
          }

          let isPossible = isAttemptPossible(i);
          if ( gameOnGoing() && (i > nbMaxHintsDisplayed)
               && ((relative_performances_of_codes_played[i-1] > -0.9999) || (relative_performances_of_codes_played[i-1] == PerformanceUNKNOWN) || (relative_performances_of_codes_played[i-1] == PerformanceNA)) // not a useless code (simplified test)
               && (nbColumns >= nominalGameNbColumns) ) { // not easy games
            ctx.font = stats_font;
            displayString("\u2234" /* tick hidden */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                          lightGray, backgroundColor, ctx);
            ctx.font = basic_bold_font;
          }
          else if (0 == isPossible) { // code is possible
            if (relative_performances_of_codes_played[i-1] == -1.00) { // useless code (simplified test)
              displayGUIError("useless code inconsistency: " + relative_performances_of_codes_played[i-1], new Error().stack);
            }
            displayString(tickChar, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                          greenColor, backgroundColor, ctx);
          }
          else { // code is not possible
            if (i <= 2) {
              displayString(crossChar, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                            redColor, backgroundColor, ctx);
            }
            else {
              if (!displayString("\u2009" /* (thin space) */ + crossChar + "\u2009" /* (thin space) */ + isPossible + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                                 redColor, backgroundColor, ctx, true, 0, true, 0)) {
                if (!displayString(isPossible, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                                   redColor, backgroundColor, ctx, true, 0, true, 0)) {
                  displayString(crossChar, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, i-1, tick_width,
                                redColor, backgroundColor, ctx);
                }
              }
            }
          }

        }
      }

      let HintsThreshold = 5;
      if (!showPossibleCodesMode) {

        // Display game version
        // ********************

        if ((!CompressedDisplayMode) && (optimal_width > 0) && (tick_width > 0)) {
          ctx.font = very_small_italic_font;
          displayString(version, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width+tick_width-5, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors, 5,
                        lightGray, backgroundColor_2, ctx, true, 2, true, 1, true /* (ignoreRanges) */);
        }

        // Display column headers
        // **********************

        ctx.font = medium_bold_font;
        if ((!gameOnGoing()) && allPerformancesFilled()) {
          let str1, str1bis, str2;
          let sum_rounded = Math.round(sumPerfs * 100.0) / 100.0; // 0.01 precision
          str1 = ":";
          str1bis = "";
          /* if (nbUnknownPerfs == 0) {
            str1 = ":";
            str1bis = "";
          }
          else {
            str1 = "";
            str1bis = "\u2248 ";
          } */
          if (sum_rounded > 0.0) {
            str2 = "+" + sum_rounded.toFixed(2) + "!"; // 2 decimal figures
          }
          else {
            str2 = sum_rounded.toFixed(2); // 2 decimal figures
          }
          let res_header1 = false;
          let res_header2 = false;
          if (!display2Strings("number", "   " + "of codes" + "   ", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                               lightGray, backgroundColor_2, ctx, 0, true)) {
            if (!displayString("\u2009" /* (thin space) */ + "#codes" + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                               lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
              if (displayString("\u2009" /* (thin space) */ + "#" + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                                lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
                res_header1 = true;
              }
            }
            else {
              res_header1 = true;
            }
          }
          else {
            res_header1 = true;
          }
          if (res_header1 && (optimal_width > 0)) {
            if (!display2Strings("total" + str1, str1bis + str2, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbMaxAttemptsToDisplay, optimal_width,
                                 lightGray, backgroundColor_2, ctx, 0, true)) {
              res_header2 = display2Strings("\u03A3" /* (capital sigma) */, str1bis + str2, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbMaxAttemptsToDisplay, optimal_width,
                                            lightGray, backgroundColor_2, ctx, 0, false); // (always display sum => res_header2 will be true)
            }
            else {
              res_header2 = true;
            }
          }
          if (res_header1 && (res_header2 || (optimal_width <= 0)) && (tick_width > 0)) {
            if (!displayString("\u2009" /* (thin space) */ + tickChar + "\u2009" /* (thin space) */ + "/" + "\u2009" /* (thin space) */ + crossChar + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, nbMaxAttemptsToDisplay, tick_width,
                               lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
              displayString(tickChar, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, nbMaxAttemptsToDisplay, tick_width,
                            lightGray, backgroundColor_2, ctx, true, 0, true, 1);
            }
          }

          if ( (!gameOnGoing()) && allPossibleCodesFilled()
               && (gameSolver !== undefined) ) {
            // (code duplicated:)
            isWorkerAlive = -1.5;
            gameSolverDbg = 1.5;
            gameSolver.terminate(); gameSolverDbg = 2.5;
            gameSolver = undefined;
          }

        }
        else {
          let res_header1 = false;
          let res_header2 = false;
          if (!display2Strings("number", "   " + "of codes" + "   ", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                               lightGray, backgroundColor_2, ctx, 0, true)) {
            if (!displayString("\u2009" /* (thin space) */ + "#codes" + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                               lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
              if (displayString("\u2009" /* (thin space) */ + "#" + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay, nb_possible_codes_width,
                                lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
                res_header1 = true;
              }
            }
            else {
              res_header1 = true;
            }
          }
          else {
            res_header1 = true;
          }
          if (res_header1 && (optimal_width > 0)) {
            if (!display2Strings("0: optimal", "-1: useless", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbMaxAttemptsToDisplay, optimal_width,
                                 lightGray, backgroundColor_2, ctx, 0, true)) {
              if (displayString("perf", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width, nbMaxAttemptsToDisplay, optimal_width,
                                lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
                res_header2 = true;
              }
            }
            else {
              res_header2 = true;
            }
          }
          if (res_header1 && (res_header2 || (optimal_width <= 0)) && (tick_width > 0)) {
            if (!displayString("\u2009" /* (thin space) */ + tickChar + "\u2009" /* (thin space) */ + "/" + "\u2009" /* (thin space) */ + crossChar + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, nbMaxAttemptsToDisplay, tick_width,
                               lightGray, backgroundColor_2, ctx, true, 0, true, 1)) {
              displayString(tickChar, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, nbMaxAttemptsToDisplay, tick_width,
                            lightGray, backgroundColor_2, ctx, true, 0, true, 1);
            }
          }
        }

        // Draw secret code
        // ****************

        ctx.fillStyle = darkGray;
        if (scode_height > 0) {
          for (let col = 0; col <= nbColumns; col++) {
            x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
            y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height));
            x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
            y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height));
            drawLine(ctx, x_0, y_0, x_1, y_1);
          }

          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height));
          drawLine(ctx, x_0, y_0, x_1+1, y_1);

          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height));
          drawLine(ctx, x_0, y_0, x_1, y_1);

          ctx.font = basic_bold_font;
          displayString("Secret code " + "\u2009" /* (thin space) */, 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                        darkGray, backgroundColor_2, ctx, true, 2, true, 0);
          if (gameOnGoing()) {
            displayCode(sCodeRevealed, nbMaxAttemptsToDisplay+transition_height, ctx, true);
          }
          else { // game over
            displayCode(simpleCodeHandler.convert(sCode), nbMaxAttemptsToDisplay+transition_height, ctx);
          }
        }

        // Display game over status
        // ************************

        if (!gameOnGoing()) {

          let totalTimeInSeconds = Math.floor((stopTime - startTime)/1000);
          let timeInMilliSeconds = (stopTime - startTime) % 1000;

          let timeInHours = Math.floor(totalTimeInSeconds/3600);
          let timeInSecondsWithinHour = (totalTimeInSeconds - timeInHours*3600); // (range: [0;3599]
          let timeInMinutes = Math.floor(timeInSecondsWithinHour/60);
          let timeInSeconds = timeInSecondsWithinHour - timeInMinutes*60; // (range: [0;59])

          if (timeInHours >= 24) {
            timeStr = "> 1 day";
          }
          else if (timeInHours >= 3) {
            timeStr = "> " + timeInHours + "h";
          }
          else if (timeInHours > 0) {
            if (timeInMinutes > 0) {
              if (timeInMinutes < 10) {
                timeStr = timeInHours + "h 0" + timeInMinutes;
              }
              else {
                timeStr = timeInHours + "h " + timeInMinutes;
              }
            }
            else {
              timeStr = timeInHours + "h";
            }
          }
          else if (timeInMinutes != 0) {
            timeInSeconds = Math.floor(timeInSeconds/10.0)*10;
            if (timeInMinutes >= 10) {
              timeStr = timeInMinutes + " min";
            }
            else if (timeInSeconds != 0) {
              timeStr = timeInMinutes + " min " + timeInSeconds + " s";
            }
            else {
              timeStr = timeInMinutes + " min";
            }
          }
          else {
            timeStr = timeInSeconds + " s";
          }

          if (gameWon) { // game won
            let victoryStr;
            let victoryStr2;
            let victoryStr3;
            let nb_attempts_for_max_score;
            let time_in_seconds_corresponding_to_one_attempt_in_score;
            let multiply_factor;
            switch (nbColumns) {
              case 3:
                nb_attempts_for_max_score = 3; // (estimate: ~16% of scores, below 3 would not be relevant)
                time_in_seconds_corresponding_to_one_attempt_in_score = 45.0; // (time corresponding to 2 attempts: 1 min 30)
                multiply_factor = 0.50;
                break;
              case 4:
                nb_attempts_for_max_score = 3; // (estimate: ~5% of scores)
                time_in_seconds_corresponding_to_one_attempt_in_score = 150.0; // (time corresponding to 2 attempts: 5 min)
                multiply_factor = 0.75;
                break;
              case 5:
                nb_attempts_for_max_score = 4; // (estimate: ~5% of scores)
                time_in_seconds_corresponding_to_one_attempt_in_score = 360.0; // (time corresponding to 2 attempts: 12 min) // See (*)
                multiply_factor = 1.0;
                break;
              case 6:
                nb_attempts_for_max_score = 6; // (estimate: ~15% of scores)
                time_in_seconds_corresponding_to_one_attempt_in_score = 600.0;  // (time corresponding to 2 attempts: 20 min) // See (*)
                multiply_factor = 1.5;
                break;
              case 7:
                nb_attempts_for_max_score = 7; // (estimate: ~7% of scores)
                time_in_seconds_corresponding_to_one_attempt_in_score = 900.0;  // (time corresponding to 2 attempts: 30 min) // See (*)
                multiply_factor = 2.0;
                break;
              default:
                throw new Error("invalid number of columns in score calculation: " + nbColumns);
            }
            let max_score = 100.0;
            let min_score = 1.4 - Math.min(totalTimeInSeconds/1000000, 0.4);
            let score_from_nb_attempts;
            if (currentAttemptNumber-1 /* number of attempts */ <= nb_attempts_for_max_score) { // (all the very low numbers of attempts ("lucky games") are handled the same way)
              score_from_nb_attempts = max_score;
            }
            else {
              score_from_nb_attempts = max_score - ((currentAttemptNumber-1) /* number of attempts */ - nb_attempts_for_max_score)*10.0;
            }
            let time_in_seconds_short_games = (2.0*time_in_seconds_corresponding_to_one_attempt_in_score)/3.0;
            let time_delta_score;
            if (totalTimeInSeconds <= time_in_seconds_short_games) { // scoring rule useful to distinguish good players
              time_delta_score = (totalTimeInSeconds*10.0)/time_in_seconds_short_games;
            }
            else { // scoring rule for other players
              // "good player's slope / 2"
              time_delta_score = 10.0 + (10.0 * (totalTimeInSeconds - time_in_seconds_short_games)) / (2*time_in_seconds_corresponding_to_one_attempt_in_score - time_in_seconds_short_games);
            }
            let max_time_delta_score = 2*10.0; // the time spent will tend not to cost more than 2 attempts in the score
            if ( (time_delta_score <= max_time_delta_score)
                 || (currentAttemptNumber-1 /* number of attempts */ >= nbMaxAttempts) /* at last attempt, score will tend towards zero "more quickly" as time goes on */ ) {
              score = multiply_factor * (score_from_nb_attempts - time_delta_score) + 0.499 - timeInMilliSeconds/10000000;
            }
            else {
              score = multiply_factor * (score_from_nb_attempts - max_time_delta_score
                                         - (time_delta_score - max_time_delta_score)/1.5) + 0.499 - timeInMilliSeconds/10000000; // "good player's slope / 3"
            }
            if (score < min_score) {
              score = min_score; /* (score will never be zero in case the game was won) */
            }

            // Check if the player was helped
            if (playerWasHelped) {
              victoryStr = "\u2009You won with help!\u2009";
              victoryStr2 = "\u2009You won /?\u2009";
              victoryStr3 = "Yes!";
              nbColorsRevealed = (nbColumns-simpleCodeHandler.nbEmptyColors(sCodeRevealed));
              if (nbColorsRevealed == 1) { // 1 color revealed
                score = Math.max(score / 3.0, min_score);
              }
              else if (nbColorsRevealed == 2) { // 2 colors revealed
                score = Math.max(score / (3.0*3.0), min_score);
              }
              else if (nbColorsRevealed > 2) { // > 2 colors revealed
                score = Math.max(score / (3.0*3.0*3.0), min_score);
              }
              else {
                score = 0.0;
                displayGUIError("internal error: nbColorsRevealed = " + nbColorsRevealed, new Error().stack);
              }
            }
            else {
              victoryStr = "\u2009You won!!!\u2009";
              victoryStr2 = "\u2009You won!\u2009";
              victoryStr3 = "Yes!";
            }

            // (code duplicated:)
            if (!displayString(victoryStr, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2, nb_possible_codes_width+optimal_width+tick_width,
                               greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              if (!displayString(victoryStr2, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2, nb_possible_codes_width+optimal_width+tick_width,
                                 greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                displayString(victoryStr3, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2, nb_possible_codes_width+optimal_width+tick_width,
                              greenColor, backgroundColor_2, ctx, true, 0, false, 0);
              }
            }
            if (!displayString("\u2009" /* (thin space) */ + "Time: " + timeStr + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                               greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              if (!displayString("\u2009" /* (thin space) */ + timeStr + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                 greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                if (!displayString("\u2009" /* (thin space) */ + timeStr.replaceAll(" min","m").replaceAll(" s","s").replaceAll(" ","\u2009" /* (thin space) */) + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                   greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                  displayString(timeStr.replaceAll("min","m").replaceAll("s","").replaceAll(" ",""), attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                                   greenColor, backgroundColor_2, ctx, true, 0, false, 0);
                }
              }
            }
            let rounded_score = Math.round(score);
            let ptsStr;
            if (rounded_score > 1) {
              ptsStr = "pts"
            }
            else {
              ptsStr = "pt";
            }
            if (!displayString("\u2009" /* (thin space) */ + "Score: " + rounded_score + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-2, nb_possible_codes_width+optimal_width+tick_width,
                               greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              if (!displayString("\u2009" /* (thin space) */ + rounded_score + "\u2009" /* (thin space) */ + ptsStr + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-2, nb_possible_codes_width+optimal_width+tick_width,
                                 greenColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                displayString(rounded_score + ptsStr, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-2, nb_possible_codes_width+optimal_width+tick_width,
                              greenColor, backgroundColor_2, ctx, true, 0, false, 0);
              }
            }

          }
          else if (currentAttemptNumber == nbMaxAttemptsToDisplay+1) { // game lost

            score = 0.0;
            // (code duplicated:)
            if (!displayString("\u2009You lost!\u2009", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2, nb_possible_codes_width+optimal_width+tick_width,
                               redColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              displayString("No!", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2, nb_possible_codes_width+optimal_width+tick_width,
                            redColor, backgroundColor_2, ctx, true, 0, false, 0);
            }
            if (!displayString("\u2009" /* (thin space) */ + "Time: " + timeStr + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                               redColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              if (!displayString("\u2009" /* (thin space) */ + timeStr + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                 redColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                if (!displayString("\u2009" /* (thin space) */ + timeStr.replaceAll(" min","m").replaceAll(" s","s").replaceAll(" ","\u2009" /* (thin space) */) + "\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                   redColor, backgroundColor_2, ctx, true, 0, true, 0)) {
                  displayString(timeStr.replaceAll("min","m").replaceAll("s","").replaceAll(" ",""), attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-1, nb_possible_codes_width+optimal_width+tick_width,
                                                   redColor, backgroundColor_2, ctx, true, 0, false, 0);
                }
              }
            }
            if (!displayString("\u2009Score: 0\u2009" /* (thin space) */, attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-2, nb_possible_codes_width+optimal_width+tick_width,
                               redColor, backgroundColor_2, ctx, true, 0, true, 0)) {
              displayString("0\u2009pt", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors/2-2, nb_possible_codes_width+optimal_width+tick_width,
                            redColor, backgroundColor_2, ctx, true, 0, false, 0);
            }
          }
          else {
            displayGUIError("game over inconsistency", new Error().stack);
          }

        }

        // Draw color selection
        // ********************

        if (font_size != min_font_size) {
          ctx.fillStyle = darkGray;
        }
        else {
          ctx.fillStyle = backgroundColor_2;
        }
        for (let color = 0; color <= nbColors; color++) {
          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+color));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+color));
          drawLine(ctx, x_0, y_0, x_1+1, y_1);
        }

        for (let col = 0; col <= nbColumns; col++) {
          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+nbColors));
          drawLine(ctx, x_0, y_0, x_1, y_1);
        }

        ctx.font = basic_bold_font;
        for (let color = 0; color < nbColors; color++) {
          for (let col = 0; col < nbColumns; col++) {
            color_selection_code = simpleCodeHandler.setColor(color_selection_code, color+1, col+1);
          }
          displayCode(color_selection_code, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+color, ctx);
        }

        ctx.fillStyle = darkGray;

        try {
          ctx.font = medium2_bold_font;
          if ((nbGamesPlayedAndWon == 0) && gameOnGoing() && (currentAttemptNumber <= 3)) {
            let x_delta = 0.75;
            if (!displayString("Select colors here!", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+1.35*x_delta, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+Math.floor(nbColors/2)-0.5, +nb_possible_codes_width+optimal_width+tick_width-2.70*x_delta,
                               darkGray, backgroundColor_2, ctx, true, 1, true, 0, false, true, true /* bottom-right bubble */)) {
              if (!displayString("Select colors!", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+1.35*x_delta, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+Math.floor(nbColors/2)-0.5, +nb_possible_codes_width+optimal_width+tick_width-2.70*x_delta,
                                 darkGray, backgroundColor_2, ctx, true, 1, true, 0, false, true, true /* bottom-right bubble */)) {
                if (!displayString("Select colors!", x_delta*0.90, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+Math.floor(nbColors/2)-0.5, attempt_nb_width+(90*(nbColumns+1))/100-2.22*x_delta,
                                   darkGray, backgroundColor_2, ctx, true, 2, true, 0, false, true, false /* bottom-left bubble */)) {
                  displayString("Select me!", x_delta*0.80, nbMaxAttemptsToDisplay+transition_height+scode_height+transition_height+Math.floor(nbColors/2)-0.5, attempt_nb_width+(90*(nbColumns+1))/100-2.22*x_delta,
                                darkGray, backgroundColor_2, ctx, true, 2, true, 0, false, true, false /* bottom-left bubble */);
                }
              }
            }
          }
        }
        catch (err_help) {}

      }

      else { // showPossibleCodesMode is true

        // Display text related to possible codes
        // **************************************

        let nbOfCodes = nbOfPossibleCodes[currentPossibleCodeShown-1];
        let nbOfCodesListed;
        let code_list_offset;
        if ((!showPossibleCodesOffsetMode) || (nbOfCodes <= nbPossibleCodesShown)) { // (first half display)
          nbOfCodesListed = Math.min(nbOfCodes,nbPossibleCodesShown);
          code_list_offset = 0;
        }
        else { // (second half display)
          nbOfCodesListed = Math.min(nbOfCodes-nbPossibleCodesShown,nbPossibleCodesShown);
          code_list_offset = nbPossibleCodesShown;
        }
        if ( (currentPossibleCodeShown >= 1) && (currentPossibleCodeShown <= nbMaxAttempts) && (nbOfCodes>=1) ) {

          ctx.font = basic_bold_font;
          if (nbOfCodes == 1) {
            res = displayString("1 possible code ", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                darkGray, backgroundColor_2, ctx, true, 0, true, 0);
            if (!res) {
              res = displayString("1\u2009code ", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                  darkGray, backgroundColor_2, ctx, true, 0, true, 0);
              if (!res) {
                res = displayString("1", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                    darkGray, backgroundColor_2, ctx, true, 0, true, 0);
              }
            }
          }
          else {
            res = displayString(nbOfCodes + " possible codes ", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                darkGray, backgroundColor_2, ctx, true, 0, true, 0);
            if (!res) {
              res = displayString(nbOfCodes + "\u2009codes ", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                  darkGray, backgroundColor_2, ctx, true, 0, true, 0);
              if (!res) {
                res = displayString(String(nbOfCodes), 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1, attempt_nb_width+(90*(nbColumns+1))/100,
                                    darkGray, backgroundColor_2, ctx, true, 0, true, 0);
              }
            }
          }
          let currentPossibleCodeShownStr;
          switch (currentPossibleCodeShown) {
            case 1:
              currentPossibleCodeShownStr = "1st";
              break;
            case 2:
              currentPossibleCodeShownStr = "2nd";
              break;
            case 3:
              currentPossibleCodeShownStr = "3rd";
              break;
            default:
              currentPossibleCodeShownStr = currentPossibleCodeShown + "th";
          }
          if (res) {
            displayString("at " + currentPossibleCodeShownStr + " attempt  ", 0, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-2, attempt_nb_width+(90*(nbColumns+1))/100,
                          darkGray, backgroundColor_2, ctx, true, 0, true, 0);
            if (nbOfCodesListed < nbOfCodes) {
              ctx.font = basic_bold_font;
              let offset_str;
              if (!showPossibleCodesOffsetMode) {
                offset_str = "\u25bc";
              }
              else {
                offset_str = "\u25b2";
              }
              if (nbOfCodes-nbOfCodesListed == 1) {
                if (!displayString("+ 1 other code\u2009" + offset_str + " ", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                   darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                  if (!displayString("+\u2009" + "1" + "\u2009code\u2009" + offset_str + "\u2009", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                     darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                    if (!displayString("+\u2009" + "1" + "\u2009" + offset_str + "\u2009", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                       darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                      displayString("+\u2009" + "1", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                    darkGray, backgroundColor_2, ctx, true, 0, true, 0);
                    }
                  }
                }
              }
              else {
                if(!displayString("+ " + (nbOfCodes-nbOfCodesListed) + " other codes\u2009" + offset_str + " ", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                  darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                  if (!displayString("+\u2009" + (nbOfCodes-nbOfCodesListed) + "\u2009codes\u2009" + offset_str + "\u2009", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                     darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                    if (!displayString("+\u2009" + (nbOfCodes-nbOfCodesListed) + "\u2009" + offset_str + "\u2009", 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                       darkGray, backgroundColor_2, ctx, true, 0, true, 0)) {
                      displayString("+\u2009" + (nbOfCodes-nbOfCodesListed), 0, nbMaxAttemptsToDisplay+transition_height, attempt_nb_width+(90*(nbColumns+1))/100,
                                    darkGray, backgroundColor_2, ctx, true, 0, true, 0);
                    }
                  }
                }
              }

              // Display hint to see other codes
              if ((!atLeastOneAttemptSelection) && (!CompressedDisplayMode) && (transition_height >= 1)) {
                ctx.font = small_bold_font;
                displayString("\u2009Click to select!\u2009", 0, nbMaxAttemptsToDisplay, attempt_nb_width+(90*(nbColumns+1))/100,
                              "#4B0082" /* purple */, backgroundColor_2, ctx, true, 0, true, 0);
              }
            }
          } // (res)

        }
        else {
          displayGUIError("invalid currentPossibleCodeShown: " + currentPossibleCodeShown, new Error().stack);
        }

        // Draw always present and impossible colors
        // *****************************************

        ctx.font = basic_bold_font;
        for (let col = 0; col < nbColumns; col++) {
          if (simpleCodeHandler.getColor(colorsFoundCodes[currentPossibleCodeShown-1], col+1) != emptyColor) {
            displayString(tickChar, attempt_nb_width+(90*(nbColumns+1))/100+col*2, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown, 2,
                          greenColor, backgroundColor_2, ctx, true, 0, true, 1, true /* (ignoreRanges) */);
          }
        }

        ctx.font = basic_bold_font;
        let colors_cnt = 0;
        for (let color = 1; color <= nbColors; color++) {
          if (minNbColorsTables[currentPossibleCodeShown-1][color] > 0) { // always present color
            for (let i = 0; i < minNbColorsTables[currentPossibleCodeShown-1][color]; i++) {
              displayColor(color, attempt_nb_width+(90*(nbColumns+1))/100-3, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-4-colors_cnt, ctx, false, true);
              colors_cnt++;
            }
          }
        }
        if (colors_cnt > 0) {
          colors_cnt++;
        }
        for (let color = 1; color <= nbColors; color++) {
          if (maxNbColorsTables[currentPossibleCodeShown-1][color] == 0) { // impossible color
            displayColor(color, attempt_nb_width+(90*(nbColumns+1))/100-3, nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-4-colors_cnt, ctx, false, false);
            colors_cnt++;
          }
        }

        // Draw possible codes & their stats
        // *********************************

        ctx.fillStyle = darkGray;
        for (let codeidx = 0; codeidx <= nbPossibleCodesShown; codeidx++) {
          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+codeidx));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+codeidx));
          drawLine(ctx, x_0, y_0, x_1+1, y_1);
        }

        for (let col = 0; col <= nbColumns; col++) {
          x_0 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
          y_0 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height));
          x_1 = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100+col*2));
          y_1 = get_y_pixel(y_min+y_step*(nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown));
          drawLine(ctx, x_0, y_0, x_1, y_1);
        }

        let best_global_perf = global_best_performances[currentPossibleCodeShown-1];
        let valid_best_global_perf = ((best_global_perf != PerformanceUNKNOWN) && (best_global_perf > 0.01)); // valid global_best_performances value
        for (let codeidx = 0; codeidx < nbOfCodesListed; codeidx++) {

          // Display code
          let code = possibleCodesLists[currentPossibleCodeShown-1][codeidx+code_list_offset];
          let y_cell = nbMaxAttemptsToDisplay+transition_height+nbPossibleCodesShown-1-codeidx;
          ctx.font = basic_bold_font;
          displayCode(code, y_cell, ctx);

          // Display performances
          let global_perf = PerformanceUNKNOWN;
          let relative_perf = PerformanceUNKNOWN;
          if ( valid_best_global_perf
               && (globalPerformancesList[currentPossibleCodeShown-1][codeidx+code_list_offset] != PerformanceUNKNOWN) && (globalPerformancesList[currentPossibleCodeShown-1][codeidx+code_list_offset] > 0.01) ) { // valid globalPerformancesList value
            global_perf = globalPerformancesList[currentPossibleCodeShown-1][codeidx+code_list_offset];
            relative_perf = best_global_perf - global_perf;
          }
          ctx.font = stats_font;
          let backgroundColor = backgroundColor_2;
          displayPerf(relative_perf, y_cell, backgroundColor, global_perf, true, valid_best_global_perf && (currentPossibleCodeShown <= 1), best_global_perf, ctx, (code == codesPlayed[currentPossibleCodeShown-1]));

        }

      }

      // Enable or disable GUI controls
      // ******************************

      if (gameWon && !allPerformancesFilled()) {
        document.getElementById("newGameButton").disabled = true;
        document.getElementById("newGameButton").className  = "button disabled";
        if (CompressedDisplayMode) {
          document.getElementById("newGameButton").value = "\u231b"; /* hourglass */
        }
        else {
          document.getElementById("newGameButton").value = "PLEASE WAIT \u231b"; /* hourglass */
        }
      }
      else {
        document.getElementById("newGameButton").disabled = false;
        document.getElementById("newGameButton").className  = "button";
        if (CompressedDisplayMode) {
          document.getElementById("newGameButton").value = "N";
        }
        else {
          document.getElementById("newGameButton").value = newGameButtonIniName;
        }
      }

      if (currentAttemptNumber > 1) {
        document.getElementById("columnslabel_3b").disabled = true;
        document.getElementById("columnslabel_4b").disabled = true;
        document.getElementById("columnslabel_5b").disabled = true;
        document.getElementById("columnslabel_6b").disabled = true;
        document.getElementById("columnslabel_7b").disabled = true;
        document.getElementById("columnslabel_3").className = "radio disabled";
        document.getElementById("columnslabel_4").className = "radio disabled";
        document.getElementById("columnslabel_5").className = "radio disabled";
        document.getElementById("columnslabel_6").className = "radio disabled";
        document.getElementById("columnslabel_7").className = "radio disabled";
      }
      else {
        document.getElementById("columnslabel_3b").disabled = false;
        document.getElementById("columnslabel_4b").disabled = false;
        document.getElementById("columnslabel_5b").disabled = false;
        document.getElementById("columnslabel_6b").disabled = false;
        document.getElementById("columnslabel_7b").disabled = false;
        document.getElementById("columnslabel_3").className = "radio";
        document.getElementById("columnslabel_4").className = "radio";
        document.getElementById("columnslabel_5").className = "radio";
        document.getElementById("columnslabel_6").className = "radio";
        document.getElementById("columnslabel_7").className = "radio";
      }

      document.getElementById("playRandomCodeButton").disabled = (!gameOnGoing() || (currentAttemptNumber >= nbMaxAttempts - ((nbColumns >= 6) ? 2 : 1)));
      if (document.getElementById("playRandomCodeButton").disabled) {
        document.getElementById("playRandomCodeButton").className = "button disabled";
      }
      else {
        document.getElementById("playRandomCodeButton").className = "button";
      }

      document.getElementById("revealSecretColorButton").disabled = !(gameOnGoing() && (nbColumns-simpleCodeHandler.nbEmptyColors(sCodeRevealed)+1) < (nbColumns+1)/2);
      if ( gameOnGoing() && (currentAttemptNumber > 1) // (Note: full condition duplicated at several places in this file)
           && !(document.getElementById("revealSecretColorButton").disabled)
           && (sCodeRevealed == 0)
           && ( (((new Date()).getTime() - startTime)/1000 > ((nbColumns <= 5) ? 720 /* 12 min */ : 1500 /* 25 min */))  // See also (*)
                || (currentAttemptNumber == nbMaxAttempts-1) /* (last but one attempt) */
                || at_least_one_useless_code_played ) ) { /* (number of useless attempts) */
        document.getElementById("revealSecretColorButton").className = (androidMode ? "button fast_blinking" : "button blinking");
      }
      else if (document.getElementById("revealSecretColorButton").disabled) {
        document.getElementById("revealSecretColorButton").className = "button disabled";
      }
      else {
        document.getElementById("revealSecretColorButton").className = "button";
      }
      document.getElementById("showPossibleCodesButton").disabled = !((!gameOnGoing()) && allPossibleCodesFilled());
      if (document.getElementById("showPossibleCodesButton").disabled) {
        document.getElementById("showPossibleCodesButton").className = "button disabled";
      }
      else {
        document.getElementById("showPossibleCodesButton").className = (mobileMode ? "button" /* ("button fast_blinking" generates display issues) */ : "button blinking");
      }

      if (CompressedDisplayMode) {
        if (showPossibleCodesMode) {
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonBackToGameCompressedName;
        }
        else {
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonCompressedName;
        }
      }
      else {
        if (showPossibleCodesMode) {
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonBackToGameName;
        }
        else {
          document.getElementById("showPossibleCodesButton").value = showPossibleCodesButtonIniName;
        }
      }

      checkArraySizes();

      main_graph_update_needed = false;

    }

    // ******************
    // Partial repainting
    // ******************

    // Display current code
    if (gameOnGoing()) { // playing phase
      ctx.font = basic_bold_font;
      displayCode(currentCode, currentAttemptNumber-1, ctx);

      // Useful to trigger button blinking due to time only
      if ( gameOnGoing() && (currentAttemptNumber > 1) // (Note: full condition duplicated at several places in this file)
           && !(document.getElementById("revealSecretColorButton").disabled)
           && (sCodeRevealed == 0)
           && ( (((new Date()).getTime() - startTime)/1000 > ((nbColumns <= 5) ? 720 /* 12 min */ : 1500 /* 25 min */))  // See also (*)
                || (currentAttemptNumber == nbMaxAttempts-1) /* (last but one attempt) */ ) ) {
          if (document.getElementById("revealSecretColorButton").className.indexOf('blinking') == -1) {
            document.getElementById("revealSecretColorButton").className = document.getElementById("revealSecretColorButton").className + (androidMode ? " fast_blinking" : " blinking");
          }
      }
    }

    document.getElementById("resetCurrentCodeButton").disabled  = !(gameOnGoing() && (currentCode != sCodeRevealed));
    if (document.getElementById("resetCurrentCodeButton").disabled) {
      document.getElementById("resetCurrentCodeButton").className = "button disabled";
    }
    else {
      document.getElementById("resetCurrentCodeButton").className = "button";
    }

    if ( last_attempt_event
         && (nbGamesPlayedAndWon == 0)
         && (gameOnGoing())
         && !(document.getElementById("revealSecretColorButton").disabled)
         && (sCodeRevealed == 0) ) {
      if (!CompressedDisplayMode) {
        alert("Need some help?\nClick on the \"" + document.getElementById("revealSecretColorButton").value + "\" button!");
      }
      else {
        alert("Need some help?\nClick on the \"" + document.getElementById("revealSecretColorButton").value + "\" button to reveal a secret color!");
      }
    }

  }
  catch (err) {
    draw_exception = true;
    displayGUIError("draw error: " + err, err.stack);
  }

}

function displayString(str, x_cell, y_cell, x_cell_width,
                       foregroundColor, backgroundColor,
                       ctx,
                       displayColorMode = true, // true = nominal display, false = strikethrough mode
                       justify = 0 /* 0 = centered, 1 = left, 2 = right */,
                       displayIfEnoughRoom = false,
                       halfLine = 0 /* 0 = full line, 1 = bottom half line, 2 = top half line */,
                       ignoreRanges = false,
                       drawInBubble = false, bottomRightBubble = true) {

  let x_0 = get_x_pixel(x_min+x_step*x_cell);
  let x_0_for_drawBubble;
  let x_0_next = get_x_pixel(x_min+x_step*(x_cell+x_cell_width));
  let y_0;
  let y_0_next;
  let y_offset = 1; // (works with Chrome & Firefox)
  if (edgeMode) {
    y_offset = 0;
  }
  /* previous offsets:
  let y_offset = 0; // (works with Chrome)
  if (firefoxMode) {
    y_offset = 1; // (works with Firefox)
  } */

  let str_width = ctx.measureText(str).width;
  let str_height = parseInt(ctx.font.match(/\d+/)[0]); // only get numbers => this is the font height

  if (0 == halfLine) {
    y_0 = get_y_pixel(y_min+y_step*y_cell);
    y_0_next = get_y_pixel(y_min+y_step*(y_cell+1), ignoreRanges);
  }
  else if (1 == halfLine) { // bottom half line
    y_0 = get_y_pixel(y_min+y_step*y_cell) - Math.round(str_height/4);
    y_0_next = y_0 - str_height;
  }
  else { // top half line
    y_0 = get_y_pixel(y_min+y_step*y_cell) - str_height - Math.round(str_height/4) - 2;
    y_0_next = y_0 - str_height;
  }

  if ( (!displayIfEnoughRoom) || (x_0_next - x_0 - str_width >= 0) ) {
    if (!ignoreRanges) {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(x_0 + 1, y_0_next + 1, x_0_next - x_0 - 1, y_0 - y_0_next - 1);
    }
    if (justify == 0) { // centered
      if (!displayColorMode) { // To simplify, strikethrough mode is only handled in the centered case
        let redC = parseInt(backgroundColor.substring(1,3), 16);
        let greenC = parseInt(backgroundColor.substring(3,5), 16);
        let blueC = parseInt(backgroundColor.substring(5,7), 16);
        if (Math.max(Math.max(redC, greenC), blueC) < 50) {
          ctx.strokeStyle = "white";
        }
        else {
          ctx.strokeStyle = "black";
        }
        ctx.beginPath();
        let lineWidthIni = ctx.lineWidth;
        ctx.lineWidth = 2;
        ctx.moveTo(x_0 + 2, y_0 - 2);
        ctx.lineTo(x_0_next - 2, y_0_next + 2);
        ctx.moveTo(x_0 + 2, y_0_next + 2);
        ctx.lineTo(x_0_next - 2, y_0 - 2);
        ctx.stroke();  // Draw it
        ctx.lineWidth = lineWidthIni;

        ctx.fillStyle = backgroundColor;
        let half_hidding_rect_width = Math.min(16*(x_0_next - x_0)/100, str_width/2+2);
        ctx.fillRect(x_0 + (x_0_next - x_0)/2 - half_hidding_rect_width, y_0_next + 1, 2*half_hidding_rect_width+2, y_0 - y_0_next - 1);
      }
      ctx.fillStyle = foregroundColor;
      ctx.textAlign = "center"; // horizontal alignment
      ctx.textBaseline = "middle"; // vertical alignment
      ctx.fillText(str, (x_0 + x_0_next)/2, (y_0 + y_0_next)/2 + y_offset);
      x_0_for_drawBubble = Math.max((x_0 + x_0_next)/2 - str_width/2, 0);
      // subPixelText(ctx, str, (x_0 + x_0_next)/2, y_0, 25);
    }
    else if (justify == 2) { // right
      ctx.fillStyle = foregroundColor;
      ctx.textAlign = "end"; // horizontal alignment
      ctx.textBaseline = "middle"; // vertical alignment
      ctx.fillText(str, x_0_next, (y_0 + y_0_next)/2 + y_offset);
      x_0_for_drawBubble = Math.max(x_0_next - str_width, 0);
    }
    else { // left
      ctx.fillStyle = foregroundColor;
      ctx.textAlign = "start"; // horizontal alignment
      ctx.textBaseline = "middle"; // vertical alignment
      ctx.fillText(str, x_0, (y_0 + y_0_next)/2 + y_offset);
      x_0_for_drawBubble = x_0;
    }

    if (drawInBubble) {
      let delta_x = 10;
      let delta_y = 3;
      drawBubble(ctx, x_0_for_drawBubble - delta_x, y_0_next - delta_y, str_width + 2*delta_x, y_0 - y_0_next + 2*delta_y, Math.floor(str_height/2), foregroundColor, 1, bottomRightBubble);
    }

    return true;
  }
  return false;

}

function display2Strings(str1, str2, x_cell, y_cell, x_cell_width,
                        foregroundColor, backgroundColor, ctx,
                        justify /* 0 = centered, 1 = left, 2 = right */, displayIfEnoughRoom) {
  let res;
  if (ctx.measureText(str1).width <= ctx.measureText(str2).width) {
    res = displayString(str2, x_cell, y_cell, x_cell_width,
                        foregroundColor, backgroundColor, ctx, true, justify, displayIfEnoughRoom, 1);
    if (res) {
      displayString(str1, x_cell, y_cell, x_cell_width,
                    foregroundColor, backgroundColor, ctx, true, justify, displayIfEnoughRoom, 2);
    }
  }
  else {
    res = displayString(str1, x_cell, y_cell, x_cell_width,
                        foregroundColor, backgroundColor, ctx, true, justify, displayIfEnoughRoom, 2);
    if (res) {
      displayString(str2, x_cell, y_cell, x_cell_width,
                      foregroundColor, backgroundColor, ctx, true, justify, displayIfEnoughRoom, 1);
    }
  }
  return res;
}

function displayColor(color, x_cell, y_cell, ctx, secretCodeCase, displayColorMode) {
  if (color != emptyColor) {
    if (color < 10) {
      displayString(color, x_cell, y_cell, 2,
                    foregroundColorTable[color-1], backgroundColorTable[color-1], ctx, displayColorMode, 0, false, 0);
    }
    else {
      let res = displayString(color, x_cell, y_cell, 2,
                              foregroundColorTable[color-1], backgroundColorTable[color-1], ctx, displayColorMode, 0, true, 0);
      if (!res) {
        displayString(color-10, x_cell, y_cell, 2,
                      foregroundColorTable[color-1], backgroundColorTable[color-1], ctx, displayColorMode, 0, false, 0);
      }
    }
  }
  else {
    if (secretCodeCase) {
      let bckg_color = darkGray;
      if (currentAttemptNumber <= 1) { // a little fun
        if (color_cnt >= nbColors) {
          color_cnt = 0;
        }
        bckg_color = backgroundColorTable[color_cnt];
        color_cnt++;
        if (color_cnt == 5) {
          color_cnt = 7;
        }
      }
      displayString("?", x_cell, y_cell, 2,
                    bckg_color, backgroundColor_2, ctx, displayColorMode, 0, false, 0);
    }
    else {
      displayString("", x_cell, y_cell, 2,
                    darkGray, backgroundColor_3, ctx, displayColorMode, 0, false, 0);
    }
  }
}

function displayCode(code, y_cell, ctx, secretCodeCase = false) {
  for (let col = 0; col < nbColumns; col++) {
    let color = simpleCodeHandler.getColor(code, col+1);
    displayColor(color, attempt_nb_width+(90*(nbColumns+1))/100+col*2, y_cell, ctx, secretCodeCase, true);
  }
}


function displayMark(mark, y_cell, backgroundColor, ctx) {

  let x_0 = get_x_pixel(x_min+x_step*attempt_nb_width);
  let x_0_next = get_x_pixel(x_min+x_step*(attempt_nb_width+(90*(nbColumns+1))/100));
  let circle_width = (2.0*(x_0_next - x_0 - 2)) / (3.0 * nbColumns + 1);
  let circle_width_applied = Math.floor(circle_width);
  if ((circle_width_applied % 2) == 1) circle_width_applied++; // makes marks larger and even values avoid Java displaying issues when drawOval is run
  let y_0 = get_y_pixel(y_min+y_step*y_cell);
  let y_0_next = get_y_pixel(y_min+y_step*(y_cell+1));
  let constant_y_cell_delta = get_y_pixel(y_min) - get_y_pixel(y_min+y_step);
  while (circle_width_applied > Math.floor((55*constant_y_cell_delta)/100)) {
    circle_width_applied = circle_width_applied - 2; // (keeps even)
  }
  if (circle_width_applied < 2) {
    circle_width_applied = 2;
  }

  // Space between marks whose circle's diameter is circle_width_applied
  let space_btw_marks = ((x_0_next - x_0 - 2.0) - (nbColumns*(circle_width_applied+1.0))) / (nbColumns+1.0);

  ctx.fillStyle = backgroundColor;
  ctx.fillRect(x_0 + 1, y_0_next + 1, x_0_next - x_0 - 1, y_0 - y_0_next - 1);

  ctx.fillStyle = "black";

  let x_0_pos;
  let left_space = 1 + Math.floor(space_btw_marks);
  let right_space = Math.floor(Math.max(0, (x_0_next - x_0) - (1 + Math.floor(space_btw_marks) + (nbColumns-1.0)*(circle_width_applied+1.0+Math.floor(space_btw_marks)) + circle_width_applied)));
  let x_0_pos_offset = Math.max(0, Math.floor((left_space + right_space)/2) - left_space);

  let circleBorderWidth = 1.25;
  let whiteBckg = "#FCFCFC";
  let radius = Math.floor(circle_width_applied/2);
  if (radius <= 3) { // radius
    circleBorderWidth = 0.6;
    whiteBckg = "#FFFFFF";
  }

  for (let i = 0; i < mark.nbBlacks; i++) {
    x_0_pos = Math.round(x_0 + 1.0 + Math.floor(space_btw_marks) + i*(circle_width_applied+1.0+Math.floor(space_btw_marks))); // Math.floor(space_btw_marks) instead of space_btw_marks to have constant spacing between all circles


    ctx.beginPath();
    ctx.arc(x_0_pos + x_0_pos_offset + radius, // center x
            Math.floor((y_0 + y_0_next + 1)/2), // center y
            radius, // radius
            0, 2 * Math.PI, false); // starting and ending angles + clockwise
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.lineWidth = circleBorderWidth;
    ctx.strokeStyle = "black";
    ctx.stroke();

  }

  for (let i = mark.nbBlacks; i < mark.nbBlacks + mark.nbWhites; i++) {
    x_0_pos = Math.round(x_0 + 1.0 + Math.floor(space_btw_marks) + i*(circle_width_applied+1.0+Math.floor(space_btw_marks))); // (int)space_btw_marks instead of space_btw_marks to have constant spacing between all circles

    ctx.beginPath();
    ctx.arc(x_0_pos + x_0_pos_offset + radius, // center x
            Math.floor((y_0 + y_0_next + 1)/2), // center y
            radius, // radius
            0, 2 * Math.PI, false); // starting and ending angles + clockwise
    ctx.fillStyle = whiteBckg;
    ctx.fill();
    ctx.lineWidth = circleBorderWidth;
    ctx.strokeStyle = "black";
    ctx.stroke();

  }

}

function drawBubble(ctx, x, y, w, h, radius, foregroundColor, lineWidth, bottomRightBubble)
{
  let r = x + w;
  let b = y + h;
  if (bottomRightBubble) { // bottom-right bubble
    ctx.beginPath();
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = lineWidth;
    ctx.moveTo(x+radius, y);
    ctx.lineTo(x+radius/2, y-10);
    ctx.lineTo(x+radius*2, y);
    ctx.lineTo(r-radius, y);
    ctx.quadraticCurveTo(r, y, r, y+radius);
    ctx.lineTo(r, y+h-radius);
    ctx.quadraticCurveTo(r, b, r-radius, b);
    ctx.lineTo(x+radius, b);
    ctx.quadraticCurveTo(x, b, x, b-radius);
    ctx.lineTo(x, y+radius);
    ctx.quadraticCurveTo(x, y, x+radius, y);
    ctx.stroke();
  }
  else { // bottom-left bubble
    ctx.beginPath();
    ctx.strokeStyle = foregroundColor;
    ctx.lineWidth = lineWidth;
    ctx.moveTo(r-radius*2, y);
    ctx.lineTo(r-radius/2, y-10);
    ctx.lineTo(r-radius, y);
    ctx.quadraticCurveTo(r, y, r, y+radius);
    ctx.lineTo(r, y+h-radius);
    ctx.quadraticCurveTo(r, b, r-radius, b);
    ctx.lineTo(x+radius, b);
    ctx.quadraticCurveTo(x, b, x, b-radius);
    ctx.lineTo(x, y+radius);
    ctx.quadraticCurveTo(x, y, x+radius, y);
    ctx.lineTo(r-radius*2, y);
    ctx.stroke();
  }
}

function displayPerf(perf, y_cell, backgroundColor, isPossible, starDisplayIfOptimal, globalPerfDisplayIfOptimal, optimalGlobalPerf, ctx, ideaFlag = false) {

  let performance = Math.round(perf * 100.0) / 100.0; // 0.01 precision
  let optimalglobalperformance = Math.round(optimalGlobalPerf * 100.0) / 100.0; // 0.01 precision

  let x_cell;
  let cell_width;
  let extra_x_space = 0;
  if (optimal_width > 0) {
    x_cell = attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width;
    cell_width = optimal_width;
    extra_x_space = 0.75*tick_width;
  }
  else { /* (nb of possible codes <-> perf switch) */
    x_cell = attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2;
    cell_width = nb_possible_codes_width;
  }

  let isPossible_str;
  if (tick_width > 0) {
    isPossible_str = "";
  }
  else {
    if (0 == isPossible) { // code is possible
      isPossible_str = "";
    }
    else { // code is not possible
      isPossible_str = "\u2009(" + isPossible + ")";
    }
  }

  if (performance == PerformanceUNKNOWN) {
    displayString("\u2234", x_cell, y_cell, cell_width,
                  lightGray, backgroundColor, ctx);
  }
  else if (performance != PerformanceNA) {
    if (performance <= -1.00) { // useless code
      let color = redColor;
      if (perf != -1.00) { // "-1.00" is set explicitly for "classical" useless codes, thus "!=" being valid here (simplified test)
        color = "#4B0082"; // purple to highlight those very particular cases
      }
      if (!displayString("  useless" + isPossible_str + "  ", x_cell, y_cell, cell_width,
                         color, backgroundColor, ctx, true, 0, true, 0)) {
        if (!displayString(" " + performance.toFixed(2).replaceAll(",",".") + isPossible_str + " ", x_cell, y_cell, cell_width,
                           color, backgroundColor, ctx, true, 0, true, 0)) {
          if (!displayString(performance.toFixed(1).replaceAll(",",".") + isPossible_str, x_cell, y_cell, cell_width,
                             color, backgroundColor, ctx, true, 0, true, 0)) {
            if (!displayString("  useless  ", x_cell, y_cell, cell_width,
                               color, backgroundColor, ctx, true, 0, true, 0)) {
              if (!displayString("\u2009" + performance.toFixed(2).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                                 color, backgroundColor, ctx, true, 0, true, 0)) {
                displayString(performance.toFixed(1).replaceAll(",","."), x_cell, y_cell, cell_width,
                              color, backgroundColor, ctx);
              }
            }
          }
        }
      }
    }
    else if (performance <= PerformanceVERYLOW) {
      if (!displayString("\u2009" + performance.toFixed(2).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                         redColor, backgroundColor, ctx, true, 0, true, 0)) {
        displayString(performance.toFixed(1).replaceAll(",","."), x_cell, y_cell, cell_width,
                      redColor, backgroundColor, ctx);
      }
    }
    else if (performance <= PerformanceLOW) {
      if (!displayString("\u2009" + performance.toFixed(2).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                         orangeColor, backgroundColor, ctx, true, 0, true, 0)) {
        displayString(performance.toFixed(1).replaceAll(",","."), x_cell, y_cell, cell_width,
                      orangeColor, backgroundColor, ctx);
      }
    }
    else if (performance < 0.00) {
      if (!displayString("\u2009" + performance.toFixed(2).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                         lightGray, backgroundColor, ctx, true, 0, true, 0)) {
        displayString(performance.toFixed(1).replaceAll(",","."), x_cell, y_cell, cell_width,
                      lightGray, backgroundColor, ctx);
      }
    }
    else if (performance == 0.00) { // optimal code (perf with +/-0.005 precision is considered for optimality)
      let starStr = "";
      if (starDisplayIfOptimal) {
        starStr = "\u2B50\u2009"; // star
      }
      if ( (!globalPerfDisplayIfOptimal)
           || (!displayString(starStr + "optimal/" + optimalglobalperformance.toFixed(2).replaceAll(",","."), x_cell-extra_x_space, y_cell, cell_width+2*extra_x_space,
                              lightGray, backgroundColor, ctx, true, 0, true, 0)) ) {
        if (!displayString(" " + starStr + "optimal ", x_cell, y_cell, cell_width,
                           lightGray, backgroundColor, ctx, true, 0, true, 0)) {
          if (!displayString("\u2009" + starStr + performance.toFixed(2).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                             lightGray, backgroundColor, ctx, true, 0, true, 0)) {
            if (!displayString("\u2009" + starStr + performance.toFixed(1).replaceAll(",",".") + "\u2009", x_cell, y_cell, cell_width,
                               lightGray, backgroundColor, ctx, true, 0, true, 0)) {
              displayString(starStr + performance.toFixed(0).replaceAll(",",".") /* star0 */, x_cell, y_cell, cell_width,
                            lightGray, backgroundColor, ctx);
            }
          }
        }
      }
    }
    else { // > 0.00: an illogical code can be better than the optimal logical code(s)
      if (performance <= 0.00) {
        throw new Error("internal error in displayPerf: " + performance);
      }
      if (!displayString("\u2009" + "+" + performance.toFixed(2).replaceAll(",",".") + "!" + "\u2009", x_cell, y_cell, cell_width,
                         greenColor, backgroundColor, ctx, true, 0, true, 0)) {
        displayString("+" + performance.toFixed(1).replaceAll(",",".") + "!", x_cell, y_cell, cell_width,
                      greenColor, backgroundColor, ctx);
      }
    }
  }
  else {
    // Nothing is displayed in case of PerformanceNA (but the background is updated if needed)
    displayString("NA", x_cell, y_cell, cell_width,
                  lightGray, backgroundColor, ctx);
  }

  if (ideaFlag && (tick_width > 0) && (!globalPerfDisplayIfOptimal)) {
    displayString("\uD83D\uDCA1", attempt_nb_width+(90*(nbColumns+1))/100+nbColumns*2+nb_possible_codes_width+optimal_width, y_cell, tick_width, // idea/bulb
                  darkGray, backgroundColor, ctx);
  }

}

function fullObjToString(obj) {
  try {
    let str = '{';
    for (let p in obj) {
      // if (obj.hasOwnProperty(p)) { // Note: this condition can be commented for (plenty of) more fields
        str += p + ':' + obj[p] + '\n';
      // }
    }
    str = str.trim().replaceAll("\n", "|") + "}";
    return str;
  }
  catch (exc) {
    return "?";
  }
}

// *************************************************************************
// Correct blurry text display which is inhertent to default canvas
// Code shared at https://jsfiddle.net/Ghislain999/2dw0bw6h/
// *************************************************************************

let subPixelText = function(ctx,text,x,y,fontHeight){
  let width = ctx.measureText(text).width + 12; // add some extra pixels
  let hOffset = Math.floor(fontHeight);
  let c = document.createElement("canvas");
  c.width  = width * 3; // scaling by 3
  c.height = fontHeight;
  c.ctx    = c.getContext("2d");
  c.ctx.font = ctx.font;
  c.ctx.globalAlpha = ctx.globalAlpha;
  c.ctx.fillStyle = ctx.fillStyle;
  c.ctx.fontAlign = "left";
  c.ctx.setTransform(3,0,0,1,0,0); // scaling by 3
  c.ctx.imageSmoothingEnabled = false;
  // c.ctx.mozImageSmoothingEnabled = false; // (obsolete)
  c.ctx.webkitImageSmoothingEnabled = false;
  c.ctx.msImageSmoothingEnabled = false;
  c.ctx.oImageSmoothingEnabled = false;
  // copy existing pixels to new canvas
  c.ctx.drawImage(ctx.canvas,x,y-hOffset,width,fontHeight,0,0,width,fontHeight);
  c.ctx.fillText(text,0,hOffset-3 /* (hardcoded to -3 for letters like 'p', 'g', ..., could be improved) */);    // draw the text 3 time the width
  // convert to sub pixels
  c.ctx.putImageData(subPixelBitmap(c.ctx.getImageData(0,0,width*3,fontHeight)), 0, 0);
  ctx.drawImage(c,0,0,width-1,fontHeight,x,y-hOffset,width-1,fontHeight);
}

let subPixelBitmap = function(imgData){
  let spR,spG,spB; // sub pixels
  let id,id1; // pixel indexes
  let w = imgData.width;
  let h = imgData.height;
  let d = imgData.data;
  let x,y;
  let ww = w*4;
  let ww4 = ww+4;
  for(y = 0; y < h; y+=1){ // (go through all y pixels)
    for(x = 0; x < w-2; x+=3){ // (go through all groups of 3 x pixels)
      let id = y*ww+x*4; // (4 consecutive values: id->red, id+1->green, id+2->blue, id+3->alpha)
      let output_id = y*ww+Math.floor(x/3)*4;
      spR = Math.round((d[id + 0] + d[id + 4] + d[id + 8])/3);
      spG = Math.round((d[id + 1] + d[id + 5] + d[id + 9])/3);
      spB = Math.round((d[id + 2] + d[id + 6] + d[id + 10])/3);
      // console.log(d[id+0], d[id+1], d[id+2] + '|' + d[id+5], d[id+6], d[id+7] + '|' + d[id+9], d[id+10], d[id+11]);
      d[output_id] = spR;
      d[output_id+1] = spG;
      d[output_id+2] = spB;
      d[output_id+3] = 255; // alpha is always set to 255
    }
  }
  return imgData;
}

let subPixelBitmap2D = function(imgData){
  let spR,spG,spB; // sub pixels
  let id,id1; // pixel indexes
  let w = imgData.width;
  let h = imgData.height;
  let d = imgData.data;
  let x,y;
  let ww = w*4;
  for(y = 0; y < h-2; y+=3){ // (go through all y pixels)
    for(x = 0; x < w-2; x+=3){ // (go through all groups of 3 x pixels)
      let id = y*ww+x*4; // (4 consecutive values: id->red, id+1->green, id+2->blue, id+3->alpha)
      let output_id = Math.floor(y/3)*ww+Math.floor(x/3)*4;
      spR = Math.round((d[id + 0] + d[id + 4] + d[id + 8] + d[id + ww + 0] + d[id + ww + 4] + d[id + ww + 8] + d[id + 2*ww + 0] + d[id + 2*ww + 4] + d[id + 2*ww + 8])/9);
      spG = Math.round((d[id + 1] + d[id + 5] + d[id + 9] + d[id + ww + 1] + d[id + ww + 5] + d[id + ww + 9] + d[id + 2*ww + 1] + d[id + 2*ww + 5] + d[id + 2*ww + 9])/9);
      spB = Math.round((d[id + 2] + d[id + 6] + d[id + 10] + d[id + ww + 2] + d[id + ww + 6] + d[id + ww + 10] + d[id + 2*ww + 2] + d[id + 2*ww + 6] + d[id + 2*ww + 10])/9);
      d[output_id] = spR;
      d[output_id+1] = spG;
      d[output_id+2] = spB;
      d[output_id+3] = 255; // alpha is always set to 255
    }
  }
  return imgData;
}

let subPixelText2D = function(ctx,text,x,y,fontHeight){
  let width = ctx.measureText(text).width + 12; // add some extra pixels
  let hOffset = Math.floor(fontHeight);

  let c = document.createElement("canvas");
  c.width  = width * 3; // scaling by 3
  c.height = fontHeight * 3; // scaling by 3
  c.ctx    = c.getContext("2d");
  c.ctx.font = ctx.font;
  c.ctx.globalAlpha = ctx.globalAlpha;
  c.ctx.fillStyle = ctx.fillStyle;
  c.ctx.fontAlign = "left";
  c.ctx.setTransform(3,0,0,3,0,0); // scaling by 3
  c.ctx.imageSmoothingEnabled = false;
  // c.ctx.mozImageSmoothingEnabled = false; // (obsolete)
  c.ctx.webkitImageSmoothingEnabled = false;
  c.ctx.msImageSmoothingEnabled = false;
  c.ctx.oImageSmoothingEnabled = false;
  // copy existing pixels to new canvas
  c.ctx.drawImage(ctx.canvas,x,y-hOffset,width,fontHeight,0,0,width,fontHeight);
  c.ctx.fillText(text,0,hOffset-3 /* (hardcoded to -3 for letters like 'p', 'g', ..., could be improved) */); // draw the text 3 time the width
  // convert to sub pixels
  c.ctx.putImageData(subPixelBitmap2D(c.ctx.getImageData(0,0,width*3,fontHeight*3)), 0, 0);
  ctx.drawImage(c,0,0,width-1,fontHeight,x,y-hOffset,width-1,fontHeight);
}

// *************************************************************************
// Draw graphic
// *************************************************************************

draw_graphic();

let canvas = document.getElementById("my_canvas");
canvas.addEventListener("click", mouseClick, false);
canvas.addEventListener("mousemove", mouseMove, false);

<!DOCTYPE html>
<html>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Super Master Mind</title> <!-- (this title will be overwritten) -->
    <meta name="robots" content="noindex"> <!-- (this page shall be preferably accessed from the main site page) -->
    <meta name="title" content="Super Master Mind">
    <meta name="description" content="Play Super Master Mind / Code breaker online, assisted by a calculator which knows the optimal strategy!">
    <meta name="keywords" content="super master mind, code breaker, game, online, optimal strategy, javascript">

    <!-- Remote console at http://console.re/supermastermind displaying console text (provided all calls to "console.log(xxx)" are replaced by "console.re.log(xxx)")
         and console errors (provided the .js scripts to be debugged are copied/pasted directly into this HTML file between <script>...</script> tags,
         otherwise error details, among which error line numbers, will be lost):
      <script src="https://console.re/connector.js" data-channel="supermastermind" id="consolerescript"></script>
      <script>console.re.log('remote log enabled!');</script>
    -->

    <style>
      /* *** Main styles *** */
      body {
        font-family: 'Verdana';
        margin: 0%;
        padding: 0%;
        /* border: thin solid white; */
        color: #777777;
        font-size: calc(7px + .34vw);
        background: black;
      }
      #my_canvas {
        margin: 0;
        padding: 0;
        border: 2px solid purple; /* (duplicated in SuperMasterMind.js for proper canvas's width & height calculation) */
        background: white;
        width: 98.5%;
        height: 93%;
        border-radius: 1%;
        zoom: 1.0; /* (used by Chrome, ignored by Firefox) */
      }
      /* *** Classes for button styling using CSS *** */
      .button {
        font-family: Verdana;
        background-color: white;
        border: 2px solid purple;
        color: black;
        padding: 7px 8px 7px 8px; /* top right bottom left */
        text-align: center;
        text-decoration: none;
        // font-size: 15px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
        display: block;
        margin-top: 5px;
        margin-bottom: 5px;
        border-radius: 20%;
        -webkit-backface-visibility: visible;
      }
      .button:hover {
        background-color: purple;
        color: white;
      }
      .disabled {
          opacity: 0.4;
          font-weight: normal;
          cursor: not-allowed;
      }
      /* Safari 4.0 - 8.0 */
      @-webkit-keyframes glowing {
        0%   {background-color: white;}
        20%  {background-color: white;}
        33%  {background-color: purple;}
        47%  {background-color: white;}
        60%  {background-color: purple;}
        73%  {background-color: white;}
        87%  {background-color: purple;}
        100% {background-color: white;}
      }
      /* Standard syntax */
      @keyframes glowing {
        0%   {background-color: white;}
        20%  {background-color: white;}
        33%  {background-color: purple;}
        47%  {background-color: white;}
        60%  {background-color: purple;}
        73%  {background-color: white;}
        87%  {background-color: purple;}
        100% {background-color: white;}
      }

      .blinking {
        -webkit-animation-name: glowing; /* Safari 4.0 - 8.0 */
        -webkit-animation-duration: 3.75s; /* Safari 4.0 - 8.0 */
        animation-name: glowing;
        animation-duration: 3.75s;
        -webkit-backface-visibility: hidden;
       }
      .fast_blinking {
        -webkit-animation-name: glowing; /* Safari 4.0 - 8.0 */
        -webkit-animation-duration: 2.75s; /* Safari 4.0 - 8.0 */
        animation-name: glowing;
        animation-duration: 2.75s;
        -webkit-backface-visibility: hidden;
       }

      .radio {
        font-family: Verdana;
        color: black;
        padding: 0 0 0 0; /* top right bottom left */
        text-align: left;
        text-decoration: none;
        // font-size: 14px;
        font-weight: bold;
        width: 100%;
        box-shadow: none;
        /* text not selectable */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .game_loading /* (used during page loading) */
      { position: fixed;
        height: 100%;
        width: 100%;
        top:0;
        left: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index:11111;
        font-size: 2.0vh;
        text-align: center;
        padding-top: 200px;
        color: #fff;
        /* text not selectable */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .page_transition /* (used during page transition) */
      { position: fixed;
        height: 100%;
        width: 100%;
        top:0;
        left: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index:11111;
        font-size: 2.0vh;
        text-align: center;
        padding-top: 200px;
        color: #fff;
        /* text not selectable */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .game_aborted /* (used at game abortion) */
      { position: fixed;
        height: 100%;
        width: 100%;
        top:0;
        left: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index:11111;
        font-size: 2.0vh;
        text-align: center;
        padding-top: 200px;
        color: #fff;
        /* text not selectable */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

    </style>

    <script>
      try {
        eval('"use strict"; class foo {}; let test_let_inst = 1;'); // Interner Explorer does not support classes and old versions of Safari (< 10) will fail on the "let" instruction (error tested on Safari 9.1)
      } catch (err) {
        alert("Your browser cannot run this game.\nThis game can be run in the last versions of Chrome, Firefox, Safari and Edge: update your browser version if necessary.");
      }
      if (typeof(Worker) == "undefined") {
        alert("Your browser cannot run this game because it does not support Web workers: update your browser version if necessary.");
      }
      var nbGamesPlayedAndWon = 0;
      var nbGamesPlayed = 0;
      var nbCodesPlayed = 0;
      var nbColorSelections = 0;
      var firstgamegeoloc = "fa";
    </script>
    <script src='lib/jquery-3.2.1.min.js'></script>
    <script>
      // Animation during page loading:
      // 1) when document is ready
      $(document).ready(function () {
        console.log("(ready)");
        // Less beautiful + can put some problems with Chrome while drawing canvas: $(".mainxxx").hide(); // hide the mainxxx div
      });
      // 2) when all elements of the page are completely loaded
      $(window).on('load', function() {
        console.log("(on load)");
        $(".game_loading").fadeOut("slow"); // game_loading div fades out
        // Less beautiful + can put some problems with Chrome while drawing canvas: $(".mainxxx").fadeIn("slow"); // mainxxx div fades in
      });
      // 2') Defense timeout to allow interactions with the page
      setTimeout("console.log('(on load timeout)');$('.game_loading').fadeOut('slow');", 5000); // game_loading div fades out

      $(window).on('beforeunload', function() { // Ask for a confirmation on window exit when a game is ongoing (***)
        try {
          if (gameOnGoing() && (currentAttemptNumber > 1)) {
            return "Do you really want to abort and lose current game?"; // (message not displayed by all browsers, some browsers will display a generic message instead - code duplicated)
          }
        }
        catch (exc) {
          console.log("error encountered at game abortion: " + exc);
          return; // (no confirmation asked)
        }
      });

      function makeid() {
        let text = "";
        let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        for (let i = 0; i < 5; i++) {
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
      }

      let firstAccess = false;
      if (typeof(Storage) !== 'undefined') {
        if (!localStorage.firstgameaccessdone) {
          localStorage.firstgameaccessdone = "first game access done";
          firstAccess = true;
        }
        if (!localStorage.firstaccessid) {
          let firstaccessid = 'GA - ' + makeid() + ' - ' + new Date();
          localStorage.firstaccessid = firstaccessid;
        }
      }
    </script>

    <link rel='stylesheet' type='text/css' href='lib/tingle-master/dist/tingle.min.css'>
  </head>

  <body onresize="draw_graphic();" onunload="/* See (***) */ console.log('exit...');storeFirstAccess('game', 777, 777 /* (a too low value here will not work) */, 'debug-out');">

    <div class="game_loading">
      <img src="img/loading.gif" style='height:12%;'><br>
      Loading...
    </div>

    <div class="page_transition" style='display:none;'>
    </div>

    <div class="game_aborted" style='display:none;'>
      Current game was lost because you aborted it<br>
      Score: 0<br>
      <img src="img/loading.gif" style='height:12%;'><br>
      Starting a new game...
    </div>

    <!-- HTML controls and canvas -->

    <table id='my_table' style='background:#E3E3E3;width:75%;height:90%;position:absolute;left:12.5%;top:2%;border:5px ridge white;border-radius:1%;margin:0;padding:0;'>
      <tr style='height:100%;'>
        <td style='width:0.4%;margin:0;padding:0;'></td>
        <td style='width:6.2%;margin:0;padding:0;vertical-align:middle;text-align:center;'>
          <input id='newGameButton' class='button' type='button' value='NEW GAME' title='Start a new game' onclick='newGameButtonClick(0)' onfocus='this.blur()'>
          <form action=''>
            <label class='radio' title='Very easy'><input id='columnslabel_3b' type='radio' value='3' name='nbColumnsSelection' style='vertical-align:middle;' onclick='newGameButtonClick(3)'><span id='columnslabel_3' class='radio' style='vertical-align:middle;'> 3 columns<br></span></label>
            <label class='radio' title='Master Mind'><input id='columnslabel_4b' type='radio' value='4' name='nbColumnsSelection' style='vertical-align:middle;' onclick='newGameButtonClick(4)'><span id='columnslabel_4' class='radio' style='vertical-align:middle;'> 4 columns<br></span></label>
            <label class='radio' title='Super Master Mind'><input id='columnslabel_5b' type='radio' value='5' name='nbColumnsSelection' style='vertical-align:middle;' onclick='newGameButtonClick(5)'><span id='columnslabel_5' class='radio' style='vertical-align:middle;'> 5 columns<br></span></label>
            <label class='radio' title='Advanced Master Mind'><input id='columnslabel_6b' type='radio' value='6' name='nbColumnsSelection' style='vertical-align:middle;' onclick='newGameButtonClick(6)'><span id='columnslabel_6' class='radio' style='vertical-align:middle;'> 6 columns<br></span></label>
            <label class='radio' title='Ultra Master Mind'><input id='columnslabel_7b' type='radio' value='7' name='nbColumnsSelection' style='vertical-align:middle;' onclick='newGameButtonClick(7)'><span id='columnslabel_7' class='radio' style='vertical-align:middle;'> 7 columns<br></span></label>
          </form>
          <input id='resetCurrentCodeButton' class='button disabled' type='button' value='Reset current code' title='Reset current code' onclick='resetCurrentCodeButtonClick()' onfocus='this.blur()' disabled>
          <input id='playRandomCodeButton' class='button disabled' type='button' value='Play random code' title='Play a random code' onclick='playRandomCodeButtonClick()' onfocus='this.blur()' disabled>
          <input id='revealSecretColorButton' class='button disabled' type='button' value='Reveal secret color' title='Reveal a color of the secret code' onclick='revealSecretColorButtonClick()' onfocus='this.blur()' disabled>
          <input id='showPossibleCodesButton' class='button disabled' type='button' value='Show possible codes' title='Show possible codes at each stage of the game (when game is over)' onfocus='this.blur()' onclick='showPossibleCodesButtonClick()' disabled>
        </td>
        <td style='width:0.4%;margin:0;padding:0;'></td>
        <td style='width:93%;margin:0;padding:0;vertical-align:middle;align:right;text-align:left;'><canvas id='my_canvas'><font color=red>Error: HTML canvas are not supported!</font></canvas></td>
      </tr>
    </table>

    <!-- Display extra text and pictures -->

    <p align='right'>
      <script>
        if (typeof(Storage) !== 'undefined') {
          let welcome_str = "Welcome";
          try {
            if ((navigator.language == "fr") || (navigator.language.indexOf("fr-") == 0)) { // covers "fr", "fr-FR", "fr-BE", "fr-CA", "fr-CH", "fr-LU"
              welcome_str = "Bienvenue";
            }
          }
          catch (exc) {}
          if (localStorage.firstname) {
            document.write("<font color=#DDDDDD><span id='welcome_id' style='float:left;'>&nbsp;&nbsp;" + welcome_str + " <b><font color=yellow>" + localStorage.firstname + "</font></b>!</span></font>");
            setTimeout(function() {
              $("#welcome_id").fadeOut().empty();
            }, 60000);
          }
        }
      </script>
      <b><a href='index.html'>&#x2302; Main page</a></b>&nbsp;&nbsp;&nbsp;<br>
      <b><a href='index.html#game_rules'>&#x2302; Game rules</a></b>&nbsp;&nbsp;&nbsp;<br>
      <b><a href='screenshots.html'>&#x2302; Game examples</a></b>&nbsp;&nbsp;&nbsp;<br>
      <b><a href='optimal_strategy.html'>&#x2302; Optimal strategy</a></b>&nbsp;&nbsp;&nbsp;<br>
      <b><a href='contact_info.html'>&#x2302; Contact info</a></b>&nbsp;&nbsp;&nbsp;<br><br>
      <script>
        {
          var date = new Date();
          var m = date.getMonth();
          var d = date.getDate();
          if ( ((m == 11) && (d >= 8)) // after December 8th
               || ((m == 0) && (d <= 8)) ) { // before January 8th
            // (Display values will be updated below if necessary)
            document.write("<img id='img_1' style='display:none;' src='img/End_of_year.png'>&nbsp;<br><img id='img_2' style='display:none;' src='img/End_of_year2.png'>&nbsp;");
          }
        }
      </script>
    </p>

    <!-- Initializations -->

    <script>
      let html_compatibility_game_version = "Ver_MA";
      let nb_errors_submitted = 0;
      let mobileMode = false;
      let androidMode = false;
      let modeAlreadySelected = false;
      let lastKeyCheck = false;
      document.body.onkeydown = function(e) {
        if (modeAlreadySelected) {
          return;
        }
        let keycheck1 = (String.fromCharCode(e.keyCode).toLowerCase() == '1');
        let keycheck2 = ((String.fromCharCode(e.keyCode).toLowerCase() == 'l') && e.shiftKey);
        if (keycheck1 && (!lastKeyCheck)) {
          lastKeyCheck = true;
        }
        else if (keycheck2 && lastKeyCheck) {
          var mode = prompt("Which mode do you want to select?", "444");
          if (mode != null) {
            document.getElementById('form_list_id').value = mode.trim();
            setTimeout("submitForm();", 444);
          }
          modeAlreadySelected = true;
        }
        else {
          lastKeyCheck = false;
        }
      };
      // Set AJAX timeout to X seconds (this will set all AJAX requests the program makes, even via $.getJSON, to have a timeout of X seconds)
      $.ajaxSetup({
        timeout: 30*1000 // 30 seconds
      });
    </script>

    <!-- Handle player's info -->

    <script src='lib/tingle-master/dist/tingle.min.js'></script>
    <script>

      var modal_mode = -1;
      var store_time = new Date().getTime();

      var modal = new tingle.modal({
          footer: true,
          stickyFooter: false,
          closeMethods: ['overlay', 'button', 'escape'],
          // closeMethods: ['button'],
          closeLabel: "Close",
          cssClass: ['custom-class-1', 'custom-class-2'],
          onOpen: function() {
            console.log('(modal onOpen)');
          },
          onClose: function() {
            console.log('(modal onClose)');
          },
          beforeClose: function() {

            console.log('(modal beforeClose)');
            if (modal_mode == 1) {

              let place_error = false;
              let country_debug = "NA";
              let city_debug = "NA";

              // Get selected country name
              try {
                let elt = document.getElementById("country_selection");
                if ( (elt.selectedIndex != -1) && (elt.selectedIndex > 0) /* (skip very first option) */) {
                  if (typeof(Storage) !== 'undefined') {
                    localStorage.countryname = elt.options[elt.selectedIndex].text;
                  }
                  country_debug = elt.options[elt.selectedIndex].text;
                }
                else {
                  alert("No country was selected!\nYou shall select a country in order to store your game scores...");
                  place_error = true;
                  country_debug = "no country was selected";
                }
              }
              catch (exc) {
                console.log("error encountered at country name selection: " + exc);
              }

              // Get city name entered
              try {
                let city_entered = document.getElementById("city_input").value;
                city_entered = city_entered.trim();
                if ( (city_entered.length >= 3) && (city_entered.length <= 20) && (/^[A-zÀ-ÿ '-]+$/.test(city_entered)) /* (only letters) */ && isCorrect(city_entered) ) {
                  if (typeof(Storage) !== 'undefined') {
                    localStorage.cityname = capitalizeFirstLetters(city_entered);
                  }
                }
                else {
                  if (!place_error) {
                    alert("Invalid city name: " + city_entered + "\nYou shall enter a valid city name in order to store your game scores...");
                    place_error = true;
                  }
                }
                city_debug = city_entered;
              }
              catch (exc) {
                console.log("error encountered at city name selection: " + exc);
              }

              if (typeof(Storage) !== 'undefined') {

                localStorage.removeItem('automaticPositioning'); // localStorage.automaticPositioning

                if (localStorage.countryname && localStorage.cityname && (!place_error)) {
                  console.log("new countryname: " + localStorage.countryname);
                  document.getElementById('form_country_id').value = localStorage.countryname;
                  var region = getRegion(localStorage.countryname, localStorage.cityname);
                  console.log("new region: " + region);
                  document.getElementById('form_region_id').value = region;
                  console.log("new city: " + localStorage.cityname);
                  document.getElementById('form_city_id').value = localStorage.cityname;
                  if (localStorage.automaticPositioning) {
                    document.getElementById('form_geoloc_id').value = firstgamegeoloc + '-' + '~i';
                  }
                  else {
                    document.getElementById('form_geoloc_id').value = firstgamegeoloc + '-' + '~~i';
                  }
                  setTimeout("submitForm();", 444);
                }
                else {
                  // country and city names shall be consistent with each other
                  localStorage.removeItem('countryname'); // localStorage.countryname
                  localStorage.removeItem('cityname'); // localStorage.cityname

                  let errorStr = "";
                  if (typeof(Storage) !== 'undefined') {
                    if (localStorage.firstaccessid) {
                      errorStr = " for first access id " + localStorage.firstaccessid;
                    }
                    if (localStorage.gamesok) {
                      errorStr = errorStr + " after " + localStorage.gamesok + " game(s)";
                    }
                    if (localStorage.html_geoloc_already_done) {
                      errorStr = errorStr + " with HTML geolocation status " + localStorage.html_geoloc_already_done;
                    }
                    try {
                      errorStr = errorStr + " for IP address " + document.getElementById('form_ipaddress_id').value;
                    }
                    catch (exc) {}
                  }
                  alert("If you accept to share your location, your country and city names will be used to store your score\nand you will also see all other players scores & rankings and in which countries and cities they played..."); // (duplicated line)
                  submitForm("warning: invalid place information entered (" + country_debug + ", " + city_debug + ")" + errorStr, true);
                }
                attempt_HTML_geolocation(true); // Subject to user acceptance => may complete / correct (in an automated way) above user inputs

              }

              modal_mode = -1;
              return true; // close the modal
              // return false; // nothing happens

            }

            else if (modal_mode == 2) {

              // Get firstname entered
              try {
                let firstname_entered = document.getElementById("firstname_input").value;
                firstname_entered = firstname_entered.trim();
                if ( (firstname_entered.length >= 3) && (firstname_entered.length <= 12) && (/^[A-zÀ-ÿ'-]+$/.test(firstname_entered)) /* (only letters) */ && isCorrect(firstname_entered) ) {
                  if (typeof(Storage) !== 'undefined') {
                    localStorage.firstname = capitalizeFirstLetters(firstname_entered);
                  }
                }
                else {
                  if (typeof(Storage) !== 'undefined') {
                    localStorage.previousfirstname = firstname_entered;
                  }
                  alert("Invalid first name: " + firstname_entered);
                }
              }
              catch (exc) {
                console.log("error encountered at first name selection: " + exc);
              }

              if (typeof(Storage) !== 'undefined') {
                if (!localStorage.firstnameAsked) {
                  localStorage.firstnameAsked = 0;
                }
                localStorage.firstnameAsked = Number(localStorage.firstnameAsked) + 1;
                if (localStorage.firstname) {
                  console.log("new firstname: " + localStorage.firstname);
                  document.getElementById('form_firstname_id').value = localStorage.firstname;
                }
                else if ((localStorage.gamesok) && (Number(localStorage.gamesok) >= 100)) {
                  // modal_mode unchanged and form not submitted waiting for proper user input
                  return false; // do not close the modal
                }
              }
              setTimeout("submitForm();", 444);

              modal_mode = -1;
              return true; // close the modal

            }

            else if (modal_mode == 3) {

              setTimeout("showPossibleCodesButtonClick(false, -1, true);", 444);
              // (same effect: setTimeout("document.getElementById('showPossibleCodesButton').click();", 444);)

              modal_mode = -1;
              return true; // close the modal
            }

            // else:
            modal_mode = -1;
            return true; // close the modal
            // return false; // nothing happens

          }
      });
      // add a button
      modal.addFooterBtn('OK', 'tingle-btn tingle-btn--primary', function() {
        // here goes some logic
        modal.close();
      });

    </script>

    <iframe style='display:none;' name='my_frame'>Your browser does not support iframes!</iframe> <!-- suppress style='display:none;' to see the form's response -->
    <form  style='display:none;' id='my_form' target='my_frame' action='https://script.google.com/macros/s/AKfycbwHJh1Tz7idd8VQJNdWIqWd-6jMxInhRtqY_O96NN7OvEKiY_ox/exec'>

      playerid: <input id='form_playerid_id' name='playerid' type='text' value='-'><br>
      firstname: <input id='form_firstname_id' name='firstname' type='text' value='-'><br>

      nbcolumns: <input id='form_nbcolumns_id' name='nbcolumns' type='text' value='-'><br>
      score: <input id='form_score_id' name='score' type='text' value='-'><br>
      attempts: <input id='form_attempts_id' name='attempts' type='text' value='-'><br>
      time: <input id='form_time_id' name='time' type='text' value='-'><br>
      perfs: <input id='form_perfs_id' name='perfs' type='text' value='-'><br>
      nbuknperfs: <input id='form_nbuknperfs_id' name='nbuknperfs' type='text' value='-'><br>
      help: <input id='form_help_id' name='help' type='text' value='-'><br>

      gamesok: <input id='form_gamesok_id' name='gamesok' type='text' value='-'><br>
      deltagames: <input id='form_deltagames_id' name='deltagames' type='text' value='-'><br>

      country: <input id='form_country_id' name='country' type='text' value='-'><br>
      region: <input id='form_region_id' name='region' type='text' value='-'><br>
      zip: <input id='form_zip_id' name='zip' type='text' value='-'><br>
      city: <input id='form_city_id' name='city' type='text' value='-'><br>
      geoloc: <input id='form_geoloc_id' name='geoloc' type='text' value='-'><br>
      timezone: <input id='form_timezone_id' name='timezone' type='text' value='-'><br>
      latitude: <input id='form_latitude_id' name='latitude' type='text' value='-'><br>
      longitude: <input id='form_longitude_id' name='longitude' type='text' value='-'><br>
      ipaddress: <input id='form_ipaddress_id' name='ipaddress' type='text' value='-'><br>

      platform: <input id='form_platform_id' name='platform' type='text' value='-'><br> <!-- OS -->
      browserlanguage: <input id='form_browserlanguage_id' name='browserlanguage' type='text' value='-'><br> <!-- Browser language -->
      useragent: <input id='form_useragent_id' name='useragent' type='text' value='-'><br> <!-- Browser (more or less) -->
      href: <input id='form_href_id' name='href' type='text' value='-'><br>
      formsubmitdate: <input id='form_formsubmitdate_id' name='formsubmitdate' type='text' value='-'><br>
      debuginfo: <input id='form_debuginfo_id' name='debuginfo' type='text' value='-'><br>

      list: <input id='form_list_id' name='list' type='text' value='-'><br>

      rankings: <input id='form_rankings_id' name='rankings' type='text' value='-'><br>

    </form>

    <script>

      function sleep(ms) { // To be called like "await sleep(1000);"
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function capitalizeFirstLetters(str) {
        if (str.length == 0) {
          return "";
        }
        else if (str.length == 1) {
          return str.charAt(0).toUpperCase();
        }
        else {
          let res = str.toLowerCase();
          res = res.charAt(0).toUpperCase() + res.slice(1);

          let res2 = "";
          let index = res.indexOf('-');
          while ((index != -1) && (index+1 < res.length)) {
            res2 = res2 + res.substring(0, index+1) + res.charAt(index+1).toUpperCase();
            if (index+2 < res.length) {
              res = res.slice(index+2);
              index = res.indexOf('-');
            }
            else {
              res = "";
              index = -1;
            }
          }
          res2 = res2 + res;
          res = res2;
          res2 = "";
          index = res.indexOf(' ');
          while ((index != -1) && (index+1 < res.length)) {
            res2 = res2 + res.substring(0, index+1) + res.charAt(index+1).toUpperCase();
            if (index+2 < res.length) {
              res = res.slice(index+2);
              index = res.indexOf(' ');
            }
            else {
              res = "";
              index = -1;
            }
          }
          res2 = res2 + res;

          res = res2;
          res2 = "";
          index = res.indexOf("'");
          while ((index != -1) && (index+1 < res.length)) {
            res2 = res2 + res.substring(0, index+1) + res.charAt(index+1).toUpperCase();
            if (index+2 < res.length) {
              res = res.slice(index+2);
              index = res.indexOf("'");
            }
            else {
              res = "";
              index = -1;
            }
          }
          res2 = res2 + res;

          res2 = res2.replace(" D'"," d'");
          res2 = res2.replace(" Sur "," sur ");

          return res2;
        }
      }

      function getLocation() {
        switch(location.protocol) {
           case 'http:':
             return 'P1';
           case 'https:':
             return 'P1b';
           case 'file:':
             return 'P2';
           default:
             // (other protocols)
             return 'P3';
        }
      }

      function nbVowels(str)
      {
        var vowel_list = 'aeiouyAEIOUY';
        var vowel_count = 0;
        for (var i = 0 ; i < str.length ; i++) {
          if (vowel_list.indexOf(str[i]) !== -1) {
            vowel_count++;
          }
        }
        return vowel_count;
      }

      function isCorrect(str) {
        if ( (str.toLowerCase().indexOf('sherlo') != -1) // (Sherlock)
             || (str.toLowerCase().indexOf('aaa') != -1)
             || (str.toLowerCase().indexOf('bbb') != -1)
             || (str.toLowerCase().indexOf('ccc') != -1)
             || (str.toLowerCase().indexOf('ddd') != -1)
             || (str.toLowerCase().indexOf('eee') != -1)
             || (str.toLowerCase().indexOf('fff') != -1)
             || (str.toLowerCase().indexOf('ggg') != -1)
             || (str.toLowerCase().indexOf('hhh') != -1)
             || (str.toLowerCase().indexOf('iii') != -1)
             || (str.toLowerCase().indexOf('jjj') != -1)
             || (str.toLowerCase().indexOf('kkk') != -1)
             || (str.toLowerCase().indexOf('lll') != -1)
             || (str.toLowerCase().indexOf('mmm') != -1)
             || (str.toLowerCase().indexOf('nnn') != -1)
             || (str.toLowerCase().indexOf('ooo') != -1)
             || (str.toLowerCase().indexOf('ppp') != -1)
             || (str.toLowerCase().indexOf('qqq') != -1)
             || (str.toLowerCase().indexOf('rrr') != -1)
             || (str.toLowerCase().indexOf('sss') != -1)
             || (str.toLowerCase().indexOf('ttt') != -1)
             || (str.toLowerCase().indexOf('uuu') != -1)
             || (str.toLowerCase().indexOf('vvv') != -1)
             || (str.toLowerCase().indexOf('www') != -1)
             || (str.toLowerCase().indexOf('xxx') != -1)
             || (str.toLowerCase().indexOf('yyy') != -1)
             || (str.toLowerCase().indexOf('zzz') != -1)
             || (str.toLowerCase().indexOf('bastard') != -1)
             || (str.toLowerCase().indexOf('fuck') != -1)
             || (str.toLowerCase().endsWith("bite"))
             || (str.toLowerCase().indexOf('noname') != -1)
             || (str.toLowerCase().indexOf('myname') != -1)
             || (str.toLowerCase().indexOf('nobody') != -1)
             || (str.toLowerCase().indexOf('noone') != -1)
             || (str.toLowerCase().indexOf('dummy') != -1)
             || (str.toLowerCase().indexOf('empty') != -1)
             || (nbVowels(str) == 0)
             || (nbVowels(str) == str.length) ) {
          return false;
        }
        return true;
      }

      if (typeof(Storage) !== 'undefined') {
        if (localStorage.firstname && (!isCorrect(localStorage.firstname))) {
          localStorage.previousfirstname = localStorage.firstname;
          localStorage.removeItem('firstname'); // localStorage.firstname
        }
      }

      function getRegion(country, city) {
        // Manual region setting
        if ((country == "France") && (city == "Paris")) { // Particular case #1
          return 'Île-de-France';
        }
        else if ((country == "Germany") && (city == "Dortmund")) { // Particular case #2
          return 'Nordrhein-Westfalen';
        }
        else {
          return '-';
        }
      }

      function HTML_geolocation_success(position) {
        let latitude = position.coords.latitude;
        let longitude = position.coords.longitude;
        console.log("HTML geolocation:");
        console.log(" latitude: " + latitude);
        console.log(" longitude: " + longitude);
        let GEOCODING = 'https://maps.googleapis.com/maps/api/geocode/json?latlng=' + latitude + '%2C' + longitude + '&language=en&key=AIzaSyBhO3CSP-LxypDUjC-MYa_b8iPfJ9qJBko';
        $.getJSON(GEOCODING).done(function(location) {
          try {
            if (location.status.toUpperCase() == "OK") {
              let country = String(location.results[0].address_components[5].long_name).trim();
              let region = String(location.results[0].address_components[4].long_name).trim();
              let city = String(location.results[0].address_components[2].long_name).trim();
              console.log(location);
              console.log(" country: " + country);
              console.log(" region: " + region);
              console.log(" city: " + city);
              console.log(" address: " + location.results[0].formatted_address);
              if ((country.length >= 3) && (city.length >= 3)) { // (redundant lines)
                localStorage.countryname = country;
                if (region.length >= 2) { // (redundant lines)
                  localStorage.regionname = region;
                }
                else {
                  localStorage.regionname = '-';
                }
                localStorage.cityname = city;
                localStorage.automaticPositioning = true;
                localStorage.html_geoloc_already_done = "ok";
              }
              else {
                console.log("HTML geolocation error: invalid location values");
                localStorage.html_geoloc_already_done = "nok-1";
              }
            }
            else {
              console.log("HTML geolocation error: status: " + location.status);
              localStorage.html_geoloc_already_done = "nok-2/" + location.status;
            }
          }
          catch (exc) {
            console.log("HTML geolocation error: " + exc);
            localStorage.html_geoloc_already_done = "nok-3/" + exc;
          }
        })
        .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
          console.log(("HTML geolocation failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim());
          localStorage.html_geoloc_already_done = "nok-4";
        });
      }
      function HTML_geolocation_error(error) {
        let error_str = "?";
        switch(error.code) {
          case error.PERMISSION_DENIED:
            if (!localStorage.html_geoloc_denied) {
              localStorage.html_geoloc_denied = 0;
            }
            localStorage.html_geoloc_denied = Number(localStorage.html_geoloc_denied) + 1;
            error_str = "user denied the request for geolocation/" + localStorage.html_geoloc_denied + "x";
            break;
          case error.POSITION_UNAVAILABLE:
            error_str = "location information is unavailable";
            break;
          case error.TIMEOUT:
            error_str = "the request to get user location timed out";
            break;
          case error.UNKNOWN_ERROR:
            error_str = "an unknown error occurred";
            break;
        }
        console.log("HTML geolocation error: " + error_str);
        localStorage.html_geoloc_already_done = "nok-5/" + error_str;
      }
      let attempt_HTML_geolocation_already_done = false;
      function attempt_HTML_geolocation(forced_mode) {
        if ((!forced_mode) && attempt_HTML_geolocation_already_done) {
          console.log("attempt_HTML_geolocation: skipped");
          return;
        }
        attempt_HTML_geolocation_already_done = true;
        if (typeof(Storage) !== 'undefined') {
          if (navigator.geolocation) {
            // Subject to user acceptance
            navigator.geolocation.getCurrentPosition(HTML_geolocation_success, HTML_geolocation_error);
          }
          else {
            console.log("HTML geolocation error: geolocation is not supported by the browser");
            localStorage.html_geoloc_already_done = "nok-6";
          }
        }
      }

      function str_from_jqxhr(jqxhr) { // (jqxhr: XMLHTTPRequest)
        try {
          let str = "jqxhr={";
          try {
            /* Status:
               200: "OK"
               403: "Forbidden"
               404: "Page not found"
               ... */
            str = str + "status:" + jqxhr.status;
            str = str + ",statusText:" + jqxhr.statusText;
            /* readyState holds the status of the XMLHttpRequest:
               0: request not initialized
               1: server connection established
               2: request received
               3: processing request
               4: request finished and response is ready */
            str = str + ",readyState:" + jqxhr.readyState;
          }
          catch (exc) {
            str = str + "?";
          }
          str = str + "}";
          return str;
        }
        catch (exc) {
          return "jqxhr=?";
        }
      }

      // Interesting links about JSONP:
      // - https://en.wikipedia.org/wiki/Same-origin_policy and https://www.getfilecloud.com/blog/using-jsonp-for-cross-domain-requests/ (JSONP usage & safety)
      // - https://ctrlq.org/code/20197-jquery-ajax-call-google-script (usage of JSONP to avoid "Cross Origin" issues)
      //   => "JSONP" to be replaced by "CORS" in the future when fully supported, which is safer.
      function submitForm(formStr = "", skipErrorDisplay = false, retryTime = 3333) {

        let my_form_url = document.getElementById("my_form").action + '?';
        if (formStr == "") { // Nominal case
          // console.log(JSON.stringify($("#my_form").serializeArray()));
          let elements = document.getElementById("my_form").elements;
          for (let i = 0, element; element = elements[i++];) {
            my_form_url = my_form_url + element.name + '=' + element.value + '&';
          }
        }
        else { // Specific case
          my_form_url = my_form_url + 'form_str=' + formStr + '&';
        }
        my_form_url = my_form_url + 'k=' + Math.floor(Math.random()*9999999999+1) + '&';
        my_form_url = my_form_url + 'my_callback_fct=handle_rsp';
        // console.log(my_form_url);
        // Submit form
        console.log("(jQuery.ajax get/jsonp" + ((formStr == "") ? "" : " for a specific case") + ")");
        jQuery.ajax({
          crossDomain: true,
          url: my_form_url,
          method: "GET",
          dataType: "jsonp"
        })
        .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)

          try {
            if (jqxhr.status == 404) { // Corresponds to the error "Loading failed for the <script> with source https://..."
              console.log(("script submission failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim());
              // Keep some time between the 2 form submissions
              let now = new Date().getTime();
              while(new Date().getTime() < now + retryTime){}; // (interface is frozen during this short time)

              jQuery.ajax({
                crossDomain: true,
                url: my_form_url,
                method: "GET",
                dataType: "jsonp"
              })
              .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
                try {
                  if (jqxhr.status == 404) { // Corresponds to the error "Loading failed for the <script> with source https://..."
                    console.log(("script submission retry failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim());
                  } // else: systematic parse error is ignored
                  if ((formStr == "") && (!skipErrorDisplay)) {
                    alert("Oops... a network error occurred, game scores could not be displayed");
                  }
                }
                catch (exc) {
                  console.log(("script submission retry failure (abnormal case): " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim());
                }
              });
            } // else: systematic parse error is ignored
          }
          catch (exc) {
            console.log(("script submission failure (abnormal case): " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim());
          }

        });

        // document.getElementById('my_form').submit();
        // $("#my_form").submit();
      }

      var playerid_prefix = "ID/";
      function handle_rsp_delayed(e) {
        if ( (e !== undefined)
             && (typeof e.parameter !== 'undefined')
             && (typeof e.parameter.playerid !== 'undefined')
             && (typeof e.rsp_cd == 'undefined')
             && (typeof e.parameter.rankings !== 'undefined') && (e.parameter.rankings.length > 10) ) {
          var rsp_rankings_str = JSON.stringify(e.parameter.rankings).replaceAll("^\"|\"$", ""); // (suppress leading and ending double quotes)
          console.log("1: " + rsp_rankings_str);
          rsp_rankings_str = rsp_rankings_str.replaceAll("<td>", "<td style='border:1px solid black;margin:2px;padding:2px;text-align:center;font-weight:bold;'>"); // actual <td> syntax is applied
          rsp_rankings_str = rsp_rankings_str.replace(/[\[]/g, "<td style='border:1px solid black;margin:2px;padding:2px;text-align:center;font-weight:bold;'>"); // actual <td> syntax is applied: "[" -> "<td ...>"
          rsp_rankings_str = rsp_rankings_str.replace(/[\]]/g, "</td>"); // actual </td> syntax is applied: "]" -> "</td>"
          rsp_rankings_str = rsp_rankings_str.replaceAll("<s>", "<small>"); // "<s>" -> "<small>"
          rsp_rankings_str = rsp_rankings_str.replaceAll("</s>", "</small>"); // "</s>" -> "</small>"
          rsp_rankings_str = rsp_rankings_str.replace(/(\([0-9]+\))/g, "<font color=#555555>$1</font>"); // apply some color changes
          console.log("2: " + rsp_rankings_str);
          // Rk: top scores are always displayed, even if current game score is not in them
          if (modal_mode == -1) {
            try {
              modal_mode = 3;
              // set modal content
              modal.setContent("<div style='-webkit-touch-callout: none; /* iOS Safari */ -webkit-user-select: none; /* Safari */ -khtml-user-select: none; /* Konqueror HTML */ -moz-user-select: none; /* Firefox */ -ms-user-select: none; /* Internet Explorer/Edge */ user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */'>"
                               + rsp_rankings_str
                               + "</div>");
              // open modal
              modal.open();
            }
            catch (exc) {
              throw new Error("modal error (" + modal_mode + "):" + exc + ": " + exc.stack);
            }
          }
          else {
            console.log("modal display conditions not fulfilled (" + modal_mode + ")");
          }
        }
        else {
          if (e == undefined) {
            console.log('rsp_cd: ?');
          }
          else if (typeof e.rsp_cd !== 'undefined') {
            console.log('rsp_cd: ' + JSON.stringify(e.rsp_cd));
          }
          else {
            console.log('rsp_cd: ?');
          }
        }
      }
      function handle_rsp(e) {
        console.log("(handle_rsp)");

        var score_display_time = 4444; // (see blinking time)
        if (mobileMode) {
          score_display_time = 1444; // (no blinking)
        }

        var time_to_wait = 44;
        var time_diff = new Date().getTime() - store_time;
        if (time_diff < 0) { // (invalid case)
          time_to_wait = 44;
        }
        else if (time_diff < score_display_time) {
          time_to_wait = score_display_time - time_diff;
        }
        else {
          time_to_wait = 44; // (no time to wait, form submission was long enough)
        }
        console.log("(time_diff=" + time_diff + ", time_to_wait=" + time_to_wait + ")");
        setTimeout("handle_rsp_delayed(" + JSON.stringify(e) + ");", time_to_wait);
      }

      var last_data_used = null;
      var last_game_cnt = -1;
      async function store_player_info(game_cnt, nbcolumns, score, attempts, timestr, perfs, nbuknperfs, help, gamestr) { // asynchronous function

        try {

          if (game_cnt == last_game_cnt) { // At most one storage per game
            return;
          }
          last_game_cnt = game_cnt;
          store_time = new Date().getTime();

          let gamesok = -1;
          let deltagames = -1;
          if (typeof(Storage) !== 'undefined') {

            if (!localStorage.gamesok) {
              localStorage.gamesok = 0;
            }
            localStorage.gamesok = Number(localStorage.gamesok) + 1;
            gamesok = Number(localStorage.gamesok);

            if ((gamesok >= 140) && (!localStorage.firstname)) { // No interest for sharing results
              if ((gamesok % 100) != 0) { // all odd numbers => first name will not be asked
                return;
              }
              if (nbcolumns == 3) {
                return;
              }
            }
            if (localStorage.skip_storing) {
              return;
            }

            switch (nbcolumns) {

              case 3:
                if (!localStorage.nbgamesstarted3) {
                  localStorage.nbgamesstarted3 = 0;
                }
                if (!localStorage.nbgamesstarted3_ref) {
                  localStorage.nbgamesstarted3_ref = 0;
                }
                deltagames = localStorage.nbgamesstarted3 - localStorage.nbgamesstarted3_ref - 1;
                localStorage.nbgamesstarted3_ref = localStorage.nbgamesstarted3;
                break;
              case 4:
                if (!localStorage.nbgamesstarted4) {
                  localStorage.nbgamesstarted4 = 0;
                }
                if (!localStorage.nbgamesstarted4_ref) {
                  localStorage.nbgamesstarted4_ref = 0;
                }
                deltagames = localStorage.nbgamesstarted4 - localStorage.nbgamesstarted4_ref - 1;
                localStorage.nbgamesstarted4_ref = localStorage.nbgamesstarted4;
                break;
              case 5:
                if (!localStorage.nbgamesstarted5) {
                  localStorage.nbgamesstarted5 = 0;
                }
                if (!localStorage.nbgamesstarted5_ref) {
                  localStorage.nbgamesstarted5_ref = 0;
                }
                deltagames = localStorage.nbgamesstarted5 - localStorage.nbgamesstarted5_ref - 1;
                localStorage.nbgamesstarted5_ref = localStorage.nbgamesstarted5;
                break;
              case 6:
                if (!localStorage.nbgamesstarted6) {
                  localStorage.nbgamesstarted6 = 0;
                }
                if (!localStorage.nbgamesstarted6_ref) {
                  localStorage.nbgamesstarted6_ref = 0;
                }
                deltagames = localStorage.nbgamesstarted6 - localStorage.nbgamesstarted6_ref - 1;
                localStorage.nbgamesstarted6_ref = localStorage.nbgamesstarted6;
                break;

              case 7:
                if (!localStorage.nbgamesstarted7) {
                  localStorage.nbgamesstarted7 = 0;
                }
                if (!localStorage.nbgamesstarted7_ref) {
                  localStorage.nbgamesstarted7_ref = 0;
                }
                deltagames = localStorage.nbgamesstarted7 - localStorage.nbgamesstarted7_ref - 1;
                localStorage.nbgamesstarted7_ref = localStorage.nbgamesstarted7;
                break;

              default:
                console.log("Error: invalid nbcolumns in store_player_info(): " + nbcolumns);
                return;

            }

          }

          var geolocation_handler = {

            run_retry: function (data_p) {
              /* ipinfodb.com response format:
                 - SUCCESS case:
                  statusCode	"OK"
                  statusMessage	""
                  ipAddress	"94.239.111.222"
                  countryCode	"FR"
                  countryName	"France"
                  regionName	"Ile-de-France"
                  cityName	"Paris"
                  zipCode	"75000"
                  latitude	"48.8534"
                  longitude	"2.3488"
                  timeZone	"+01:00"
                - FAILURE case:
                  statusCode	"ERROR"
                  statusMessage	"Invalid IP Address."
                  ipAddress	"994.239.111.222"
                  countryCode	""
                  countryName	""
                  regionName	""
                  cityName	""
                  zipCode	""
                  latitude	"0"
                  longitude	"0"
                  timeZone	""
              */
              let converted_data = JSON.stringify(data_p);

              console.log("(geolocation retry data conversion for " + converted_data + ")");

              if ((typeof data_p.statusCode != 'undefined') && (typeof data_p.statusMessage != 'undefined') && (data_p.statusCode != "OK")) {
                console.log("geolocation error in run_retry(): " + data_p.statusCode + " " + data_p.statusMessage);
              }

              // latitude -> latitude
              // longitude -> longitude
              // countryName -> country_name
              converted_data = converted_data.replace("countryName", "country_name");
              // regionName -> region
              converted_data = converted_data.replace("regionName", "region");
              // zipCode -> postal
              converted_data = converted_data.replace("zipCode", "postal");
              // cityName -> city
              converted_data = converted_data.replace("cityName", "city");
              // timeZone -> time_zone
              converted_data = converted_data.replace("timeZone", "time_zone");
              // ipAddress -> ip
              converted_data = converted_data.replace("ipAddress", "ip");

              geolocation_handler.run(JSON.parse(converted_data), true);
            },

            nb_JSON_queries_posted: 0,
            first_geolocation_errorStr: "-",

            run: function (data_p) {

              // Check that the response contains valid information
              // **************************************************

              let this_data_is_valid = false;
              if ( (typeof data_p.latitude != 'undefined') && (typeof data_p.longitude != 'undefined') // (redundant lines)
                   && ((String(data_p.latitude).indexOf('.') != -1) || (String(data_p.longitude).indexOf('.') != -1)) // (redundant lines)
                   && ((typeof data_p.country_name != 'undefined') && (data_p.country_name.length >= 3)) // (redundant lines)
                   && ((typeof data_p.city != 'undefined') && (data_p.city.length >= 3)) // (redundant lines)
                   && ((typeof data_p.ip != 'undefined') && (String(data_p.ip).trim().length >= 7 /* 0.0.0.0 */)) ) { // (redundant lines)
                this_data_is_valid = true;
                if (typeof(Storage) !== 'undefined') { // Better than manual positioning (and will be updated if necessary)
                  localStorage.countryname = String(data_p.country_name).trim();
                  if ((typeof data_p.region != 'undefined') && (data_p.region.length >= 2)) { // (redundant lines)
                    localStorage.regionname = String(data_p.region).trim();
                  }
                  else {
                    localStorage.regionname = '-';
                  }
                  localStorage.cityname = String(data_p.city).trim();
                  localStorage.automaticPositioning = true;
                }
              }
              let last_data_used_is_valid = false;
              if ( (last_data_used != null)
                   && (typeof last_data_used.latitude != 'undefined') && (typeof last_data_used.longitude != 'undefined') // (redundant lines)
                   && ((String(last_data_used.latitude).indexOf('.') != -1) || (String(last_data_used.longitude).indexOf('.') != -1)) // (redundant lines)
                   && ((typeof last_data_used.country_name != 'undefined') && (last_data_used.country_name.length >= 3)) // (redundant lines)
                   && ((typeof last_data_used.city != 'undefined') && (last_data_used.city.length >= 3)) // (redundant lines)
                   && ((typeof last_data_used.ip != 'undefined') && (String(last_data_used.ip).trim().length >= 7 /* 0.0.0.0 */)) ) { // (redundant lines)
                last_data_used_is_valid = true;
              }
              let successcase__this_data_is_used;
              let data;
              let last_data_tag = "";
              if (this_data_is_valid || (!last_data_used_is_valid)) {
                data = data_p;
              }
              else { // Reuse last valid geolocation data
                data = last_data_used;
                last_data_tag = "r";
              }
              successcase__this_data_is_used = (data != last_data_used); // (data_p and last_data_used may be equal pointers)
              console.log("(geolocation: this_data:" + this_data_is_valid + ", last_data_used:" + last_data_used_is_valid + ", this_data_is_used: " + successcase__this_data_is_used + ")");
              last_data_used = data;

              let country = '-';
              let region = '-';
              let zip = '-';
              let city = '-'; // (city may stay equal to this default value if not valid)
              let geoloc = '-';  // (geoloc may stay equal to this default value if not valid)
              let timezone = '-';
              let latitude = '-';
              let longitude = '-';
              let ipaddress = '-'; // (ipaddress may stay equal to this default value if not valid)
              if ( (typeof data.latitude != 'undefined') && (typeof data.longitude != 'undefined') // (redundant lines)
                   && ((String(data.latitude).indexOf('.') != -1) || (String(data.longitude).indexOf('.') != -1)) ) {

                if ((typeof data.country_name != 'undefined') && (String(data.country_name).trim().length >= 3)) { // (redundant lines)
                  country = String(data.country_name).trim();
                }
                else {
                  console.log('invalid country name in response');
                }
                if ((typeof data.region != 'undefined') && (String(data.region).trim().length >= 2)) {
                  region = String(data.region).trim();
                }
                else {
                  console.log('invalid region name in response');
                }
                if ((typeof data.postal != 'undefined') && (String(data.postal).trim().length >= 2)) {
                  zip = String(data.postal).trim();
                }
                else {
                  console.log('invalid zip code in response');
                }
                if ((typeof data.city != 'undefined') && (String(data.city).trim().length >= 3)) { // (redundant lines)
                  city = String(data.city).trim();
                  geoloc = 'ok' + String(geolocation_handler.nb_JSON_queries_posted) + last_data_tag;
                }
                else {
                  console.log('invalid city name in response');
                }
                if ((typeof data.time_zone != 'undefined') && (String(data.time_zone).trim().length >= 2)) {
                  if ((typeof data.time_zone.name != 'undefined') && (String(data.time_zone.name).trim().length >= 2)) {
                    timezone = String(data.time_zone.name).trim();
                  }
                  else {
                    timezone = String(data.time_zone).trim();
                  }
                }
                else {
                  console.log('invalid time zone in response');
                }
                if (typeof data.latitude != 'undefined') {
                  latitude = String(data.latitude).trim();
                }
                else {
                  console.log('invalid latitude response');
                }
                if (typeof data.longitude != 'undefined') {
                  longitude = String(data.longitude).trim();
                }
                else {
                  console.log('invalid longitude in response');
                }

              }

              let valid_ipaddress = false;
              if ((typeof data.ip != 'undefined') && (String(data.ip).trim().length >= 7 /* 0.0.0.0 */)) { // (redundant lines)
                ipaddress = String(data.ip).trim();
                valid_ipaddress = true;
              }
              else {
                console.log('invalid ip address in response');
              }

              // Manual geolocation table corrections for particular IP addresses
              if ( (ipaddress.indexOf("176.130.42.") == 0) && (ipaddress.length <= 15) ) { // 176.130.42.* IPv4 addresses
                country = "France";
                region = "Alsace";
                city = "Munster";
                geoloc = 'ok' + String(geolocation_handler.nb_JSON_queries_posted) + last_data_tag + "+";
              }

              // Manual conversions
              if (localStorage.firstname && (localStorage.firstname.indexOf("Ghi") == 0) && (region == "Illinois") && (city == "Naperville")) {
                country = "France";
                region = "Île-de-France";
                city = "Paris";
                geoloc = 'ok' + String(geolocation_handler.nb_JSON_queries_posted) + last_data_tag + "+";
              }
              else if (localStorage.firstname && (localStorage.firstname.indexOf("Ghi") == 0) && (region == "California") && (city == "San Jose")) {
                country = "France";
                region = "Île-de-France";
                city = "Paris";
                geoloc = 'ok' + String(geolocation_handler.nb_JSON_queries_posted) + last_data_tag + "+";
              }
              if (country == "Lao People's Democratic Republic") {
                country = "Laos";
              }
              if (country == "Venezuela, Bolivarian Republic of") {
                country = "Venezuela";
              }
              if ((country == "Portugal") && (region == "Regiao Autonoma da Madeira")) {
                region = "Madeira";
              }
              if (country.indexOf("Republic of") == 0) {
                country = country.replace("Republic of", "").trim();
              }
              let comma_idx = country.indexOf(", ");
              if (comma_idx >= 4) {
                country = country.substring(0, comma_idx).trim();
              }

              // Check if geolocation data are valid
              if (geolocation_handler.nb_JSON_queries_posted == 1) {
                if ((!valid_ipaddress) || (city == '-')) {
                  let retry_error_str = "";
                  if (!valid_ipaddress) {
                    retry_error_str += "invalid IP address ";
                    if (typeof data.ip != 'undefined') {
                      retry_error_str += String(data.ip).trim() + " ";
                    }
                  }
                  if (city == '-') {
                    retry_error_str += "invalid city ";
                    if (typeof data.city != 'undefined') {
                      retry_error_str += String(data.city).trim();
                    }
                  }
                  // => exit the function and retry
                  return geolocation_handler.geolocation_retry("", "manual geolocation retry due to invalid geolocation data", retry_error_str.trim());
                }
              }

              if (typeof(Storage) !== 'undefined') {
                if ( (country == '-') || (city == '-') ) { // Fill a consistent set of {country, region, city} values
                  if (localStorage.countryname && localStorage.cityname) {
                    country = localStorage.countryname;
                    if (localStorage.automaticPositioning && localStorage.regionname) {
                      region = localStorage.regionname;
                    }
                    else {
                      region = getRegion(localStorage.countryname, localStorage.cityname);
                    }
                    city = localStorage.cityname;
                    if (localStorage.automaticPositioning) {
                      geoloc = '~' + String(geolocation_handler.nb_JSON_queries_posted);
                    }
                    else {
                      geoloc = '~~' + String(geolocation_handler.nb_JSON_queries_posted);
                    }
                  }
                }
                geoloc = firstgamegeoloc + '-' + geoloc;
              }

              console.log(country);
              document.getElementById('form_country_id').value = country;
              console.log(region);
              document.getElementById('form_region_id').value = region;
              console.log(zip);
              document.getElementById('form_zip_id').value = zip;
              console.log(city);
              document.getElementById('form_city_id').value = city;
              console.log(geoloc);
              document.getElementById('form_geoloc_id').value = geoloc;
              console.log(timezone);
              document.getElementById('form_timezone_id').value = timezone;
              console.log(latitude);
              document.getElementById('form_latitude_id').value = latitude;
              console.log(longitude);
              document.getElementById('form_longitude_id').value = longitude;
              console.log(ipaddress);
              document.getElementById('form_ipaddress_id').value = ipaddress;

              // Other fields
              // ************

              let playerid;
              let firstname = "-"; // (firstname may stay equal to this default value if not defined)
              if (typeof(Storage) !== 'undefined') {
                if (localStorage.firstname) {
                  firstname = localStorage.firstname;
                }
                if (!localStorage.playerid) {
                  let id = makeid() + ' - ' + new Date();
                  localStorage.playerid = id;
                }
                playerid = playerid_prefix + localStorage.playerid;
              }
              else {
                console.log("Error: your browser does not support web storage...");
                playerid = playerid_prefix + "Default";
              }

              console.log(playerid);
              document.getElementById('form_playerid_id').value = playerid;
              console.log(firstname);
              document.getElementById('form_firstname_id').value = firstname;
              console.log(nbcolumns);
              document.getElementById('form_nbcolumns_id').value = nbcolumns;
              console.log(score);
              document.getElementById('form_score_id').value = score;
              console.log(attempts);
              document.getElementById('form_attempts_id').value = attempts;
              console.log(timestr);
              document.getElementById('form_time_id').value = timestr;
              console.log(perfs);
              document.getElementById('form_perfs_id').value = perfs;
              console.log(nbuknperfs);
              document.getElementById('form_nbuknperfs_id').value = nbuknperfs;
              console.log(help);
              document.getElementById('form_help_id').value = help;
              console.log(gamesok);
              document.getElementById('form_gamesok_id').value = gamesok;
              console.log(deltagames);
              document.getElementById('form_deltagames_id').value = deltagames;

              console.log(navigator.platform);
              document.getElementById('form_platform_id').value = navigator.platform;
              console.log(navigator.language);
              document.getElementById('form_browserlanguage_id').value = navigator.language;
              console.log(navigator.userAgent);
              document.getElementById('form_useragent_id').value = navigator.userAgent;
              document.getElementById('form_href_id').value = decodeURI(location.href);
              document.getElementById('form_formsubmitdate_id').value = new Date();

              var extra_debug_info = "";
              try {
                if (typeof(Storage) !== 'undefined') {
                  if (localStorage.previousfirstname) {
                    extra_debug_info = extra_debug_info + "/PreviousFirstName:" + localStorage.previousfirstname;
                  }
                }
                extra_debug_info = extra_debug_info + "/Game:" + gamestr;
                extra_debug_info = extra_debug_info + "/Cookies:" + navigator.cookieEnabled;
                extra_debug_info = extra_debug_info + "/Java:" + navigator.javaEnabled();
                var pluginsLength = navigator.plugins.length; // (Note: plugin listing is no longer allowed in Firefox for security reasons => length will be less than the actual value)
                extra_debug_info =  extra_debug_info + "/Plugins:" + pluginsLength;
                if (pluginsLength > 0) {
                  for (var i = 0; i < pluginsLength; i++) {
                    extra_debug_info = extra_debug_info + "|" + i + ":" + navigator.plugins[i].filename + (navigator.plugins[i].version ? navigator.plugins[i].version : "");
                  }
                }
                extra_debug_info = extra_debug_info + "/MimeTypes:" + navigator.mimeTypes.length;
              }
              catch (exc) {}
              var firstNameAskedStr = "0x";
              var firstAccessIdStr = "-";
              if (typeof(Storage) !== 'undefined') {
                if (localStorage.firstnameAsked) {
                  firstNameAskedStr = localStorage.firstnameAsked + "x"; // (past game counter to simplify)
                }
                if (localStorage.firstaccessid) {
                  firstAccessIdStr = localStorage.firstaccessid;
                }
              }
              document.getElementById('form_debuginfo_id').value = getLocation() + '/Screen:' + screen.width + '*' + screen.height + ',' + screen.colorDepth + '/Inner:' + window.innerWidth + "*" + window.innerHeight + '/' + html_compatibility_game_version + '/GeolocStatus:' + successcase__this_data_is_used + '/FirstNameAsked:' + firstNameAskedStr + '/FirstAccessId:' + firstAccessIdStr + extra_debug_info;

              document.getElementById('form_rankings_id').value = '-';
              document.getElementById('form_list_id').value = '-';

              var form_to_be_submitted = true;
              if (typeof(Storage) !== 'undefined') {
                if ( ((city == '-') && (!localStorage.cityname))
                     || ((country == '-') && (!localStorage.countryname)) ) {
                  if (modal_mode == -1) {
                    try  {
                      modal_mode = 1;
                      // set modal content
                      modal.setContent("<div style='-webkit-touch-callout: none; /* iOS Safari */ -webkit-user-select: none; /* Safari */ -khtml-user-select: none; /* Konqueror HTML */ -moz-user-select: none; /* Firefox */ -ms-user-select: none; /* Internet Explorer/Edge */ user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */'>"
                                       + "<h2>Storing your scores...<br>Please enter your country and city names, they will be used to store your scores:</h2>"
                                       + "<h3>Your country:</h3><select id='country_selection'><option value=\"-\">Select your country...</option><option value=\"AF\">Afghanistan</option><option value=\"AX\">Åland Islands</option><option value=\"AL\">Albania</option><option value=\"DZ\">Algeria</option><option value=\"AS\">American Samoa</option><option value=\"AD\">Andorra</option><option value=\"AO\">Angola</option><option value=\"AI\">Anguilla</option><option value=\"AQ\">Antarctica</option><option value=\"AG\">Antigua and Barbuda</option><option value=\"AR\">Argentina</option><option value=\"AM\">Armenia</option><option value=\"AW\">Aruba</option><option value=\"AU\">Australia</option><option value=\"AT\">Austria</option><option value=\"AZ\">Azerbaijan</option><option value=\"BS\">Bahamas</option><option value=\"BH\">Bahrain</option><option value=\"BD\">Bangladesh</option><option value=\"BB\">Barbados</option><option value=\"BY\">Belarus</option><option value=\"BE\">Belgium</option><option value=\"BZ\">Belize</option><option value=\"BJ\">Benin</option><option value=\"BM\">Bermuda</option><option value=\"BT\">Bhutan</option><option value=\"BO\">Bolivia, Plurinational State of</option><option value=\"BQ\">Bonaire, Sint Eustatius and Saba</option><option value=\"BA\">Bosnia and Herzegovina</option><option value=\"BW\">Botswana</option><option value=\"BV\">Bouvet Island</option><option value=\"BR\">Brazil</option><option value=\"IO\">British Indian Ocean Territory</option><option value=\"BN\">Brunei Darussalam</option><option value=\"BG\">Bulgaria</option><option value=\"BF\">Burkina Faso</option><option value=\"BI\">Burundi</option><option value=\"KH\">Cambodia</option><option value=\"CM\">Cameroon</option><option value=\"CA\">Canada</option><option value=\"CV\">Cape Verde</option><option value=\"KY\">Cayman Islands</option><option value=\"CF\">Central African Republic</option><option value=\"TD\">Chad</option><option value=\"CL\">Chile</option><option value=\"CN\">China</option><option value=\"CX\">Christmas Island</option><option value=\"CC\">Cocos (Keeling) Islands</option><option value=\"CO\">Colombia</option><option value=\"KM\">Comoros</option><option value=\"CG\">Congo</option><option value=\"CD\">Congo, the Democratic Republic of the</option><option value=\"CK\">Cook Islands</option><option value=\"CR\">Costa Rica</option><option value=\"CI\">Côte d'Ivoire</option><option value=\"HR\">Croatia</option><option value=\"CU\">Cuba</option><option value=\"CW\">Curaçao</option><option value=\"CY\">Cyprus</option><option value=\"CZ\">Czech Republic</option><option value=\"DK\">Denmark</option><option value=\"DJ\">Djibouti</option><option value=\"DM\">Dominica</option><option value=\"DO\">Dominican Republic</option><option value=\"EC\">Ecuador</option><option value=\"EG\">Egypt</option><option value=\"SV\">El Salvador</option><option value=\"GQ\">Equatorial Guinea</option><option value=\"ER\">Eritrea</option><option value=\"EE\">Estonia</option><option value=\"ET\">Ethiopia</option><option value=\"FK\">Falkland Islands (Malvinas)</option><option value=\"FO\">Faroe Islands</option><option value=\"FJ\">Fiji</option><option value=\"FI\">Finland</option><option value=\"FR\">France</option><option value=\"GF\">French Guiana</option><option value=\"PF\">French Polynesia</option><option value=\"TF\">French Southern Territories</option><option value=\"GA\">Gabon</option><option value=\"GM\">Gambia</option><option value=\"GE\">Georgia</option><option value=\"DE\">Germany</option><option value=\"GH\">Ghana</option><option value=\"GI\">Gibraltar</option><option value=\"GR\">Greece</option><option value=\"GL\">Greenland</option><option value=\"GD\">Grenada</option><option value=\"GP\">Guadeloupe</option><option value=\"GU\">Guam</option><option value=\"GT\">Guatemala</option><option value=\"GG\">Guernsey</option><option value=\"GN\">Guinea</option><option value=\"GW\">Guinea-Bissau</option><option value=\"GY\">Guyana</option><option value=\"HT\">Haiti</option><option value=\"HM\">Heard Island and McDonald Islands</option><option value=\"VA\">Holy See (Vatican City State)</option><option value=\"HN\">Honduras</option><option value=\"HK\">Hong Kong</option><option value=\"HU\">Hungary</option><option value=\"IS\">Iceland</option><option value=\"IN\">India</option><option value=\"ID\">Indonesia</option><option value=\"IR\">Iran, Islamic Republic of</option><option value=\"IQ\">Iraq</option><option value=\"IE\">Ireland</option><option value=\"IM\">Isle of Man</option><option value=\"IL\">Israel</option><option value=\"IT\">Italy</option><option value=\"JM\">Jamaica</option><option value=\"JP\">Japan</option><option value=\"JE\">Jersey</option><option value=\"JO\">Jordan</option><option value=\"KZ\">Kazakhstan</option><option value=\"KE\">Kenya</option><option value=\"KI\">Kiribati</option><option value=\"KP\">Korea, Democratic People's Republic of</option><option value=\"KR\">Korea, Republic of</option><option value=\"KW\">Kuwait</option><option value=\"KG\">Kyrgyzstan</option><option value=\"LA\">Lao People's Democratic Republic</option><option value=\"LV\">Latvia</option><option value=\"LB\">Lebanon</option><option value=\"LS\">Lesotho</option><option value=\"LR\">Liberia</option><option value=\"LY\">Libya</option><option value=\"LI\">Liechtenstein</option><option value=\"LT\">Lithuania</option><option value=\"LU\">Luxembourg</option><option value=\"MO\">Macao</option><option value=\"MK\">Macedonia, the former Yugoslav Republic of</option><option value=\"MG\">Madagascar</option><option value=\"MW\">Malawi</option><option value=\"MY\">Malaysia</option><option value=\"MV\">Maldives</option><option value=\"ML\">Mali</option><option value=\"MT\">Malta</option><option value=\"MH\">Marshall Islands</option><option value=\"MQ\">Martinique</option><option value=\"MR\">Mauritania</option><option value=\"MU\">Mauritius</option><option value=\"YT\">Mayotte</option><option value=\"MX\">Mexico</option><option value=\"FM\">Micronesia, Federated States of</option><option value=\"MD\">Moldova, Republic of</option><option value=\"MC\">Monaco</option><option value=\"MN\">Mongolia</option><option value=\"ME\">Montenegro</option><option value=\"MS\">Montserrat</option><option value=\"MA\">Morocco</option><option value=\"MZ\">Mozambique</option><option value=\"MM\">Myanmar</option><option value=\"NA\">Namibia</option><option value=\"NR\">Nauru</option><option value=\"NP\">Nepal</option><option value=\"NL\">Netherlands</option><option value=\"NC\">New Caledonia</option><option value=\"NZ\">New Zealand</option><option value=\"NI\">Nicaragua</option><option value=\"NE\">Niger</option><option value=\"NG\">Nigeria</option><option value=\"NU\">Niue</option><option value=\"NF\">Norfolk Island</option><option value=\"MP\">Northern Mariana Islands</option><option value=\"NO\">Norway</option><option value=\"OM\">Oman</option><option value=\"PK\">Pakistan</option><option value=\"PW\">Palau</option><option value=\"PS\">Palestinian Territory, Occupied</option><option value=\"PA\">Panama</option><option value=\"PG\">Papua New Guinea</option><option value=\"PY\">Paraguay</option><option value=\"PE\">Peru</option><option value=\"PH\">Philippines</option><option value=\"PN\">Pitcairn</option><option value=\"PL\">Poland</option><option value=\"PT\">Portugal</option><option value=\"PR\">Puerto Rico</option><option value=\"QA\">Qatar</option><option value=\"RE\">Réunion</option><option value=\"RO\">Romania</option><option value=\"RU\">Russian Federation</option><option value=\"RW\">Rwanda</option><option value=\"BL\">Saint Barthélemy</option><option value=\"SH\">Saint Helena, Ascension and Tristan da Cunha</option><option value=\"KN\">Saint Kitts and Nevis</option><option value=\"LC\">Saint Lucia</option><option value=\"MF\">Saint Martin (French part)</option><option value=\"PM\">Saint Pierre and Miquelon</option><option value=\"VC\">Saint Vincent and the Grenadines</option><option value=\"WS\">Samoa</option><option value=\"SM\">San Marino</option><option value=\"ST\">Sao Tome and Principe</option><option value=\"SA\">Saudi Arabia</option><option value=\"SN\">Senegal</option><option value=\"RS\">Serbia</option><option value=\"SC\">Seychelles</option><option value=\"SL\">Sierra Leone</option><option value=\"SG\">Singapore</option><option value=\"SX\">Sint Maarten (Dutch part)</option><option value=\"SK\">Slovakia</option><option value=\"SI\">Slovenia</option><option value=\"SB\">Solomon Islands</option><option value=\"SO\">Somalia</option><option value=\"ZA\">South Africa</option><option value=\"GS\">South Georgia and the South Sandwich Islands</option><option value=\"SS\">South Sudan</option><option value=\"ES\">Spain</option><option value=\"LK\">Sri Lanka</option><option value=\"SD\">Sudan</option><option value=\"SR\">Suriname</option><option value=\"SJ\">Svalbard and Jan Mayen</option><option value=\"SZ\">Swaziland</option><option value=\"SE\">Sweden</option><option value=\"CH\">Switzerland</option><option value=\"SY\">Syrian Arab Republic</option><option value=\"TW\">Taiwan, Province of China</option><option value=\"TJ\">Tajikistan</option><option value=\"TZ\">Tanzania, United Republic of</option><option value=\"TH\">Thailand</option><option value=\"TL\">Timor-Leste</option><option value=\"TG\">Togo</option><option value=\"TK\">Tokelau</option><option value=\"TO\">Tonga</option><option value=\"TT\">Trinidad and Tobago</option><option value=\"TN\">Tunisia</option><option value=\"TR\">Turkey</option><option value=\"TM\">Turkmenistan</option><option value=\"TC\">Turks and Caicos Islands</option><option value=\"TV\">Tuvalu</option><option value=\"UG\">Uganda</option><option value=\"UA\">Ukraine</option><option value=\"AE\">United Arab Emirates</option><option value=\"GB\">United Kingdom</option><option value=\"US\">United States</option><option value=\"UM\">United States Minor Outlying Islands</option><option value=\"UY\">Uruguay</option><option value=\"UZ\">Uzbekistan</option><option value=\"VU\">Vanuatu</option><option value=\"VE\">Venezuela, Bolivarian Republic of</option><option value=\"VN\">Viet Nam</option><option value=\"VG\">Virgin Islands, British</option><option value=\"VI\">Virgin Islands, U.S.</option><option value=\"WF\">Wallis and Futuna</option><option value=\"EH\">Western Sahara</option><option value=\"YE\">Yemen</option><option value=\"ZM\">Zambia</option><option value=\"ZW\">Zimbabwe</option></select>"
                                       + "<h3>Your city (between 3 and 20 characters):</h3><input id='city_input' type='text' value='Paris?' maxlength='20'></input>"
                                       + "<h4>Close this dialog to skip this step</h4>"
                                       + "</div>");
                      // open modal
                      modal.open();
                      form_to_be_submitted = false; // form to be submitted when modal is closed
                    }
                    catch (exc) {
                      throw new Error("modal error (" + modal_mode + "):" + exc + ": " + exc.stack);
                    }
                  }
                }
                else {
                  if ( (!localStorage.firstname)
                       && (gamesok >= 4) // (coherent with "history_clear_advice")
                       && (attempts >= 4) // (game not too easy)
                       && ( (gamesok <= 5) || ((gamesok % 2) == 1) ) // (do not ask first name too often if not filled / ignore 1 result out of 2 + oblige page reload after 100 games if not filled / no more results after 140 games if not filled)
                       && ( ((nbcolumns == 4) && (score >= 55)) || ((nbcolumns == 5) && (score >= 60)) || ((nbcolumns == 6) && (score >= 110)) || ((nbcolumns == 7) && (score >= 130))
                            || ((gamesok >= 7) && (score >= 44))
                            || ((gamesok >= 13) && (score >= 25)) ) ) { // (experienced player)
                    if (modal_mode == -1) {
                      try {
                        modal_mode = 2;
                        // set modal content
                        modal.setContent("<div style='-webkit-touch-callout: none; /* iOS Safari */ -webkit-user-select: none; /* Safari */ -khtml-user-select: none; /* Konqueror HTML */ -moz-user-select: none; /* Firefox */ -ms-user-select: none; /* Internet Explorer/Edge */ user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */'>"
                                         + "<h2>You seem to be an experienced player!<br>Please enter your first name, it will be used to store your scores:</h2>"
                                         + "<h3>Your first name (between 3 and 12 letters, no spaces):</h3><input id='firstname_input' type='text' value='Sherlock?' maxlength='12'></input>"
                                         + "<h4>To store your future scores properly (with your first name), make sure that your browser does not clear cookies/site data when exited...<br>Close this dialog to skip this step</h4>"
                                         + "</div>");
                        // open modal
                        modal.open();
                        form_to_be_submitted = false; // form to be submitted when modal is closed
                      }
                      catch (exc) {
                        throw new Error("modal error (" + modal_mode + "):" + exc + ": " + exc.stack);
                      }
                    }
                  }
                }
              }

              console.log("(run completed)");

              if (form_to_be_submitted) {
                submitForm();
              }
              else {
                console.log("(form submission skipped)");
              }

            }, // run

            geolocation_retry: function (jqxhr, textStatus, error) {
              var errorStr = ("geolocation failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim();
              if (typeof(Storage) !== 'undefined') {
                if (localStorage.firstname) {
                  errorStr = errorStr + " for " + localStorage.firstname;
                }
                if (localStorage.firstaccessid) {
                  errorStr = errorStr + " for first access id " + localStorage.firstaccessid;
                }
                if (localStorage.countryname) {
                  errorStr = errorStr + " in " + localStorage.countryname;
                }
                if (localStorage.cityname) {
                  errorStr = errorStr + " in " + localStorage.cityname;
                }
                if (localStorage.gamesok) {
                  errorStr = errorStr + " after " + localStorage.gamesok + " game(s)";
                }
              }
              errorStr = errorStr + " |nbcolumns:" + nbcolumns + "|score:" + score + "|attempts:" + attempts + "|time:" + timestr;
              console.log(errorStr);
              // submitForm(errorStr, true); => skipped as this may be part of a frequent use case (*)
              geolocation_handler.first_geolocation_errorStr = errorStr;

              // Keep some time between the 2 potential calls to submitForm() -> no longer applicable (*)
              // This may also allow to make the 2nd getJSON in different mobile network conditions
              let now = new Date().getTime();
              while(new Date().getTime() < now + 111){}; // (interface is frozen during this short time)

              // Another geolocation server is used
              geolocation_handler.nb_JSON_queries_posted++;
              if (geolocation_handler.nb_JSON_queries_posted > 2) {
                console.log("error: too many recursive calls to run()! (#1)");
                return; // defense against infinite loops
              }
              $.getJSON('https://api.ipinfodb.com/v3/ip-city/?key=e61c60ef2fd204e654c2dbe9cd5f4d48c325e6b9ec666a9d76466fab576a9ce6&format=json', geolocation_handler.run_retry)
              .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
                var errorStr = ("geolocation retry failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim();
                let html_geoloc_already_done_str = "";
                if (typeof(Storage) !== 'undefined') {
                  if (localStorage.firstname) {
                    errorStr = errorStr + " for " + localStorage.firstname;
                  }
                  if (localStorage.firstaccessid) {
                    errorStr = errorStr + " for first access id " + localStorage.firstaccessid;
                  }
                  if (localStorage.countryname) {
                    errorStr = errorStr + " in " + localStorage.countryname;
                  }
                  if (localStorage.cityname) {
                    errorStr = errorStr + " in " + localStorage.cityname;
                  }
                  if (localStorage.gamesok) {
                    errorStr = errorStr + " after " + localStorage.gamesok + " game(s)";
                  }
                  if (localStorage.html_geoloc_already_done) {
                    html_geoloc_already_done_str = "|HTML geolocation status:" + localStorage.html_geoloc_already_done;
                  }
                }
                errorStr = errorStr + " |nbcolumns:" + nbcolumns + "|score:" + score + "|attempts:" + attempts + "|time:" + timestr + "|last_data_used_not_null:" + (last_data_used != null) + "|first_geolocation_error:" + geolocation_handler.first_geolocation_errorStr + html_geoloc_already_done_str + "|html_compatibility_game_version:" + html_compatibility_game_version;
                console.log(errorStr);

                // Reuse last (valid or not) geolocation data if any
                if (last_data_used != null) {
                  geolocation_handler.nb_JSON_queries_posted++;
                  console.log("reuse last (valid or not) geolocation data");
                  geolocation_handler.run(last_data_used);
                }
                else {
                  var fixed_ip_address = geolocation_handler.getIpAddressForIdentifiedUser();
                  if (fixed_ip_address != "") { // Identified user
                    geolocation_handler.nb_JSON_queries_posted++;
                    console.log("use fixed IP address: " + fixed_ip_address);
                    var fixed_data = {'ip':fixed_ip_address};
                    geolocation_handler.run(fixed_data);
                  }
                  else if ( (typeof(Storage) !== 'undefined')
                            && localStorage.automaticPositioning && localStorage.countryname && localStorage.regionname && localStorage.cityname ) { // Relevant location
                    geolocation_handler.nb_JSON_queries_posted++;
                    var sum = 0;
                    // regionname is used instead of cityname below to better identify unique players
                    // => one unique "geolocation retry failure" player is supported per region
                    for (var i = 0; i < localStorage.regionname.length; i++) {
                      sum = sum + localStorage.regionname.charCodeAt(i);
                    }
                    var inferred_ip_address = "2.2.2." + String(sum % 256);
                    console.log("use inferred IP address: " + inferred_ip_address);
                    var inferred_data = {'ip':inferred_ip_address};
                    geolocation_handler.run(inferred_data);
                  }
                  else { // No form is submitted in this retry failure case
                    var manualGeolocAttempt = false;
                    if (typeof(Storage) !== 'undefined') {
                      if (localStorage.gamesok) {
                        if ( (Number(localStorage.gamesok) >= 8) && ((Number(localStorage.gamesok) % 8) == 0) ) { // Subject to user acceptance => not done systematically because may prevent all future requests in case of initial rejection
                          manualGeolocAttempt = true;
                        }
                      }
                    }
                    if (manualGeolocAttempt) {
                      alert("If you accept to share your location, your country and city names will be used to store your score\nand you will also see all other players scores & rankings and in which countries and cities they played..."); // (duplicated line)
                    }
                    submitForm(errorStr, true);
                    if (manualGeolocAttempt) {
                      attempt_HTML_geolocation(true); // Subject to user acceptance
                    }
                  }
                }
              })
              .always(function() {
                console.log("(getJSON completed #2)");
              });
            }, // geolocation_retry

            getIpAddressForIdentifiedUser: function () { // "Reliable" users having played for a certain time, whose location is unknown and who did not want to share it
              if (typeof(Storage) !== 'undefined') {
                if (localStorage.firstaccessid) {
                  if (localStorage.firstaccessid.indexOf("FA - 0KQI0 - Fri Jan 12 2018") != -1) {
                    return "1.1.1.1"; // (unique fixed IP address)
                  }
                  /* else if (localStorage.firstaccessid.indexOf("FA - 8Q0RU - Wed Feb 07") != -1) {
                    return "1.1.1.2"; // (unique fixed IP address)
                  } */
                  // Note: "2.2.2.x" IP addresses shall not be used here, as used for another case
                }
                return "";
              }
              return "";
            },


          } // geolocation_handler

          geolocation_handler.nb_JSON_queries_posted++;
          if (geolocation_handler.nb_JSON_queries_posted > 2) {
            console.log("error: too many recursive calls to run()! (#2)");
            return; // defense against infinite loops
          }
          $.getJSON('https://api.ipdata.co/en?api-key=1b31a83f2dc4ead71542c7df3dc4850ce22fed68341a7f3b46ab67b2', geolocation_handler.run)
          .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
            geolocation_handler.geolocation_retry(jqxhr, textStatus, error);
          })
          .always(function() {
            console.log("(getJSON completed #1)");
          });

          console.log("(store player info exit)");

        }
        catch (exc) {
          console.log("internal error while storing scores: " + exc);
          if (nb_errors_submitted == 0) {
            // alert("Oops... an internal error occurred: " + exc);
            var errorStr = "";
            if (typeof(Storage) !== 'undefined') {
              if (localStorage.firstname) {
                errorStr = errorStr + " for " + localStorage.firstname;
              }
              if (localStorage.firstaccessid) {
                errorStr = errorStr + " for first access id " + localStorage.firstaccessid;
              }
            }
            errorStr = errorStr + " on " + navigator.platform + " / " + navigator.userAgent + " / " + decodeURI(location.href);
            submitForm("internal error while storing scores" + errorStr + ": " + exc, true);
            nb_errors_submitted++;
          }
        }

      } // store_player_info

      // ***********************
      // Handle page access info
      // ***********************

      var initial_time = new Date().getTime();
      function submitAccessForm(data, access_type, debug_info) {
        var final_time = new Date().getTime();
        if (final_time - initial_time > 999000) { // 15min+delta max - See (**)
          return;
        }
        var timeStr = String(Math.floor((final_time - initial_time)/1000));
        if (access_type.indexOf(" in") != -1) {
          timeStr = "";
        }
        var countryNameStr = "-";
        if ((data != null) && (typeof data.country_name != 'undefined')) {
          countryNameStr = String(data.country_name).trim();
        }
        var regionNameStr = "-";
        if ((data != null) && (typeof data.region != 'undefined')) {
          regionNameStr = String(data.region).trim();
        }
        var cityNameStr = "-";
        if ((data != null) && (typeof data.city != 'undefined')) {
          cityNameStr = String(data.city).trim();
        }
        var ipAddressStr = "-";
        if ((data != null) && (typeof data.ip != 'undefined')) {
          ipAddressStr = String(data.ip).trim();
        }
        var firstAccessIdStr = "-";
        if (typeof(Storage) !== 'undefined') {
          if (localStorage.firstaccessid) {
            firstAccessIdStr = localStorage.firstaccessid;
          }
        }
        var debugStr = "firstgeoloc:" + firstgamegeoloc + "/" + navigator.userAgent + "/initial: " + initial_time + "/final: " + final_time + "/debug_info:" + debug_info;
        var nbColorSelectionsStr = ((nbColorSelections == 0) ? "(-)" : "(" + String(nbColorSelections) + ")");
        submitForm('-&' + 'page=' + access_type + '&' + 'timeonpage=' + timeStr + '&' + 'country=' + countryNameStr + '&region=' + regionNameStr + '&city=' + cityNameStr + '&nbgameswon=' + ((nbGamesPlayedAndWon==0)?"-":String(nbGamesPlayedAndWon)) + '&nbgames=' + ((nbGamesPlayed==0)?"-":String(nbGamesPlayed)) + '&nbcodes=' + ((nbCodesPlayed==0)?"-":String(nbCodesPlayed)) + " " + nbColorSelectionsStr + '&ipaddress=' + ipAddressStr + '&firstaccessid=' + firstAccessIdStr + '&debug=' + debugStr, true, 111);
      }

      function storeFirstAccess(access_type, timeToWait1, timeToWait2, debug_info) {
        if (firstAccess) {
          // Keep some time between the 2 potential calls to submitAccessForm()
          let now = new Date().getTime();
          while(new Date().getTime() < now + timeToWait1){}; // (interface is frozen during this short time)
          if (last_data_used != null) {
            submitAccessForm(last_data_used, access_type, debug_info);
          }
          else {
            submitAccessForm(null, access_type, debug_info);
          }
          // Keep some time between the 2 potential calls to submitAccessForm()
          now = new Date().getTime();
          while(new Date().getTime() < now + timeToWait2){}; // (interface is frozen during this short time)
        }
      }

      function firstAccessGeolocFailure(jqxhr, textStatus, error) {
        var errorStr = ("first access geolocation failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim();
        console.log(errorStr);
        $.getJSON('https://api.ipinfodb.com/v3/ip-city/?key=e61c60ef2fd204e654c2dbe9cd5f4d48c325e6b9ec666a9d76466fab576a9ce6&format=json', function(data_p) {
          firstgamegeoloc = "fa2";
          /* ipinfodb.com response format:
             - SUCCESS case:
              statusCode	"OK"
              statusMessage	""
              ipAddress	"94.239.111.222"
              countryCode	"FR"
              countryName	"France"
              regionName	"Ile-de-France"
              cityName	"Paris"
              zipCode	"75000"
              latitude	"48.8534"
              longitude	"2.3488"
              timeZone	"+01:00"
            - FAILURE case:
              statusCode	"ERROR"
              statusMessage	"Invalid IP Address."
              ipAddress	"994.239.111.222"
              countryCode	""
              countryName	""
              regionName	""
              cityName	""
              zipCode	""
              latitude	"0"
              longitude	"0"
              timeZone	""
          */
          let converted_data = JSON.stringify(data_p);

          // latitude -> latitude
          // longitude -> longitude
          // countryName -> country_name
          converted_data = converted_data.replace("countryName", "country_name");
          // regionName -> region
          converted_data = converted_data.replace("regionName", "region");
          // cityName -> city
          converted_data = converted_data.replace("cityName", "city");
          // ipAddress -> ip
          converted_data = converted_data.replace("ipAddress", "ip");

          last_data_used = JSON.parse(converted_data);
          storeFirstAccess('game', 444, 444 /* (a too low value here will not work) */, 'debug-ok2');
        })
        .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
          firstgamegeoloc = "faerr2";
          var errorStr = ("first access geolocation retry failure: " + textStatus + " " + error + " " + str_from_jqxhr(jqxhr)).trim();
          console.log(errorStr);
          storeFirstAccess('game', 444, 444 /* (a too low value here will not work) */, 'debug-fail');
          // setTimeout("attempt_HTML_geolocation(false)", 25000); // Subject to user acceptance => not done because may prevent all future requests in case of initial rejection
        })
        .always(function() {
          console.log("(getJSON completed #i2)");
        });
      }

      if (firstAccess) {
        $.getJSON('https://api.ipdata.co/en?api-key=1b31a83f2dc4ead71542c7df3dc4850ce22fed68341a7f3b46ab67b2', function(data) {
          firstgamegeoloc = "fatmp1";
          last_data_used = data;
          if ( ((typeof data.ip != 'undefined') && (String(data.ip).trim().length >= 7 /* 0.0.0.0 */)) // (redundant lines)
               && ((typeof data.city != 'undefined') && (String(data.city).trim().length >= 3)) ) { // (redundant lines)
            firstgamegeoloc = "fa1";
            storeFirstAccess('game', 444, 444 /* (a too low value here will not work) */, 'debug-ok1');
          }
          else {
            firstgamegeoloc = "faerr1a";
            return firstAccessGeolocFailure("", "manual first access geolocation retry due to invalid geolocation data", "");
          }
        }) // to simplify, failure cases are not handled in a more complex way
        .fail(function(jqxhr, textStatus, error) { // (jqxhr: XMLHTTPRequest)
          firstgamegeoloc = "faerr1b";
          firstAccessGeolocFailure(jqxhr, textStatus, error);
        })
        .always(function() {
          console.log("(getJSON completed #i1)");
        });

        setTimeout("storeFirstAccess('game', 0, 0, 'debug-ini')",        44);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-5s')",       5000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-10s')",     10000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-15s')",     15000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-20s')",     20000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-30s')",     30000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-40s')",     40000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-50s')",     50000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-1min')",    60000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-1min30')",  90000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-2min')",   120000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-2min30')", 150000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-3min')",   180000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-4min')",   240000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-5min')",   300000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-10min')",  600000);
        setTimeout("storeFirstAccess('game', 0, 0, 'debug-15min')",  900000); // See (**)
      }

    </script>

    <p id='traces_id' style='color:#AAAAAA;'></p>

    <!-- Load GameSolver worker script -->
    
    <script id='gamesolver_id' type='javascript/worker'>
    
      // ***********************************************************************************************
      // IMPORTANT NOTE: this script won't be parsed by JS engines because its type is javascript/worker
      // ***********************************************************************************************
      
      // ******************************
      // GameSolver worker code - start
      // ******************************

      "use strict";

      try {

        // *************************************************************************
        // *************************************************************************
        // Global variables
        // *************************************************************************
        // *************************************************************************

        let emptyColor = 0; // (0 is also the Java default table init value)
        let nbMinColors = 5;
        let nbMaxColors = 10;
        let nbMinColumns = 3;
        let nbMaxColumns = 7;
        let overallNbMinAttempts = 4;
        let overallNbMaxAttempts = 16;
        let overallMaxDepth = 16;

        let init_done = false;
        let nbColumns = -1;
        let nbColors = -1;
        let nbMaxAttempts = -1;
        let nbMaxPossibleCodesShown = -1;
        let possibleCodesShown;
        let globalPerformancesShown;
        let game_id = -1;

        let codesPlayed;
        let marks;

        let codeHandler;

        let initialNbPossibleCodes = -1;
        let previousNbOfPossibleCodes = -1;
        let nextNbOfPossibleCodes = -1;

        let colorsFoundCode = -1;
        let minNbColorsTable;
        let maxNbColorsTable;
        let nbColorsTableForMinMaxNbColors;

        let nbMaxMarks = -1;
        let marksTable_MarkToNb;
        let marksTable_NbToMark;
        let best_mark_idx;
        let worst_mark_idx;

        let possibleCodesAfterNAttempts;

        let curAttemptNumber = 0;
        let nbMaxAttemptsForEndOfGame = -1;
        let message_processing_ongoing = false;
        let IAmAliveMessageSent = false;

        let abort_worker_process = false;

        // Performance-related variables
        // *****************************

        let baseOfMaxPerformanceEvaluationTime = 30000; // 30 seconds / much higher in (precalculation mode)
        let maxPerformanceEvaluationTime = -1;

        let refNbOfCodesForSystematicEvaluation = 1500; // (high values may induce latencies)
        let nbOfCodesForSystematicEvaluation = -1;
        let nbOfCodesForSystematicEvaluation_ForMemAlloc = -1;

        let initialNbClasses = -1;
        let curNbClasses = -1;

        let possibleCodesForPerfEvaluation;
        // let initialCodeListForPrecalculatedMode; // (precalculation mode)
        let possibleCodesForPerfEvaluation_lastIndexWritten = -1;
        let mem_reduc_factor = 0.90; // (too low values can lead to dynamic memory allocations)
        let maxDepth = -1;
        let maxDepthApplied = -1;
        let marks_optimization_mask;

        let performanceListsInitDone = false;
        let performanceListsInitDoneForPrecalculatedGames = false;
        let arraySizeAtInit = -1;
        let listOfGlobalPerformances;
        let listsOfPossibleCodes;
        let nbOfPossibleCodes;
        let listOfClassesFirstCall;
        let nbOfClassesFirstCall = -1;
        let listOfEquivalentCodesAndPerformances;
        let marks_already_computed_table = null;
        let nbCodesLimitForEquivalentCodesCheck = 40; // (value determined empirically)

        let PerformanceNA = -3.00; // (duplicated in SuperMasterMind.js)
        let PerformanceUNKNOWN = -2.00; // (duplicated in SuperMasterMind.js)
        let PerformanceMinValidValue = -1.30; // (a valid relative performance can be < -1.00 in some extremely rare cases - duplicated in SuperMasterMind.js)
        let PerformanceMaxValidValue = +1.30; // (a valid relative performance can be > 0.00 in some rare (impossible code) cases - duplicated in SuperMasterMind.js) / Some values observed: +0.94 for 5-colmuns game {4B0W 11223; 11456}, +1.04 for 6-colmuns game {5B0W 112234; 112567}

        let initialInitDone = false;
        let curGame;
        let curGameSize;
        let marksIdxs;
        let all_permutations_table_size;
        let all_permutations_table;
        let cur_permutations_table_size = 0;
        let cur_permutations_table;

       // *************************************************************************
        // *************************************************************************
        // Game precalculation
        // *************************************************************************
        // *************************************************************************

        let minNbCodesForPrecalculation = 270;
        let nbCodesForPrecalculationThreshold = Math.max(refNbOfCodesForSystematicEvaluation, minNbCodesForPrecalculation); // (shall be in [minNbCodesForPrecalculation, refNbOfCodesForSystematicEvaluation])

        let maxDepthForGamePrecalculation = -1; // (-1 or 3)
        let maxDepthForGamePrecalculation_ForMemAlloc = 10;
        let curGameForGamePrecalculation = new Array(maxDepthForGamePrecalculation_ForMemAlloc);
        curGameForGamePrecalculation.fill(0); // empty code
        let marksIdxsForGamePrecalculation = new Array(maxDepthForGamePrecalculation_ForMemAlloc);
        marksIdxsForGamePrecalculation.fill(-1);

        let precalculation_mode_mark = {nbBlacks:0, nbWhites:0};

        // ***************************************************************************************************************
        // Precalculated table for 4 columns
        // for minNbCodesForPrecalculation = 300, nbCodesForPrecalculationThreshold = 1296, precalculation_time >= 3.5 sec
        // ***************************************************************************************************************

        let precalculated_games_4columns =
          "0||N:1296|1111:13C7,1112:11C8,1122:1168,1123:110C,1234:115F.";

        // ***************************************************************************************************************
        // Precalculated table for 5 columns
        // ***************************************************************************************************************

        let precalculated_games_5columns =
          "0||N:32768|11111:28B03,11112:25A19,11122:24BF0,11123:24501,11223:23ED9,11234:23F55,12345:244BA.";

        // **************
        // Error handling
        // **************

        self.onerror = function (e) {
          self.postMessage({'rsp_type': 'INTERNAL_WORKER_ERROR_DETECTED', 'error_str': e + ", " + e.data + ", " + e.message + " (" + e.filename + ":" + e.lineno + ")"}); // (attempt to include all potential fields)
        };
        self.onmessageerror = function (e) {
          self.postMessage({'rsp_type': 'INTERNAL_WORKER_MESSAGE_ERROR_DETECTED', 'error_str': e + ", " + e.data + ", " + e.message + " (" + e.filename + ":" + e.lineno + ")"}); // (attempt to include all potential fields)
        };

        // ***************************
        // Look for precalculated game
        // ***************************

        let dotStr = ".";
        let separatorStr = "|";
        let separator2Str = ":";
        let separator3Str = ",";
        let nbCodesPrefixStr = "N:";
        let precalculated_mark = {nbBlacks:0, nbWhites:0};
        // Returned value:
        // - > 0 if both game and code were precalculated
        // - 0 if only game was precalculated
        // - -1 if nothing was precalculated
        function lookForCodeInPrecalculatedGames(code_p, cur_game_size, nb_possible_codes_p) {

          if (cur_game_size > maxDepthForGamePrecalculation) {
            throw new Error("lookForCodeInPrecalculatedGames: invalid game size: " + cur_game_size);
          }

          let precalculated_games;
          switch (nbColumns) {
            case 4:
              precalculated_games = precalculated_games_4columns;
              break;
            case 5:
              precalculated_games = precalculated_games_5columns;
              break;
            default:
              throw new Error("lookForCodeInPrecalculatedGames: invalid nbColumns value: " + nbColumns);
          }

          let dot_index = 0;
          let last_dot_index = 0;
          while ((dot_index = precalculated_games.indexOf(dotStr, last_dot_index)) != -1) {
            let line_str = precalculated_games.substring(last_dot_index, dot_index+1);
            let last_line_str_index = dot_index - last_dot_index;

            // Parse precalculated depth
            // *************************

            let separator_index1 = line_str.indexOf(separatorStr);
            let depth = Number(line_str.substring(0, separator_index1));
            if ((separator_index1 == -1) || isNaN(depth) || (depth < 0) || (depth > maxDepthForGamePrecalculation)) {
              throw new Error("lookForCodeInPrecalculatedGames: invalid depth: " + depth);
            }
            if (depth != cur_game_size) {
              // End of loop processing
              last_dot_index = dot_index+1;
              continue;
            }

            // Parse precalculated game
            // ************************

            let last_separator_index = separator_index1+1;
            if (cur_game_size == 0) {
              last_separator_index++;
            }
            else {
              for (let i = 0; i < cur_game_size; i++) {
                // Precalculated code
                let separator_index2 = line_str.indexOf(separator2Str, last_separator_index);
                let code_str = line_str.substring(last_separator_index, separator_index2);
                let code = codeHandler.uncompressStringToCode(code_str);
                // Precalculated mark
                let separator_index3 = line_str.indexOf(separatorStr, separator_index2+1);
                let mark_str = line_str.substring(separator_index2+1, separator_index3);
                codeHandler.stringToMark(mark_str, precalculated_mark);

                curGameForGamePrecalculation[i] = code;
                marksIdxsForGamePrecalculation[i] = marksTable_MarkToNb[precalculated_mark.nbBlacks][precalculated_mark.nbWhites];

                last_separator_index = separator_index3+1;
              }
            }

            // Check marks equivalence
            // ***********************

            let areAllMarksEqual = true;
            for (let i = 0; i < cur_game_size; i++) {
              if (marksIdxs[i] != marksIdxsForGamePrecalculation[i]) {
                areAllMarksEqual = false;
                break;
              }
            }
            if (!areAllMarksEqual) {
              // End of loop processing
              last_dot_index = dot_index+1;
              continue;
            }

            // Check game equivalence
            // **********************

            if (!areCodesEquivalent(0, 0, cur_game_size, true, -1 /* N.A. */, curGameForGamePrecalculation)) {
              // End of loop processing
              last_dot_index = dot_index+1;
              continue;
            }

            // Parse number of possible codes
            // ******************************

            let separator_index4 = line_str.indexOf(separatorStr, last_separator_index);
            let nb_possible_codes_str = line_str.substring(last_separator_index, separator_index4);
            if ((separator_index4 == -1) || (nb_possible_codes_str.indexOf(nbCodesPrefixStr) != 0)) {
              throw new Error("lookForCodeInPrecalculatedGames: invalid number of possible codes (1): " + nb_possible_codes_str);
            }
            nb_possible_codes_str = nb_possible_codes_str.substring(nbCodesPrefixStr.length);
            let nb_possible_codes = Number(nb_possible_codes_str);
            if (isNaN(nb_possible_codes) || (nb_possible_codes <= 0) || (nb_possible_codes > initialNbPossibleCodes)) {
              throw new Error("lookForCodeInPrecalculatedGames: invalid number of possible codes (2): " + nb_possible_codes_str);
            }
            if (nb_possible_codes <= nbCodesLimitForEquivalentCodesCheck) {
              throw new Error("lookForCodeInPrecalculatedGames: too low number of possible codes: " + nb_possible_codes_str);
            }
            if (nb_possible_codes != nb_possible_codes_p) {
              throw new Error("lookForCodeInPrecalculatedGames: invalid numbers of possible codes: " + nb_possible_codes + ", " + nb_possible_codes_p);
            }
            // console.log(nb_possible_codes);

            // Parse precalculated codes
            // *************************

            let last_end_of_code_perf_pair_index = separator_index4+1;
            while (true) {
              let middle_of_code_perf_pair_index = line_str.indexOf(separator2Str, last_end_of_code_perf_pair_index);
              if (middle_of_code_perf_pair_index == -1) {
                throw new Error("lookForCodeInPrecalculatedGames: inconsistent code and perf pair: " + line_str);
              }

              // Precalculated code
              let code_str = line_str.substring(last_end_of_code_perf_pair_index, middle_of_code_perf_pair_index);
              let code = codeHandler.uncompressStringToCode(code_str);

              // Precalculated sum
              let separator_index5 = line_str.indexOf(separator3Str, middle_of_code_perf_pair_index+1);
              if (separator_index5 == -1) {
                separator_index5 = line_str.indexOf(dotStr, middle_of_code_perf_pair_index+1);
                if (separator_index5 != last_line_str_index) {
                  throw new Error("lookForCodeInPrecalculatedGames: inconsistent end of line: " + separator_index5 + ", " + last_line_str_index);
                }
              }
              let sum_str = line_str.substring(middle_of_code_perf_pair_index+1, separator_index5);
              let sum = Number("0x" + sum_str); // (hexa number parsing)
              if (isNaN(sum) || (sum <= 0)) {
                throw new Error("lookForCodeInPrecalculatedGames: invalid sum: " + sum_str);
              }
              // console.log(codeHandler.codeToString(code) + ":" + sum + ",");

              // Check global game + code equivalence
              // console.log("assessed: " + compressed_str_from_lists_of_codes_and_markidxs(curGameForGamePrecalculation, marksIdxsForGamePrecalculation, cur_game_size) + " for code "  + codeHandler.codeToString(code));
              // console.log(" versus " + str_from_list_of_codes(curGame, cur_game_size) + " for code " + codeHandler.codeToString(code_p));
              if (areCodesEquivalent(code_p, code /* (shall be in second parameter) */, cur_game_size, false, -1 /* N.A. */, curGameForGamePrecalculation)) {
                // console.log("precalculated game found: " + compressed_str_from_lists_of_codes_and_markidxs(curGameForGamePrecalculation, marksIdxsForGamePrecalculation, cur_game_size));
                return sum; // both game and code were precalculated - precalculated sum found
              }

              // End of loop processing
              if (separator_index5 >= last_line_str_index) {
                break;
              }
              last_end_of_code_perf_pair_index = separator_index5+1;
            }

            // End of loop processing
            last_dot_index = dot_index+1;
            return 0; // only game was precalculated - no precalculated sum found

          } // end while

          return -1; // nothing was precalculated - no precalculated sum found

        }

        // *************************************************************************
        // *************************************************************************
        // Classes
        // *************************************************************************
        // *************************************************************************

        // ********************************************************************************************************
        // OptimizedArrayInternalList class (used by OptimizedArrayList)
        // ********************************************************************************************************
        class OptimizedArrayInternalList {
          constructor(granularity_p) {
            this.list = new Array(granularity_p);
          }
        }

        // **********************************************************************************************************
        // OptimizedArrayList class: "ArrayList" of non-null integers optimized in terms of performances and memory.
        // A classical use case of this class is the handling of a memory buffer whose size is significantly flexible
        // (dynamic memory allocation instead of static allocation).
        // **********************************************************************************************************
        let nb_max_internal_lists = 100; // (100 means a 1% memory allocation flexibility)
        class OptimizedArrayList {

          constructor(granularity_p) {
            if (granularity_p < 5*nb_max_internal_lists)  {
              throw new Error("OptimizedArrayList: invalid granularity: " + granularity_p);
            }

            this.granularity = granularity_p;
            this.nb_elements = 0;
            this.cur_add_list_idx = 0;
            this.cur_add_idx = 0;
            this.cur_get_list_idx = 0;
            this.cur_get_idx = 0;
            this.internal_lists = new Array(nb_max_internal_lists);
            this.internal_lists[0] = new OptimizedArrayInternalList(this.granularity);
          }

          clear() {
            this.nb_elements = 0;
            this.cur_add_list_idx = 0;
            this.cur_add_idx = 0;
            this.cur_get_list_idx = 0;
            this.cur_get_idx = 0;
            // Memory is not freed explicitly (no "this.internal_lists[x] = null" (or "this.internal_lists[x].list[y] = null": N.A. for int type))
            // => the tables allocated in memory will thus be reusable, which can fasten the processes
          }

          free() {
            this.nb_elements = 0;
            this.cur_add_list_idx = 0;
            this.cur_add_idx = 0;
            this.cur_get_list_idx = 0;
            this.cur_get_idx = 0;
            // Memory is freed
            for (let list_idx = 0; list_idx < nb_max_internal_lists; list_idx++) {
              this.internal_lists[list_idx] = null; // (help garbage collector)
            }
            this.internal_lists = null; // (help garbage collector)
          }

          getNbElements() {
            return this.nb_elements;
          }

          add(value) {

            // Add element
            this.internal_lists[this.cur_add_list_idx].list[this.cur_add_idx] = value;
            this.nb_elements++;

            // Prepare next add
            if (this.cur_add_idx < this.granularity-1) {
              this.cur_add_idx++;
            }
            else {
              if (this.cur_add_list_idx >= nb_max_internal_lists-1) {
                throw new Error("OptimizedArrayList: array is full");
              }
              this.cur_add_list_idx++;
              if (this.internal_lists[this.cur_add_list_idx] == null) {
                this.internal_lists[this.cur_add_list_idx] = new OptimizedArrayInternalList(this.granularity);
              }
              this.cur_add_idx = 0;
            }

          }

          resetGetIterator() {
            this.cur_get_list_idx = 0;
            this.cur_get_idx = 0;
          }

          getNextElement(goToNext) {

            // Get next element
            if ( (this.cur_get_list_idx < this.cur_add_list_idx)
                 || ( (this.cur_get_list_idx == this.cur_add_list_idx) && (this.cur_get_idx < this.cur_add_idx) ) ) {

              let value = this.internal_lists[this.cur_get_list_idx].list[this.cur_get_idx];

              // Prepare next get
              if (goToNext) {
                if (this.cur_get_idx < this.granularity-1) {
                  this.cur_get_idx++;
                }
                else {
                  this.cur_get_list_idx++;
                  this.cur_get_idx = 0;
                }
              }

              if (value == 0) {
                throw new Error("OptimizedArrayList: getNextElement inconsistency");
              }
              return value;

            }
            else {
              return 0;
            }

          }

          replaceNextElement(value_ini_p, value_p) {

            if ( (value_ini_p == 0) || (value_p == 0) ) {
              throw new Error("OptimizedArrayList: replaceNextElement: invalid parameter (" + value_ini_p + "," + value_p + ")");
            }

            // Replace next element
            if ( (this.cur_get_list_idx < this.cur_add_list_idx)
                 || ( (this.cur_get_list_idx == this.cur_add_list_idx) && (this.cur_get_idx < this.cur_add_idx) ) ) {

              let value = this.internal_lists[this.cur_get_list_idx].list[this.cur_get_idx];
              if (value != value_ini_p) {
                throw new Error("OptimizedArrayList: replaceNextElement inconsistency (" + value + "," + value_ini_p + ")");
              }

              // Replace
              this.internal_lists[this.cur_get_list_idx].list[this.cur_get_idx] = value_p;

              // Prepare next get
              if (this.cur_get_idx < this.granularity-1) {
                this.cur_get_idx++;
              }
              else {
                this.cur_get_list_idx++;
                this.cur_get_idx = 0;
              }

            }
            else {
              throw new Error("OptimizedArrayList: replaceNextElement inconsistency");
            }

          }

        }

        // *************************************************************************
        // Code handler class
        // *************************************************************************

        class CodeHandler { // NOTE: the code of this class is partially duplicated in SuperMasterMind.js script

          constructor(nbColumns_p, nbColors_p, nbMinColumns_p, nbMaxColumns_p, emptyColor_p) {
            if ( (nbColumns_p < Math.max(nbMinColumns_p,3)) || (nbColumns_p > Math.min(nbMaxColumns_p,7)) /* 3 and 7 is hardcoded in some methods of this class for better performances */ ) {
              throw new Error("CodeHandler: invalid nb of columns (" + nbColumns_p + ", " + nbMinColumns_p + "," + nbMaxColumns_p + ")");
            }
            if (nbColors_p < 0) {
              throw new Error("CodeHandler: invalid nb of colors: (" + nbColors_p + ")");
            }
            this.nbColumns = nbColumns_p;
            this.nbColors = nbColors_p;
            this.nbMaxColumns = nbMaxColumns_p;
            this.emptyColor = emptyColor_p;

            this.code1_colors = new Array(this.nbMaxColumns);
            this.code2_colors = new Array(this.nbMaxColumns);
            this.colors_int = new Array(this.nbMaxColumns);

            this.different_colors = new Array(this.nbColors+1)
          }

          getNbColumns() {
            return this.nbColumns;
          }

          getColor(code, column) {
            switch (column) {
              case 1:
                return (code & 0x0000000F);
              case 2:
                return ((code >> 4) & 0x0000000F);
              case 3:
                return ((code >> 8) & 0x0000000F);
              case 4:
                return ((code >> 12) & 0x0000000F);
              case 5:
                return ((code >> 16) & 0x0000000F);
              case 6:
                return ((code >> 20) & 0x0000000F);
              case 7:
                return ((code >> 24) & 0x0000000F);
              default:
                throw new Error("CodeHandler: getColor (" + column + ")");
            }
          }

          setColor(code, color, column)  {
            switch (column) {
              case 1:
                return ((code & 0xFFFFFFF0) | color);
              case 2:
                return ((code & 0xFFFFFF0F) | (color << 4));
              case 3:
                return ((code & 0xFFFFF0FF) | (color << 8));
              case 4:
                return ((code & 0xFFFF0FFF) | (color << 12));
              case 5:
                return ((code & 0xFFF0FFFF) | (color << 16));
              case 6:
                return ((code & 0xFF0FFFFF) | (color << 20));
              case 7:
                return ((code & 0xF0FFFFFF) | (color << 24));
              default:
                throw new Error("CodeHandler: setColor (" + column + ")");
            }
          }

          setAllColors(color1, color2, color3, color4, color5, color6, color7) {
            return color1
                   | (color2 << 4)
                   | (color3 << 8)
                   | (color4 << 12)
                   | (color5 << 16)
                   | (color6 << 20)
                   | (color7 << 24);
          }

          setAllColorsIdentical(color) {
            let res_code = 0;
            for (let col = 0; col < this.nbColumns; col++) {
              res_code = this.setColor(res_code, color, col+1);
            }
            return res_code;
          }

          nbDifferentColors(code) {
            let sum = 0;
            this.different_colors.fill(0);
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              if (this.different_colors[color] == 0) {
                this.different_colors[color] = 1;
                sum = sum + 1;
              }
            }
            return sum;
          }

          isVerySimple(code) {
            this.different_colors.fill(0);
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              this.different_colors[color]++;
            }
            for (let color = 0; color <= this.nbColors; color++) {
              if (this.different_colors[color] == this.nbColumns) {
                return true; // "111...1" like codes
              }
              else if (this.different_colors[color] == this.nbColumns - 1) {
                return true; // "122...2" like codes
              }
            }
            return false;
          }

          codeToString(code) {
            let res = "[ ";
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              res = res + color + " ";
            }
            res = res + "]";
            return res;
          }

          compressCodeToString(code) {
            let res = "";
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              res = res + color.toString(16).toUpperCase(); // (hexa number used if >= 10)
            }
            return res;
          }

          uncompressStringToCode(str) {
            let code = 0; // empty code
            if (str.length != this.nbColumns) {
              throw new Error("CodeHandler: uncompressStringToCode (1) (" + str + ")");
            }
            for (let col = 0; col < this.nbColumns; col++) {
              let color = Number("0x" + str.substring(col, col+1)); // (hexa number parsing)
              code = this.setColor(code, color, col+1);
            }
            if (!this.isFullAndValid(code)) {
              throw new Error("CodeHandler: uncompressStringToCode (2) (" + str + ")");
            }
            return code;
          }

          createRandomCode() {
            let code = 0;
            for (let col = 0; col < this.nbColumns; col++) {
              code = this.setColor(code, Math.floor((Math.random() * this.nbColors) + 1), col+1);
            }
            return code;
          }

          isValid(code) {
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              if ( ((color < 1) || (color > this.nbColors))
                   && (color != this.emptyColor) ) {
                return false;
              }
            }
            for (let col = this.nbColumns+1; col <= this.nbMaxColumns; col++) {
              let color = this.getColor(code, col);
              if (color != this.emptyColor) {
                return false;
              }
            }
            return true;
          }

          isFullAndValid(code) {
            for (let col = 0; col < this.nbColumns; col++) {
              let color = this.getColor(code, col+1);
              if ( (color < 1) || (color > this.nbColors)
                   || (color == this.emptyColor) ) {
                return false;
              }
            }
            for (let col = this.nbColumns+1; col <= this.nbMaxColumns; col++) {
              let color = this.getColor(code, col);
              if (color != this.emptyColor) {
                return false;
              }
            }
            return true;
          }

          nbEmptyColors(code) {
            let cnt = 0;
            for (let col = 0; col < this.nbColumns; col++) {
              if (this.getColor(code, col+1) == this.emptyColor) {
                cnt++;
              }
            }
            return cnt;
          }

          isEmpty(code) {
            return (code == 0); // only emptyColor in the code
          }

          replaceEmptyColor(code, emptyColorIdx, code2) {
            let cnt = 0;
            for (let col = 0; col < this.nbColumns; col++) {
              if (this.getColor(code, col+1) == this.emptyColor) {
                if (cnt == emptyColorIdx) {
                  return this.setColor(code, this.getColor(code2, col+1), col+1);
                }
                cnt++;
              }
            }
            return code;
          }

          // Get a mark between 2 codes
          getMark(code1, code2) {
            let mark = {nbBlacks:0, nbWhites:0};
            this.fillMark(code1, code2, mark);
            return mark;
          }

          // Fill a mark between 2 codes in a fast way
          fillMark(code1, code2, mark) { // (duplicated code)

            let marks_already_computed_table_cell;
            let codeX;
            let codeY;

            // Marks optimization (1/2) - begin
            // Notes: - Hash key computing shall be symetrical wrt code1 and code2 and very fast.
            //        - Bit operations are done on 32 bits in javascript (so for example 'x >> y', with x > 0 on 64 bits, may be negative).
            //        - The final hash key will anyway always be in the range [0, marks_optimization_mask] after bit mask application with the '&' operator.

            let sum_codes = code1 + code2;
            let key = ( (sum_codes /* (use LSBs) */
                        + (sum_codes >> 9) /* (use MSBs) */
                        + code1 * code2 /* (mix LSBs) */) & marks_optimization_mask ); // (duplicated code)
            marks_already_computed_table_cell = marks_already_computed_table[key];
            codeX = marks_already_computed_table_cell.code1a;
            codeY = marks_already_computed_table_cell.code2a;
            if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
              mark.nbBlacks = marks_already_computed_table_cell.nbBlacksa;
              mark.nbWhites = marks_already_computed_table_cell.nbWhitesa;
            }
            else {
              codeX = marks_already_computed_table_cell.code1b;
              codeY = marks_already_computed_table_cell.code2b;
              if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
                mark.nbBlacks = marks_already_computed_table_cell.nbBlacksb;
                mark.nbWhites = marks_already_computed_table_cell.nbWhitesb;
              }
              else {
                codeX = marks_already_computed_table_cell.code1c;
                codeY = marks_already_computed_table_cell.code2c;
                if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
                  mark.nbBlacks = marks_already_computed_table_cell.nbBlacksc;
                  mark.nbWhites = marks_already_computed_table_cell.nbWhitesc;
                }
                // Marks optimization (1/2) - end
                else {
                  let nbBlacks = 0;
                  let nbWhites = 0;
                  let col1, col2;

                  // The below operations are unrolled for better performances
                  this.colors_int[0] = true;
                  this.colors_int[1] = true;
                  this.colors_int[2] = true;
                  this.colors_int[3] = true;
                  this.colors_int[4] = true;
                  this.colors_int[5] = true;
                  this.colors_int[6] = true;
                  this.code1_colors[0] = (code1 & 0x0000000F);
                  this.code1_colors[1] = ((code1 >> 4) & 0x0000000F);
                  this.code1_colors[2] = ((code1 >> 8) & 0x0000000F);
                  this.code1_colors[3] = ((code1 >> 12) & 0x0000000F);
                  this.code1_colors[4] = ((code1 >> 16) & 0x0000000F);
                  this.code1_colors[5] = ((code1 >> 20) & 0x0000000F);
                  this.code1_colors[6] = ((code1 >> 24) & 0x0000000F);
                  this.code2_colors[0] = (code2 & 0x0000000F);
                  this.code2_colors[1] = ((code2 >> 4) & 0x0000000F);
                  this.code2_colors[2] = ((code2 >> 8) & 0x0000000F);
                  this.code2_colors[3] = ((code2 >> 12) & 0x0000000F);
                  this.code2_colors[4] = ((code2 >> 16) & 0x0000000F);
                  this.code2_colors[5] = ((code2 >> 20) & 0x0000000F);
                  this.code2_colors[6] = ((code2 >> 24) & 0x0000000F);

                  for (col1 = 0; col1 < this.nbColumns; col1++) {
                    if (this.code1_colors[col1] == this.code2_colors[col1]) {
                      nbBlacks++;
                    }
                    else {
                      for (col2 = 0; col2 < this.nbColumns; col2++) {
                        if ((this.code1_colors[col1] == this.code2_colors[col2]) && (this.code1_colors[col2] != this.code2_colors[col2]) && this.colors_int[col2]) {
                          this.colors_int[col2] = false;
                          nbWhites++;
                          break;
                        }
                      }
                    }
                  }

                  mark.nbBlacks = nbBlacks;
                  mark.nbWhites = nbWhites;

                  // Marks optimization (2/2) - begin
                  if (marks_already_computed_table_cell.write_index == 0) {
                    marks_already_computed_table_cell.code1a = code1;
                    marks_already_computed_table_cell.code2a = code2;
                    marks_already_computed_table_cell.nbBlacksa = nbBlacks;
                    marks_already_computed_table_cell.nbWhitesa = nbWhites;
                    marks_already_computed_table_cell.write_index = 1;
                  }
                  else if (marks_already_computed_table_cell.write_index == 1) {
                    marks_already_computed_table_cell.code1b = code1;
                    marks_already_computed_table_cell.code2b = code2;
                    marks_already_computed_table_cell.nbBlacksb = nbBlacks;
                    marks_already_computed_table_cell.nbWhitesb = nbWhites;
                    marks_already_computed_table_cell.write_index = 2;
                  }
                  else if (marks_already_computed_table_cell.write_index == 2) {
                    marks_already_computed_table_cell.code1c = code1;
                    marks_already_computed_table_cell.code2c = code2;
                    marks_already_computed_table_cell.nbBlacksc = nbBlacks;
                    marks_already_computed_table_cell.nbWhitesc = nbWhites;
                    marks_already_computed_table_cell.write_index = 0;
                  }
                  else {
                    throw new Error("CodeHandler: fillMark (wrong write_index: " + marks_already_computed_table_cell.write_index + ")");
                  }
                  // Marks optimization (2/2) - end
                }
              }
            }

          }

          marksEqual(mark1, mark2) {
            return ( (mark1.nbBlacks == mark2.nbBlacks) && (mark1.nbWhites == mark2.nbWhites) );
          }

          isMarkValid(mark) {
            if ( (mark.nbBlacks >= 0) && (mark.nbWhites >= 0) && (mark.nbBlacks + mark.nbWhites <= this.nbColumns)
                 && !((mark.nbBlacks == this.nbColumns - 1) && (mark.nbWhites == 1)) ) {
              return true;
            }
            return false;
          }

          markToString(mark) {
            return mark.nbBlacks + "B" + mark.nbWhites + "W";
          }

          stringToMark(str, mark) {
            if (str.length != 4) {
              throw new Error("CodeHandler: stringToMark (1) (" + str + ")");
            }
            let index_blacks = str.indexOf("B");
            if (index_blacks != 1) {
              throw new Error("CodeHandler: stringToMark (2) (" + str + ")");
            }
            let index_whites = str.indexOf("W", index_blacks);
            if (index_whites != 3) {
              throw new Error("CodeHandler: stringToMark (3) (" + str + ")");
            }
            mark.nbBlacks = Number(str.substring(0,1));
            mark.nbWhites = Number(str.substring(2,3));
            if (!codeHandler.isMarkValid(mark)) {
              throw new Error("CodeHandler: stringToMark (4) (" + str + ")");
            }
          }

        }

        // *************************************************************************
        // *************************************************************************
        // Functions
        // *************************************************************************
        // *************************************************************************

        // **********************************
        // Check if a code played is possible
        // **********************************

        function isAttemptPossibleinGameSolver(attempt_nb) { // (returns 0 if the attempt_nb th code is possible, returns the first attempt number with which there is a contradiction otherwise)
          if ( (attempt_nb <= 0) || (attempt_nb > curAttemptNumber) ) {
            throw new Error("isAttemptPossibleinGameSolver: invalid attempt_nb " + attempt_nb + ", " + curAttemptNumber);
            return 1;
          }
          let mark_tmp = {nbBlacks:0, nbWhites:0};
          for (let i = 1; i <= attempt_nb-1; i++) { // go through all codes previously played
            codeHandler.fillMark(codesPlayed[attempt_nb-1], codesPlayed[i-1], mark_tmp);
            if (!codeHandler.marksEqual(mark_tmp, marks[i-1])) {
              return i;
            }
          }
          return 0;
        }

        // *****************************************
        // Fill a short initial possible codes table
        // *****************************************

        function fillShortInitialPossibleCodesTable(table, size_to_fill) {

          let code_tmp = 0;
          let cnt = 0;

          if (size_to_fill > table.length) {
            throw new Error("fillShortInitialPossibleCodesTable: table size is too low: " + size_to_fill + ", " + table.length);
          }

          switch (nbColumns) {

            case 3:

              for (let color1 = 1; color1 <= nbColors; color1++) {
                for (let color2 = 1; color2 <= nbColors; color2++) {
                  for (let color3 = 1; color3 <= nbColors; color3++) {
                    code_tmp = codeHandler.setAllColors(color1, color2, color3, emptyColor, emptyColor, emptyColor, emptyColor);
                    table[cnt] = code_tmp;
                    cnt++;
                    if (cnt >= size_to_fill) return cnt;
                  }
                }
              }
              break;

            case 4:

              for (let color1 = 1; color1 <= nbColors; color1++) {
                for (let color2 = 1; color2 <= nbColors; color2++) {
                  for (let color3 = 1; color3 <= nbColors; color3++) {
                    for (let color4 = 1; color4 <= nbColors; color4++) {
                      code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, emptyColor, emptyColor, emptyColor);
                      table[cnt] = code_tmp;
                      cnt++;
                      if (cnt >= size_to_fill) return cnt;
                    }
                  }
                }
              }
              break;

            case 5:

              for (let color1 = 1; color1 <= nbColors; color1++) {
                for (let color2 = 1; color2 <= nbColors; color2++) {
                  for (let color3 = 1; color3 <= nbColors; color3++) {
                    for (let color4 = 1; color4 <= nbColors; color4++) {
                      for (let color5 = 1; color5 <= nbColors; color5++) {
                        code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, emptyColor, emptyColor);
                        table[cnt] = code_tmp;
                        cnt++;
                        if (cnt >= size_to_fill) return cnt;
                      }
                    }
                  }
                }
              }
              break;

            case 6:

              for (let color1 = 1; color1 <= nbColors; color1++) {
                for (let color2 = 1; color2 <= nbColors; color2++) {
                  for (let color3 = 1; color3 <= nbColors; color3++) {
                    for (let color4 = 1; color4 <= nbColors; color4++) {
                      for (let color5 = 1; color5 <= nbColors; color5++) {
                        for (let color6 = 1; color6 <= nbColors; color6++) {
                          code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, color6, emptyColor);
                          table[cnt] = code_tmp;
                          cnt++;
                          if (cnt >= size_to_fill) return cnt;
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 7:

              for (let color1 = 1; color1 <= nbColors; color1++) {
                for (let color2 = 1; color2 <= nbColors; color2++) {
                  for (let color3 = 1; color3 <= nbColors; color3++) {
                    for (let color4 = 1; color4 <= nbColors; color4++) {
                      for (let color5 = 1; color5 <= nbColors; color5++) {
                        for (let color6 = 1; color6 <= nbColors; color6++) {
                          for (let color7 = 1; color7 <= nbColors; color7++) {
                            code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, color6, color7);
                            table[cnt] = code_tmp;
                            cnt++;
                            if (cnt >= size_to_fill) return cnt;
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              throw new Error("fillShortInitialPossibleCodesTable: invalid nbColumns value: " + nbColumns);
          }

          throw new Error("fillShortInitialPossibleCodesTable: internal error (cnt value: " + cnt + ")");
          // return cnt;

        }

        // **********************************
        // Update tables of numbers of colors
        // **********************************

        function updateNbColorsTables(code) {

          if (!codeHandler.isEmpty(colorsFoundCode)) { // colorsFoundCode is not empty
            for (let column = 0; column < nbColumns; column++) {
              let color = codeHandler.getColor(colorsFoundCode, column+1);
              if (color == emptyColor) {
                continue;
              }
              let color2 = codeHandler.getColor(code, column+1);
              if (color == nbColors+1) { // (initial value)
                colorsFoundCode = codeHandler.setColor(colorsFoundCode, color2, column+1);
              }
              else if (color != color2) {
                colorsFoundCode = codeHandler.setColor(colorsFoundCode, emptyColor, column+1);
              }
            }
          }

          let sum = 0;
          for (let color = 1; color <= nbColors; color++) {
            let nb_colors_tmp = nbColorsTableForMinMaxNbColors[color];
            sum += nb_colors_tmp;
            minNbColorsTable[color] = Math.min(nb_colors_tmp, minNbColorsTable[color]);
            maxNbColorsTable[color] = Math.max(nb_colors_tmp, maxNbColorsTable[color]);
          }
          if (sum != nbColumns) {
            throw new Error("updateNbColorsTables() error: " + sum);
          }

        }

        // ***************************************************
        // Compute number of possible codes at a given attempt
        // ***************************************************

        let last_attempt_nb = 1;
        function computeNbOfPossibleCodes(attempt_nb, nb_codes_max_listed, possibleCodes_p) {

          if ( (attempt_nb < 2) || (attempt_nb != last_attempt_nb+1) || (nb_codes_max_listed <= 0) ) { // Calls to computeNbOfPossibleCodes() use consecutive attempt numbers
           throw new Error("computeNbOfPossibleCodes: invalid parameters (" + attempt_nb + "," + last_attempt_nb + "," + nb_codes_max_listed + ")");
          }
          if (nb_codes_max_listed > possibleCodes_p.length) {
            throw new Error("computeNbOfPossibleCodes: table size is too low: " + nb_codes_max_listed + ", " + possibleCodes_p.length);
          }
          last_attempt_nb++;

          // Initialize tables of numbers of colors
          colorsFoundCode = codeHandler.setAllColorsIdentical(nbColors+1); // (initial value)
          for (let color = 1; color <= nbColors; color++) {
            minNbColorsTable[color] = nbColumns;
            maxNbColorsTable[color] = 0;
          }

          let N; // possibleCodesAfterNAttempts is build at attempt N (shall be >= 1)
          if (nbColumns >= 7) { // (higher memory consumption)
            N = 5;
          }
          else {
            N = 2;
          }

          if (attempt_nb <= N) {

            if (possibleCodesAfterNAttempts.getNbElements() != 0) {
              throw new Error("computeNbOfPossibleCodes: internal error (" + possibleCodesAfterNAttempts.getNbElements() + ")");
            }

            let code_tmp = 0;
            let mark_tmp = {nbBlacks:0, nbWhites:0};
            let cnt = 0;

            switch (nbColumns) {

              case 3:

                for (let color1 = 1; color1 <= nbColors; color1++) {
                  for (let color2 = 1; color2 <= nbColors; color2++) {
                    for (let color3 = 1; color3 <= nbColors; color3++) {
                      code_tmp = codeHandler.setAllColors(color1, color2, color3, emptyColor, emptyColor, emptyColor, emptyColor);
                      let isPossible = true;
                      for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                        codeHandler.fillMark(codesPlayed[attempt_idx], code_tmp, mark_tmp);
                        if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                          isPossible = false;
                          break;
                        }
                      }
                      if (isPossible) {
                        nbColorsTableForMinMaxNbColors.fill(0);
                        nbColorsTableForMinMaxNbColors[color1]++;
                        nbColorsTableForMinMaxNbColors[color2]++;
                        nbColorsTableForMinMaxNbColors[color3]++;
                        updateNbColorsTables(code_tmp);
                        if (cnt < nb_codes_max_listed) {
                          possibleCodes_p[cnt] = code_tmp;
                        }
                        cnt++;
                        if (attempt_nb == N) {
                          possibleCodesAfterNAttempts.add(code_tmp);
                        }
                      }
                    }
                  }
                }
                break;

              case 4:

                for (let color1 = 1; color1 <= nbColors; color1++) {
                  for (let color2 = 1; color2 <= nbColors; color2++) {
                    for (let color3 = 1; color3 <= nbColors; color3++) {
                      for (let color4 = 1; color4 <= nbColors; color4++) {
                        code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, emptyColor, emptyColor, emptyColor);
                        let isPossible = true;
                        for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                          codeHandler.fillMark(codesPlayed[attempt_idx], code_tmp, mark_tmp);
                          if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                            isPossible = false;
                            break;
                          }
                        }
                        if (isPossible) {
                          nbColorsTableForMinMaxNbColors.fill(0);
                          nbColorsTableForMinMaxNbColors[color1]++;
                          nbColorsTableForMinMaxNbColors[color2]++;
                          nbColorsTableForMinMaxNbColors[color3]++;
                          nbColorsTableForMinMaxNbColors[color4]++;
                          updateNbColorsTables(code_tmp);
                          if (cnt < nb_codes_max_listed) {
                            possibleCodes_p[cnt] = code_tmp;
                          }
                          cnt++;
                          if (attempt_nb == N) {
                            possibleCodesAfterNAttempts.add(code_tmp);
                          }
                        }
                      }
                    }
                  }
                }
                break;

              case 5:

                for (let color1 = 1; color1 <= nbColors; color1++) {
                  for (let color2 = 1; color2 <= nbColors; color2++) {
                    for (let color3 = 1; color3 <= nbColors; color3++) {
                      for (let color4 = 1; color4 <= nbColors; color4++) {
                        for (let color5 = 1; color5 <= nbColors; color5++) {
                          code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, emptyColor, emptyColor);
                          let isPossible = true;
                          for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                            codeHandler.fillMark(codesPlayed[attempt_idx], code_tmp, mark_tmp);
                            if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                              isPossible = false;
                              break;
                            }
                          }
                          if (isPossible) {
                            nbColorsTableForMinMaxNbColors.fill(0);
                            nbColorsTableForMinMaxNbColors[color1]++;
                            nbColorsTableForMinMaxNbColors[color2]++;
                            nbColorsTableForMinMaxNbColors[color3]++;
                            nbColorsTableForMinMaxNbColors[color4]++;
                            nbColorsTableForMinMaxNbColors[color5]++;
                            updateNbColorsTables(code_tmp);
                            if (cnt < nb_codes_max_listed) {
                              possibleCodes_p[cnt] = code_tmp;
                            }
                            cnt++;
                            if (attempt_nb == N) {
                              possibleCodesAfterNAttempts.add(code_tmp);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;

              case 6:

                for (let color1 = 1; color1 <= nbColors; color1++) {
                  for (let color2 = 1; color2 <= nbColors; color2++) {
                    for (let color3 = 1; color3 <= nbColors; color3++) {
                      for (let color4 = 1; color4 <= nbColors; color4++) {
                        for (let color5 = 1; color5 <= nbColors; color5++) {
                          for (let color6 = 1; color6 <= nbColors; color6++) {
                            code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, color6, emptyColor);
                            let isPossible = true;
                            for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                              codeHandler.fillMark(codesPlayed[attempt_idx], code_tmp, mark_tmp);
                              if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                                isPossible = false;
                                break;
                              }
                            }
                            if (isPossible) {
                              nbColorsTableForMinMaxNbColors.fill(0);
                              nbColorsTableForMinMaxNbColors[color1]++;
                              nbColorsTableForMinMaxNbColors[color2]++;
                              nbColorsTableForMinMaxNbColors[color3]++;
                              nbColorsTableForMinMaxNbColors[color4]++;
                              nbColorsTableForMinMaxNbColors[color5]++;
                              nbColorsTableForMinMaxNbColors[color6]++;
                              updateNbColorsTables(code_tmp);
                              if (cnt < nb_codes_max_listed) {
                                possibleCodes_p[cnt] = code_tmp;
                              }
                              cnt++;
                              if (attempt_nb == N) {
                                possibleCodesAfterNAttempts.add(code_tmp);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;

              case 7:

                if (!codeHandler.isFullAndValid(codesPlayed[0])) {
                  throw new Error("computeNbOfPossibleCodes: internal error (codesPlayed[0] is not full and valid)");
                }
                let mark0_nb_pegs = marks[0].nbBlacks + marks[0].nbWhites;
                let mark1_nb_pegs = -1;
                if (attempt_nb == 3) {
                  mark1_nb_pegs = marks[1].nbBlacks + marks[1].nbWhites;
                }
                for (let color1 = 1; color1 <= nbColors; color1++) {
                  for (let color2 = 1; color2 <= nbColors; color2++) {
                    for (let color3 = 1; color3 <= nbColors; color3++) {
                      for (let color4 = 1; color4 <= nbColors; color4++) {
                        for (let color5 = 1; color5 <= nbColors; color5++) {
                          for (let color6 = 1; color6 <= nbColors; color6++) {

                            // Optimization
                            code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, color6, emptyColor);
                            codeHandler.fillMark(codesPlayed[0], code_tmp, mark_tmp);
                            let mark_tmp_nb_pegs = mark_tmp.nbBlacks + mark_tmp.nbWhites;
                            if ( (mark_tmp_nb_pegs > mark0_nb_pegs)
                                 || (mark_tmp_nb_pegs < mark0_nb_pegs - 1)
                                 || (mark_tmp.nbBlacks > marks[0].nbBlacks)
                                 || (mark_tmp.nbBlacks < marks[0].nbBlacks - 1) ) {
                              continue;
                            }
                            if (mark1_nb_pegs != -1) {
                              codeHandler.fillMark(codesPlayed[1], code_tmp, mark_tmp);
                              let mark_tmp_nb_pegs = mark_tmp.nbBlacks + mark_tmp.nbWhites;
                              if ( (mark_tmp_nb_pegs > mark1_nb_pegs)
                                   || (mark_tmp_nb_pegs < mark1_nb_pegs - 1)
                                   || (mark_tmp.nbBlacks > marks[1].nbBlacks)
                                   || (mark_tmp.nbBlacks < marks[1].nbBlacks - 1) ) {
                                continue;
                              }
                            }

                            for (let color7 = 1; color7 <= nbColors; color7++) {
                              code_tmp = codeHandler.setAllColors(color1, color2, color3, color4, color5, color6, color7);
                              let isPossible = true;
                              for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                                codeHandler.fillMark(codesPlayed[attempt_idx], code_tmp, mark_tmp);
                                if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                                  isPossible = false;
                                  break;
                                }
                              }
                              if (isPossible) {
                                nbColorsTableForMinMaxNbColors.fill(0);
                                nbColorsTableForMinMaxNbColors[color1]++;
                                nbColorsTableForMinMaxNbColors[color2]++;
                                nbColorsTableForMinMaxNbColors[color3]++;
                                nbColorsTableForMinMaxNbColors[color4]++;
                                nbColorsTableForMinMaxNbColors[color5]++;
                                nbColorsTableForMinMaxNbColors[color6]++;
                                nbColorsTableForMinMaxNbColors[color7]++;
                                updateNbColorsTables(code_tmp);
                                if (cnt < nb_codes_max_listed) {
                                  possibleCodes_p[cnt] = code_tmp;
                                }
                                cnt++;
                                if (attempt_nb == N) {
                                  possibleCodesAfterNAttempts.add(code_tmp);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;

              default:
                throw new Error("computeNbOfPossibleCodes: invalid nbColumns value: " + nbColumns);
            }

            if ( (cnt <= 0) || (cnt > initialNbPossibleCodes)
                 || ( (attempt_nb == 1) && (cnt != initialNbPossibleCodes) )
                 || ( (attempt_nb < N) && (possibleCodesAfterNAttempts.getNbElements() != 0) )
                 || ( (attempt_nb == N) && (cnt != possibleCodesAfterNAttempts.getNbElements()) ) ) {
              throw new Error("computeNbOfPossibleCodes: invalid cnt values (" + cnt + "," + attempt_nb + "," + possibleCodesAfterNAttempts.getNbElements() + ")");
            }
            return cnt;

          } // (attempt_nb <= N)
          else { // (attempt_nb > N)

            let code_possible_after_N_attempts;
            let code_possible_after_N_attempts_bis;
            let mark_tmp = {nbBlacks:0, nbWhites:0};
            let cnt = 0;
            let cnt_global = 0;

            possibleCodesAfterNAttempts.resetGetIterator();
            do {

              code_possible_after_N_attempts = possibleCodesAfterNAttempts.getNextElement(false /* (do not make the iteration) */);
              if (code_possible_after_N_attempts == 0) {
                break;
              }
              cnt_global++;

              let isPossible;
              if (code_possible_after_N_attempts != -1) { // ("code impossible" value)
                isPossible = true;
                for (let attempt_idx = 0; attempt_idx < attempt_nb-1; attempt_idx++) {
                  codeHandler.fillMark(codesPlayed[attempt_idx], code_possible_after_N_attempts, mark_tmp);
                  if (!codeHandler.marksEqual(marks[attempt_idx], mark_tmp)) {
                    isPossible = false;
                    break;
                  }
                }
              }
              else {
                isPossible = false;
              }

              if (isPossible) {
                code_possible_after_N_attempts_bis = possibleCodesAfterNAttempts.getNextElement(true /* (make the iteration) */);
                if (code_possible_after_N_attempts != code_possible_after_N_attempts_bis) {
                  throw new Error("computeNbOfPossibleCodes: iteration inconsistency (" + code_possible_after_N_attempts + "," + code_possible_after_N_attempts_bis + ")");
                }
                nbColorsTableForMinMaxNbColors.fill(0);
                for (let column = 0; column < nbColumns; column++) {
                  nbColorsTableForMinMaxNbColors[codeHandler.getColor(code_possible_after_N_attempts, column+1)]++;
                }
                updateNbColorsTables(code_possible_after_N_attempts);
                if (cnt < nb_codes_max_listed) {
                  possibleCodes_p[cnt] = code_possible_after_N_attempts;
                }
                cnt++;
              }
              else {
                possibleCodesAfterNAttempts.replaceNextElement(code_possible_after_N_attempts, -1); // ("code impossible" value)
              }

            } while (true);

            if ( (cnt <= 0) || (cnt > initialNbPossibleCodes)
                 || ( (attempt_nb == 1) && (cnt != initialNbPossibleCodes) )
                 || (cnt_global != possibleCodesAfterNAttempts.getNbElements()) ) {
              throw new Error("computeNbOfPossibleCodes: invalid cnt/cnt_global values (" + cnt + "," + cnt_global + "," + possibleCodesAfterNAttempts.getNbElements() + ")");
            }
            return cnt;

          }

        }

        // *********************
        // Generate permutations
        // *********************

        function generateAllPermutations() {

          all_permutations_table_size = new Array(nbMaxColumns+1);
          all_permutations_table_size.fill(0);
          all_permutations_table_size[3] = 3*2; // 3! permutations
          all_permutations_table_size[4] = 4*3*2; // 4! permutations
          all_permutations_table_size[5] = 5*4*3*2; // 5! permutations
          all_permutations_table_size[6] = 6*5*4*3*2; // 6! permutations
          all_permutations_table_size[7] = 7*6*5*4*3*2; // 7! permutations

          if (all_permutations_table_size[nbColumns] <= 0) {
            throw new Error("generateAllPermutations / error while computing all_permutations_table_size: " + nbColumns);
          }

          all_permutations_table = new Array(nbMaxColumns+1);
          for (let nb_elts = nbMinColumns; nb_elts <= nbMaxColumns; nb_elts++) {
            if (all_permutations_table_size[nb_elts] > 0) {
              all_permutations_table[nb_elts] = new Array(all_permutations_table_size[nb_elts]);
            }
          }

          let NB_ELEMENTS;
          let indexes = new Array(nbMaxColumns);
          let permutation_cnt = 0;

          switch (nbColumns) {

            case 3:

              // Generate permutations of 3 elements
              // ***********************************

              NB_ELEMENTS = 3;
              // console.log("// Permutations of " + NB_ELEMENTS + " elements:");
              for (indexes[0] = 0; indexes[0] < NB_ELEMENTS; indexes[0]++) {
                for (indexes[1] = 0; indexes[1] < NB_ELEMENTS; indexes[1]++) {
                  for (indexes[2] = 0; indexes[2] < NB_ELEMENTS; indexes[2]++) { // NB_ELEMENTS loops
                    // Check if {indexes[0], indexes[1], ... indexes[NB_ELEMENTS-1]} is a permutation
                    let is_a_permutation = true;
                    for (let idx1 = 0; (idx1 < NB_ELEMENTS) && is_a_permutation; idx1++) {
                      for (let idx2 = 0; idx2 < NB_ELEMENTS; idx2++) {
                        if ((idx1 != idx2) && (indexes[idx1] == indexes[idx2])) {
                          is_a_permutation = false;
                          break;
                        }
                      }
                    }
                    if (is_a_permutation) {
                      all_permutations_table[NB_ELEMENTS][permutation_cnt] = [indexes[0], indexes[1], indexes[2]]; // NB_ELEMENTS elements
                      // console.log("all_permutations_table[" + NB_ELEMENTS + "][" + permutation_cnt + "] = [" + indexes[0] + ", " + indexes[1] + ", " + indexes[2] + "];"); // NB_ELEMENTS elements
                      permutation_cnt++;
                    }
                  }
                }
              }
              if (permutation_cnt != all_permutations_table_size[NB_ELEMENTS]) {
                throw new Error("generateAllPermutations / error while computing " + NB_ELEMENTS + "-elements permutations!");
              }
              break;

            case 4:

              // Generate permutations of 4 elements
              // ***********************************

              NB_ELEMENTS = 4;
              // console.log("// Permutations of " + NB_ELEMENTS + " elements:");
              for (indexes[0] = 0; indexes[0] < NB_ELEMENTS; indexes[0]++) {
                for (indexes[1] = 0; indexes[1] < NB_ELEMENTS; indexes[1]++) {
                  for (indexes[2] = 0; indexes[2] < NB_ELEMENTS; indexes[2]++) {
                    for (indexes[3] = 0; indexes[3] < NB_ELEMENTS; indexes[3]++) { // NB_ELEMENTS loops
                      // Check if {indexes[0], indexes[1], ... indexes[NB_ELEMENTS-1]} is a permutation
                      let is_a_permutation = true;
                      for (let idx1 = 0; (idx1 < NB_ELEMENTS) && is_a_permutation; idx1++) {
                        for (let idx2 = 0; idx2 < NB_ELEMENTS; idx2++) {
                          if ((idx1 != idx2) && (indexes[idx1] == indexes[idx2])) {
                            is_a_permutation = false;
                            break;
                          }
                        }
                      }
                      if (is_a_permutation) {
                        all_permutations_table[NB_ELEMENTS][permutation_cnt] = [indexes[0], indexes[1], indexes[2], indexes[3]]; // NB_ELEMENTS elements
                        // console.log("all_permutations_table[" + NB_ELEMENTS + "][" + permutation_cnt + "] = [" + indexes[0] + ", " + indexes[1] + ", " + indexes[2] + ", " + indexes[3] + "];"); // NB_ELEMENTS elements
                        permutation_cnt++;
                      }
                    }
                  }
                }
              }
              if (permutation_cnt != all_permutations_table_size[NB_ELEMENTS]) {
                throw new Error("generateAllPermutations / error while computing " + NB_ELEMENTS + "-elements permutations!");
              }
              break;

            case 5:

              // Generate permutations of 5 elements
              // ***********************************

              NB_ELEMENTS = 5;
              // console.log("// Permutations of " + NB_ELEMENTS + " elements:");
              for (indexes[0] = 0; indexes[0] < NB_ELEMENTS; indexes[0]++) {
                for (indexes[1] = 0; indexes[1] < NB_ELEMENTS; indexes[1]++) {
                  for (indexes[2] = 0; indexes[2] < NB_ELEMENTS; indexes[2]++) {
                    for (indexes[3] = 0; indexes[3] < NB_ELEMENTS; indexes[3]++) {
                      for (indexes[4] = 0; indexes[4] < NB_ELEMENTS; indexes[4]++) { // NB_ELEMENTS loops
                        // Check if {indexes[0], indexes[1], ... indexes[NB_ELEMENTS-1]} is a permutation
                        let is_a_permutation = true;
                        for (let idx1 = 0; (idx1 < NB_ELEMENTS) && is_a_permutation; idx1++) {
                          for (let idx2 = 0; idx2 < NB_ELEMENTS; idx2++) {
                            if ((idx1 != idx2) && (indexes[idx1] == indexes[idx2])) {
                              is_a_permutation = false;
                              break;
                            }
                          }
                        }
                        if (is_a_permutation) {
                          all_permutations_table[NB_ELEMENTS][permutation_cnt] = [indexes[0], indexes[1], indexes[2], indexes[3], indexes[4]]; // NB_ELEMENTS elements
                          // console.log("all_permutations_table[" + NB_ELEMENTS + "][" + permutation_cnt + "] = [" + indexes[0] + ", " + indexes[1] + ", " + indexes[2] + ", " + indexes[3] + ", " + indexes[4] + "];"); // NB_ELEMENTS elements
                          permutation_cnt++;
                        }
                      }
                    }
                  }
                }
              }
              if (permutation_cnt != all_permutations_table_size[NB_ELEMENTS]) {
                throw new Error("generateAllPermutations / error while computing " + NB_ELEMENTS + "-elements permutations!");
              }
              break;

            case 6:

              // Generate permutations of 6 elements
              // ***********************************

              NB_ELEMENTS = 6;
              // console.log("// Permutations of " + NB_ELEMENTS + " elements:");
              for (indexes[0] = 0; indexes[0] < NB_ELEMENTS; indexes[0]++) {
                for (indexes[1] = 0; indexes[1] < NB_ELEMENTS; indexes[1]++) {
                  for (indexes[2] = 0; indexes[2] < NB_ELEMENTS; indexes[2]++) {
                    for (indexes[3] = 0; indexes[3] < NB_ELEMENTS; indexes[3]++) {
                      for (indexes[4] = 0; indexes[4] < NB_ELEMENTS; indexes[4]++) {
                        for (indexes[5] = 0; indexes[5] < NB_ELEMENTS; indexes[5]++) { // NB_ELEMENTS loops
                          // Check if {indexes[0], indexes[1], ... indexes[NB_ELEMENTS-1]} is a permutation
                          let is_a_permutation = true;
                          for (let idx1 = 0; (idx1 < NB_ELEMENTS) && is_a_permutation; idx1++) {
                            for (let idx2 = 0; idx2 < NB_ELEMENTS; idx2++) {
                              if ((idx1 != idx2) && (indexes[idx1] == indexes[idx2])) {
                                is_a_permutation = false;
                                break;
                              }
                            }
                          }
                          if (is_a_permutation) {
                            all_permutations_table[NB_ELEMENTS][permutation_cnt] = [indexes[0], indexes[1], indexes[2], indexes[3], indexes[4], indexes[5]]; // NB_ELEMENTS elements
                            // console.log("all_permutations_table[" + NB_ELEMENTS + "][" + permutation_cnt + "] = [" + indexes[0] + ", " + indexes[1] + ", " + indexes[2] + indexes[3] + ", " + indexes[4] + ", " + indexes[5] + "];"); // NB_ELEMENTS elements
                            permutation_cnt++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (permutation_cnt != all_permutations_table_size[NB_ELEMENTS]) {
                throw new Error("generateAllPermutations / error while computing " + NB_ELEMENTS + "-elements permutations!");
              }
              break;

            case 7:

              // Generate permutations of 7 elements
              // ***********************************

              NB_ELEMENTS = 7;
              // console.log("// Permutations of " + NB_ELEMENTS + " elements:");
              for (indexes[0] = 0; indexes[0] < NB_ELEMENTS; indexes[0]++) {
                for (indexes[1] = 0; indexes[1] < NB_ELEMENTS; indexes[1]++) {
                  for (indexes[2] = 0; indexes[2] < NB_ELEMENTS; indexes[2]++) {
                    for (indexes[3] = 0; indexes[3] < NB_ELEMENTS; indexes[3]++) {
                      for (indexes[4] = 0; indexes[4] < NB_ELEMENTS; indexes[4]++) {
                        for (indexes[5] = 0; indexes[5] < NB_ELEMENTS; indexes[5]++) {
                          for (indexes[6] = 0; indexes[6] < NB_ELEMENTS; indexes[6]++) { // NB_ELEMENTS loops
                            // Check if {indexes[0], indexes[1], ... indexes[NB_ELEMENTS-1]} is a permutation
                            let is_a_permutation = true;
                            for (let idx1 = 0; (idx1 < NB_ELEMENTS) && is_a_permutation; idx1++) {
                              for (let idx2 = 0; idx2 < NB_ELEMENTS; idx2++) {
                                if ((idx1 != idx2) && (indexes[idx1] == indexes[idx2])) {
                                  is_a_permutation = false;
                                  break;
                                }
                              }
                            }
                            if (is_a_permutation) {
                              all_permutations_table[NB_ELEMENTS][permutation_cnt] = [indexes[0], indexes[1], indexes[2], indexes[3], indexes[4], indexes[5], indexes[6]]; // NB_ELEMENTS elements
                              // console.log("all_permutations_table[" + NB_ELEMENTS + "][" + permutation_cnt + "] = [" + indexes[0] + ", " + indexes[1] + ", " + indexes[2] + ", " + indexes[3] + ", " + indexes[4] + ", " + indexes[5] + ", " + indexes[6] + "];"); // NB_ELEMENTS elements
                              permutation_cnt++;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (permutation_cnt != all_permutations_table_size[NB_ELEMENTS]) {
                throw new Error("generateAllPermutations / error while computing " + NB_ELEMENTS + "-elements permutations!");
              }
              break;

            default:
              throw new Error("generateAllPermutations / invalid nbColumns: " + nbColumns);

          }

          if ( (all_permutations_table_size.length != nbMaxColumns+1) || (permutation_cnt != all_permutations_table_size[nbColumns]) ) {
            throw new Error("generateAllPermutations / internal error");
          }

          // Update possible permutations
          // ****************************

          // All permutations are listed by default
          cur_permutations_table_size = new Array(overallNbMaxAttempts+overallMaxDepth);
          cur_permutations_table_size[0] = all_permutations_table_size[nbColumns];
          cur_permutations_table = new2DArray(overallNbMaxAttempts+overallMaxDepth, cur_permutations_table_size[0]);
          for (let i = 0; i < cur_permutations_table_size[0]; i++) {
            cur_permutations_table[0][i] = i;
          }

        }

        // ******************************
        // Handle multidimensional arrays
        // ******************************

        function new2DArray(x, y) {
          var my_array = new Array(x);
          for (let i = 0; i < x; i++) {
            my_array[i] = new Array(y);
          }
          return my_array;
        }

        function check2DArraySizes(my_array, x, y) {
          if (my_array.length != x) {
            console.log("check2DArraySizes/0: " + my_array.length + " != " + x);
            return false;
          }
          for (let i = 0; i < my_array.length; i++) {
            if (my_array[i].length != y) {
              console.log("check2DArraySizes/1(" + i + "): " + my_array[i].length + " != " + y);
              return false;
            }
          }
          return true;
        }

        function new3DArray(x, y, z, reduc) {
          var my_array = new Array(x);
          var reduced_z = z;
          for (let i = 0; i < x; i++) {
            my_array[i] = new2DArray(y, reduced_z);
            reduced_z = Math.ceil(reduced_z * reduc);
          }
          return my_array;
        }

        function check3DArraySizes(my_array, x, y, z, reduc) {
          if (my_array.length != x) {
            console.log("check3DArraySizes/0: " + my_array.length + " != " + x);
            return false;
          }
          var reduced_z = z;
          for (let i = 0; i < my_array.length; i++) {
            if (!check2DArraySizes(my_array[i], y, reduced_z)) {
              return false;
            }
            reduced_z = Math.ceil(reduced_z * reduc);
          }
          return true;
        }

        // *********************
        // Evaluate performances
        // *********************

        function spaces(nb) {
          let str = "";
          for (let i = -1; i < nb; i++) {
            str = str + "  ";
          }
          return str;
        }

        function print_permutation_list(list, list_size) {
          let str = "";
          for (let i = 0; i < list_size; i++) {
            str = str + all_permutations_table[nbColumns][list[i]] + " | ";
          }
          str = "{" + str.trim() + "}";
          return str;
        }

        function str_from_list_of_codes(list, list_size) {
          let str = "";
          for (let i = 0; i < list_size; i++) {
            str = str + codeHandler.codeToString(list[i]) + " ";
          }
          str = "{" + str.trim() + "}";
          return str;
        }

        function compressed_str_from_lists_of_codes_and_markidxs(code_list, mark_idx_list, list_size) {
          if (list_size == 0) {
            return "";
          }
          else {
            let str = "";
            for (let i = 0; i < list_size-1; i++) {
              str = str + codeHandler.compressCodeToString(code_list[i]) + ":" + codeHandler.markToString(marksTable_NbToMark[mark_idx_list[i]]) + "|";
            }
            str = str + codeHandler.compressCodeToString(code_list[list_size-1]) + ":" + codeHandler.markToString(marksTable_NbToMark[mark_idx_list[list_size-1]]);
            return str;
          }
        }

        function send_trace_msg(trace_str) {
          self.postMessage({'rsp_type': 'TRACE', 'trace_contents': trace_str});
        }

        let code_colors = new Array(nbMaxColumns);
        let other_code_colors = new Array(nbMaxColumns);
        let different_colors_1 = new Array(nbMaxColors+1);
        let different_colors_2 = new Array(nbMaxColors+1);
        let cur_game_code_colors = new2DArray(overallNbMaxAttempts+overallMaxDepth, nbMaxColumns); // first dimension shall be >= curGame size
        let other_game_code_colors = new2DArray(overallNbMaxAttempts+overallMaxDepth, nbMaxColumns); // first dimension shall be >= curGame size
        let permuted_other_code_colors = new Array(nbMaxColumns);
        let partial_bijection = new Array(nbMaxColors+1);
        function areCodesEquivalent(code, other_code, cur_game_size, assess_cur_game_only, forceGlobalPermIdx /* -1 if N.A. */, otherGame /* null if N.A. */) {
          let all_permutations = all_permutations_table[nbColumns]; // [nb_permutations][nbColumns] array
          let global_perm_idx;
          let perm_idx;
          let cur_game_depth;
          let cur_game_code;
          let other_game_code;
          let cur_game_code_colors_set;
          let other_game_code_colors_set;
          let col;
          let color;
          let bijection_is_possible_for_this_permutation;
          let source_color, old_target_color, new_target_color;

          // *****************
          // Get useful colors
          // *****************

          // 2 codes colors
          if (!assess_cur_game_only) {

            // (duplicated code from getColor() for better performances - begin)
            code_colors[0] = (code & 0x0000000F);
            code_colors[1] = ((code >> 4) & 0x0000000F);
            code_colors[2] = ((code >> 8) & 0x0000000F);
            code_colors[3] = ((code >> 12) & 0x0000000F);
            code_colors[4] = ((code >> 16) & 0x0000000F);
            code_colors[5] = ((code >> 20) & 0x0000000F);
            code_colors[6] = ((code >> 24) & 0x0000000F);

            other_code_colors[0] = (other_code & 0x0000000F);
            other_code_colors[1] = ((other_code >> 4) & 0x0000000F);
            other_code_colors[2] = ((other_code >> 8) & 0x0000000F);
            other_code_colors[3] = ((other_code >> 12) & 0x0000000F);
            other_code_colors[4] = ((other_code >> 16) & 0x0000000F);
            other_code_colors[5] = ((other_code >> 20) & 0x0000000F);
            other_code_colors[6] = ((other_code >> 24) & 0x0000000F);
            // (duplicated code from getColor() for better performances - end)

            // Optimization
            // ************

            // (duplicated code from nbDifferentColors() for better performances - begin)
            let sum_1 = 0;
            let sum_2 = 0;
            different_colors_1.fill(0);
            different_colors_2.fill(0);
            for (col = 0; col < nbColumns; col++) {
              let color_1 = code_colors[col];
              let color_2 = other_code_colors[col];
              if (different_colors_1[color_1] == 0) {
                different_colors_1[color_1] = 1;
                sum_1 = sum_1 + 1;
              }
              if (different_colors_2[color_2] == 0) {
                different_colors_2[color_2] = 1;
                sum_2 = sum_2 + 1;
              }
            }
            // (duplicated code from nbDifferentColors() for better performances - end)
            if (sum_1 == sum_2) {
              if (cur_game_size == 0) {
                if (sum_1 == nbColumns-1) {
                  return true; // 1 double and N-2 other different colors - at least one bijection exists between the 2 games
                }
                if (sum_1 == nbColumns) {
                  return true; // N different colors - at least one bijection exists between the 2 games
                }
              }
            }
            else {
              return false; // no bijection exists between the 2 games
            }

          }

          // Game(s) colors
          for (cur_game_depth = 0; cur_game_depth < cur_game_size; cur_game_depth++) {
            cur_game_code = curGame[cur_game_depth]
            cur_game_code_colors_set = cur_game_code_colors[cur_game_depth]; // [nbMaxColumns] array

            // (duplicated code from getColor() for better performances - begin)
            cur_game_code_colors_set[0] = (cur_game_code & 0x0000000F);
            cur_game_code_colors_set[1] = ((cur_game_code >> 4) & 0x0000000F);
            cur_game_code_colors_set[2] = ((cur_game_code >> 8) & 0x0000000F);
            cur_game_code_colors_set[3] = ((cur_game_code >> 12) & 0x0000000F);
            cur_game_code_colors_set[4] = ((cur_game_code >> 16) & 0x0000000F);
            cur_game_code_colors_set[5] = ((cur_game_code >> 20) & 0x0000000F);
            cur_game_code_colors_set[6] = ((cur_game_code >> 24) & 0x0000000F);
            // (duplicated code from getColor() for better performances - end)
          }
          if (otherGame != null) {
            for (cur_game_depth = 0; cur_game_depth < cur_game_size; cur_game_depth++) {
              other_game_code = otherGame[cur_game_depth]
              other_game_code_colors_set = other_game_code_colors[cur_game_depth]; // another game is used - [nbMaxColumns] array

              // (duplicated code from getColor() for better performances - begin)
              other_game_code_colors_set[0] = (other_game_code & 0x0000000F);
              other_game_code_colors_set[1] = ((other_game_code >> 4) & 0x0000000F);
              other_game_code_colors_set[2] = ((other_game_code >> 8) & 0x0000000F);
              other_game_code_colors_set[3] = ((other_game_code >> 12) & 0x0000000F);
              other_game_code_colors_set[4] = ((other_game_code >> 16) & 0x0000000F);
              other_game_code_colors_set[5] = ((other_game_code >> 20) & 0x0000000F);
              other_game_code_colors_set[6] = ((other_game_code >> 24) & 0x0000000F);
              // (duplicated code from getColor() for better performances - end)
            }
          }

          // ************************************
          // Go through all possible permutations
          // ************************************

          let permLoopStartIdx = 0;
          let permLoopStopIdx;
          if (forceGlobalPermIdx != -1) { // Evaluate one given permutation only
            if ((forceGlobalPermIdx < 0) || (forceGlobalPermIdx >= all_permutations_table_size[nbColumns])) {
              throw new Error("areCodesEquivalent: invalid forceGlobalPermIdx: " + forceGlobalPermIdx);
            }
            permLoopStopIdx = 1; // one loop only
          }
          else if (otherGame == null) {
            permLoopStopIdx = cur_permutations_table_size[cur_game_size];
          }
          else { // (otherGame != null)
            permLoopStopIdx = cur_permutations_table_size[0]; // all permutations
          }

          if (permLoopStopIdx <= permLoopStartIdx) {
            throw new Error("areCodesEquivalent: no permutation");
          }

          for (perm_idx = permLoopStartIdx; perm_idx < permLoopStopIdx; perm_idx++) {

            if (forceGlobalPermIdx != -1) { // Evaluate one given permutation only
              global_perm_idx = forceGlobalPermIdx;
            }
            else if (otherGame == null) {
              global_perm_idx = cur_permutations_table[cur_game_size][perm_idx];
            }
            else { // (otherGame != null)
              global_perm_idx = cur_permutations_table[0][perm_idx]; // all permutations
            }
            // console.log("permutation:" + all_permutations[global_perm_idx]);

            // **********************************************************************
            // If possible, compute bijection between:
            // 1) code and permuted other code (if assess_cur_game_only is false)
            // 2) cur game and permuted game
            // **********************************************************************

            bijection_is_possible_for_this_permutation = true;
            partial_bijection.fill(0);

            // 1) Bijection between code and permuted other code (if assess_cur_game_only is false)
            // ****************************************************************************************

            if (!assess_cur_game_only) {

              // Compute permuted other code
              for (col = 0; col < nbColumns; col++) {
                permuted_other_code_colors[all_permutations[global_perm_idx][col]] = other_code_colors[col];
              }

              // console.log("  permuted_other_code_colors = " + permuted_other_code_colors);

              for (col = 0; col < nbColumns; col++) {
                source_color = code_colors[col];
                old_target_color = partial_bijection[source_color];
                new_target_color = permuted_other_code_colors[col];
                if ((old_target_color != 0) && (old_target_color != new_target_color)) { // target color already allocated differently
                  // console.log("  NOK1:" + old_target_color);
                  bijection_is_possible_for_this_permutation = false;
                  break;
                }
                for (color = 1; color <= nbColors; color++) {
                  if ((color != source_color) && (partial_bijection[color] == new_target_color)) { // new target color already allocated to another source color
                    // console.log("  NOK2");
                    bijection_is_possible_for_this_permutation = false;
                    break;
                  }
                }
                if (!bijection_is_possible_for_this_permutation) {
                  break;
                }
                // if (partial_bijection[source_color] != new_target_color) {
                //  console.log(source_color + " -> " + new_target_color);
                // }
                partial_bijection[source_color] = new_target_color;
              }

            }

            // 2) Bijection between cur game and permuted game
            // ***************************************************

            if (bijection_is_possible_for_this_permutation) {

              for (cur_game_depth = cur_game_size-1; cur_game_depth >= 0; cur_game_depth--) { // (impacts on permutations are more likely for the last played codes)
                cur_game_code_colors_set = cur_game_code_colors[cur_game_depth]; // [nbMaxColumns] array
                if (otherGame == null) {
                  other_game_code_colors_set = cur_game_code_colors_set; // cur game is used twice - [nbMaxColumns] array
                }
                else { // (otherGame != null)
                  other_game_code_colors_set = other_game_code_colors[cur_game_depth]; // another game is used - [nbMaxColumns] array
                }

                // Compute permuted other code
                for (col = 0; col < nbColumns; col++) {
                  permuted_other_code_colors[all_permutations[global_perm_idx][col]] = other_game_code_colors_set[col];
                }

                // console.log("  permuted_other_code_colors = " + permuted_other_code_colors);

                for (col = 0; col < nbColumns; col++) {
                  source_color = cur_game_code_colors_set[col];
                  old_target_color = partial_bijection[source_color];
                  new_target_color = permuted_other_code_colors[col];
                  if ((old_target_color != 0) && (old_target_color != new_target_color)) { // target color already allocated differently
                    // console.log("  NOK1B:" + old_target_color);
                    bijection_is_possible_for_this_permutation = false;
                    break;
                  }
                  for (color = 1; color <= nbColors; color++) {
                    if ((color != source_color) && (partial_bijection[color] == new_target_color)) { // new target color already allocated to another source color
                      // console.log("  NOK2B");
                      bijection_is_possible_for_this_permutation = false;
                      break;
                    }
                  }
                  if (!bijection_is_possible_for_this_permutation) {
                    break;
                  }
                  // if (partial_bijection[source_color] != new_target_color) {
                  //  console.log(source_color + " -> " + new_target_color);
                  // }
                  partial_bijection[source_color] = new_target_color;
                }
              } // end loop on cur game

            }

            if (bijection_is_possible_for_this_permutation) {
              return true; // at least one bijection exists between the 2 games
            }

          } // end loop on perm_idx

          return false; // no bijection exists between the 2 games
        }

        let evaluatePerformancesStartTime;

        let mark_perf_tmp = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpa = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpb = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpc = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpd = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpe = {nbBlacks:-1, nbWhites:-1}; // N.A.
        let mark_perf_tmpf = {nbBlacks:-1, nbWhites:-1}; // N.A.

        let code1_colors = new Array(nbMaxColumns);
        let code2_colors = new Array(nbMaxColumns);
        let colors_int = new Array(nbMaxColumns);

        let particularCodeToAssess = 0; // empty code
        let particularCodeGlobalPerformance = PerformanceNA;
        let recursiveEvaluatePerformancesWasAborted = false;

        let areCurrentGameOrCodePrecalculated = -1;

        // Outputs: listOfGlobalPerformances[]
        //          particularCodeGlobalPerformance in case of impossible code
        function evaluatePerformances(depth, listOfCodes, nbCodes, particularCode, areCurrentGameOrCodePrecalculated_p) {

          let idx;
          let res;

          evaluatePerformancesStartTime = new Date().getTime();

          // Defensive check
          if ((best_mark_idx != marksTable_MarkToNb[nbColumns][0]) || (best_mark_idx >= nbMaxMarks)) {
            throw new Error("evaluatePerformances: invalid best_mark_idx");
          }
          if ((worst_mark_idx != marksTable_MarkToNb[0][0]) || (worst_mark_idx >= nbMaxMarks)) {
            throw new Error("evaluatePerformances: invalid worst_mark_idx");
          }
          if (curAttemptNumber <= 0) {
            throw new Error("evaluatePerformances: invalid curAttemptNumber: " + curAttemptNumber);
          }
          if ((nbCodes < 1) || (listOfCodes.length < nbCodes)) {
            throw new Error("evaluatePerformances: invalid number of codes: " + nbCodes + ", " + listOfCodes.length);
          }

          areCurrentGameOrCodePrecalculated = areCurrentGameOrCodePrecalculated_p;

          if (depth == -1) { // first call

            // Check cur game (useful for subsequent equivalent codes processing - duplicated code)
            if (curGameSize != curAttemptNumber-1) {
              throw new Error("evaluatePerformances: invalid curGameSize");
            }
            for (idx = 0; idx < curGameSize; idx++) {
              if ( (curGame[idx] != codesPlayed[idx]) || (!codeHandler.isFullAndValid(curGame[idx])) ) {
                throw new Error("evaluatePerformances: invalid cur game (" + idx + ")");
              }
              if ( (!codeHandler.marksEqual(marksTable_NbToMark[marksIdxs[idx]], marks[idx])) || (!codeHandler.isMarkValid(marksTable_NbToMark[marksIdxs[idx]])) )  {
                throw new Error("evaluatePerformances: invalid cur marks (" + idx + ")");
              }
            }

            // Determine cur number of classes
            // ***********************************

            listOfClassesFirstCall.fill(0);
            nbOfClassesFirstCall = 0;

            for (let idx1 = 0; idx1 < nbCodes; idx1++) {
              let cur_code = listOfCodes[idx1];
              let equiv_code_found = false;
              for (let idx2 = 0; idx2 < nbOfClassesFirstCall; idx2++) {
                let known_code = listOfClassesFirstCall[idx2];
                if (areCodesEquivalent(cur_code, known_code, curGameSize, false, -1 /* N.A. */, null)) {
                  equiv_code_found = true;
                  break;
                }
              }
              if (!equiv_code_found) {
                listOfClassesFirstCall[nbOfClassesFirstCall] = cur_code;
                nbOfClassesFirstCall++;
              }
            }

            curNbClasses = nbOfClassesFirstCall;
            if ( (curNbClasses <= 0) || (curNbClasses > nbCodes)
                 || ((curGameSize == 0) && (curNbClasses != initialNbClasses)) ) {
              throw new Error("evaluatePerformances: invalid curNbClasses: " + curNbClasses);
            }

            // Initializations
            // ***************

            // Initialize equivalent codes and performances
            for (let idx1 = 0; idx1 < listOfEquivalentCodesAndPerformances.length; idx1++) {
              for (let idx2 = 0; idx2 < listOfEquivalentCodesAndPerformances[idx1].length; idx2++) {
                listOfEquivalentCodesAndPerformances[idx1][idx2].equiv_code = 0; // output
                listOfEquivalentCodesAndPerformances[idx1][idx2].equiv_sum = PerformanceNA; // output
              }
            }

            // Initialize outputs
            if (nbCodes != previousNbOfPossibleCodes) {
              throw new Error("evaluatePerformances: (nbCodes != previousNbOfPossibleCodes)");
            }
            for (idx = 0; idx < nbCodes; idx++) {
              listOfGlobalPerformances[idx] = PerformanceNA; // output
            }
            particularCodeGlobalPerformance = PerformanceNA; // output
            recursiveEvaluatePerformancesWasAborted = false; // output

            // Main processing
            // ***************

            particularCodeToAssess = particularCode;
            res = recursiveEvaluatePerformances(depth, listOfCodes, nbCodes /*,  true (precalculation mode) */);

            if (recursiveEvaluatePerformancesWasAborted) {
              for (idx = 0; idx < nbCodes; idx++) {
                listOfGlobalPerformances[idx] = PerformanceNA; // output
              }
              particularCodeGlobalPerformance = PerformanceNA; // output
              return PerformanceUNKNOWN;
            }
            if (res <= 0.01) { // result is always known if the process was not aborted
              throw new Error("evaluatePerformances: invalid global performance: " + res);
            }
            return res;

          }
          else {
            throw new Error("evaluatePerformances: invalid depth: " + depth);
          }

        }

        // XXX Further work to do:
        // - X) Compress game.html script sizes?!
        // - X) Web page with good smartphone display
        // - X) Generate 5col tables + document precalculation assumptions
        // - X) Precalculate {5 columns, 8 colors} games, check possible & impossible code (code precalculated or its only game precalculated) & useless (obviously + not obviously useless) code & "very inefficient" code & "some-useless-color" codes & at precalculated depth 1/2/3, check RAM due to nbOfCodesForSystematicEvaluation_ForMemAlloc
        // - X) LONG PROCESSING TIME - 37 sec for 365 possibles codes on i5 processor.png
        // - X) test strictly positive precalculated perf
        // - X) Precalculated table split in several javascript modules to decrease size loaded?
        // - X) XXXs in all files
        // - X) Max nber of attempts for SMM games once precalculation fully stored (=> web page) + new game pictures in web page w/ all perfs evaluated + check total sum of attempts at the same time
        // - X) Complete forum? -> https://codegolf.stackexchange.com/questions/31926/mastermind-strategy
        // - X) Appli Android?
        function recursiveEvaluatePerformances(depth, listOfCodes, nbCodes /*, possibleGame (precalculation mode) */) {

          let first_call = (depth == -1);
          let next_depth = depth+1;
          let next_cur_game_idx = curGameSize + next_depth;
          let nextListsOfCodes;
          let nextNbsCodes;
          let nbOfEquivalentCodesAndPerformances = 0;
          let mark_idx, idx, idx1, idx2;
          let cur_code;
          let other_code;
          let mark_perf_tmp_idx;
          let compute_sum_ini = (nbCodes <= nbCodesLimitForEquivalentCodesCheck);
          let compute_sum;
          let precalculated_cur_game_or_code = (first_call ? areCurrentGameOrCodePrecalculated : -1);
          let precalculated_sum;
          // let write_me; // (traces useful for debug)
          // let write_me_for_precalculation; // (precalculation mode)
          let sum;
          let sum_marks;
          let best_sum = 100000000000.0;
          let marks_already_computed_table_cell;
          let codeX;
          let codeY;
          let nb_classes_cnt = 0;

          /*
          // (precalculation mode)
          // Note: rules shall be more and more constraining when depth increases
          let precalculation_mode = ( (nbCodes >= minNbCodesForPrecalculation) // (**) only games for which there may not be enough CPU capacity / time to calculate performances online
                                      && (next_cur_game_idx <= maxDepthForGamePrecalculation) // (-1 or 3)
                                      && ( (next_cur_game_idx <= 1)
                                           || ((next_cur_game_idx == 2) && ((possibleGame && (codeHandler.nbDifferentColors(curGame[0]) <= 2)) || (codeHandler.isVerySimple(curGame[0]) && codeHandler.isVerySimple(curGame[1])) || (nbCodes <= nbCodesForPrecalculationThreshold))) // (***)
                                           || ((next_cur_game_idx == 3) && possibleGame && (codeHandler.nbDifferentColors(curGame[0]) <= 2) && (codeHandler.nbDifferentColors(curGame[1]) <= 2) && (codeHandler.nbDifferentColors(curGame[2]) <= 2)) )
                                      && (!compute_sum_ini) ); // not a leaf
          let str; // (precalculation mode)
          let precalculation_start_time; // (precalculation mode)
          if (precalculation_mode) { // (precalculation mode)
            str = next_cur_game_idx + "|" + compressed_str_from_lists_of_codes_and_markidxs(curGame, marksIdxs, next_cur_game_idx) + "|N:" + nbCodes + "|";
            send_trace_msg("-" + str + " is being computed... " + new Date());
            precalculation_start_time = new Date().getTime();
          } */

          // Initializations
          // ***************

          if (next_depth >= maxDepth) {
            throw new Error("recursiveEvaluatePerformances: max depth reached");
          }

          nextListsOfCodes = listsOfPossibleCodes[next_depth]; // [nbMaxMarks][n]
          nextNbsCodes = nbOfPossibleCodes[next_depth]; // [nbMaxMarks] array

          // Evaluate performances of possible codes
          // ***************************************

          /*
          let nbCodesToGoThrough = nbCodes; // (precalculation mode)
          if (precalculation_mode) { // (precalculation mode)
            nbCodesToGoThrough = nbCodesToGoThrough + initialNbPossibleCodes; // add also impossible codes
          }
          for (idx1 = 0; idx1 < nbCodesToGoThrough; idx1++) { // (precalculation mode)

            // Split precalculation if needed
            // 0:  11111
            // 1:  11112
            // 9:  11122
            // 10: 11123
            // 74: 11223
            // 83: 11234
            // 84: 12345
            // if (first_call && (idx1 != 10) && (idx1 != 74) && (idx1 != 83) && (idx1 != 84)) {
            //  continue;
            // }

            if (idx1 < nbCodes) {
              cur_code = listOfCodes[idx1];
            }
            else {
              cur_code = initialCodeListForPrecalculatedMode[idx1 - nbCodes]; // (precalculation mode) / add also impossible codes

              // Precalculation optimization (1/4): skip cur code if needed
              if (!precalculation_mode) {
                throw new Error("recursiveEvaluatePerformances: precalculation_mode error");
              }
              let skip_cur_code = false;
              for (let i = 0; i < next_cur_game_idx; i++) {
                // (replayed codes are addressed more generally below through useless codes, as all codes equivalent to replayed codes shall be covered to reach an optimization)
                // if (cur_code == curGame[i]) {
                //  skip_cur_code = true; // code replayed
                //  break;
                // }
                if (marksIdxs[i] == worst_mark_idx) { // 0 black + 0 white mark => all colors in this code are obviously impossible
                  codeHandler.fillMark(cur_code, curGame[i], precalculation_mode_mark);
                  if ((precalculation_mode_mark.nbBlacks > 0) || (precalculation_mode_mark.nbWhites > 0)) {
                    skip_cur_code = true; // obviously impossible color played
                    break;
                  }
                }
              }
              // Precalculation optimization (2/4): skip impossible cur code if acceptable
              if ((next_cur_game_idx >= 2) && (nbCodes <= nbCodesForPrecalculationThreshold)) { // (***)
                skip_cur_code = true;
              }
              if (skip_cur_code) {
                continue; // skip cur code
              }
            }
          */
          for (idx1 = 0; idx1 < nbCodes; idx1++) {
            cur_code = listOfCodes[idx1];

            /* if ((depth <= 1) &&(!compute_sum_ini)) { // Specific trace
              console.log(spaces(depth) + "(depth " + depth + ") " + "CURRENT_CODE:" + codeHandler.codeToString(cur_code));
              console.log(spaces(depth) + "cur game: " + str_from_list_of_codes(curGame, next_cur_game_idx));
              console.log(spaces(depth) + "perms: " + cur_permutations_table_size[next_cur_game_idx] + ": "
                          + print_permutation_list(cur_permutations_table[next_cur_game_idx], cur_permutations_table_size[next_cur_game_idx]));
            } */
            // write_me = false; // (traces useful for debug)
            // write_me_for_precalculation = false; // (precalculation mode)

            compute_sum = compute_sum_ini;
            // precalculated_sum = false; useless setting due to compute_sum setting
            if (!compute_sum) {
              sum = 0.0;
              for (idx = 0; idx < nbOfEquivalentCodesAndPerformances; idx++) {
                let known_code = listOfEquivalentCodesAndPerformances[next_depth][idx].equiv_code;
                if (areCodesEquivalent(cur_code, known_code, next_cur_game_idx, false, -1 /* N.A. */, null)) {
                  sum = listOfEquivalentCodesAndPerformances[next_depth][idx].equiv_sum;
                  break;
                }
              }
              if (sum < 0.00) {
                throw new Error("recursiveEvaluatePerformances: negative sum (1): " + sum);
              }
              compute_sum = (sum == 0.0);

              precalculated_sum = false;
              if ( (precalculated_cur_game_or_code >= 0) // both game and code were precalculated OR only game was precalculated
                   && compute_sum /* && (!precalculation_mode) */ ) { // (precalculation mode)
                sum = lookForCodeInPrecalculatedGames(cur_code, next_cur_game_idx, nbCodes);
                if (sum > 0) { // precalculated sum found
                  compute_sum = false;
                  precalculated_sum = true;

                  if (!compute_sum_ini) {
                    listOfEquivalentCodesAndPerformances[next_depth][nbOfEquivalentCodesAndPerformances].equiv_code = cur_code;
                    listOfEquivalentCodesAndPerformances[next_depth][nbOfEquivalentCodesAndPerformances].equiv_sum = sum;
                    nbOfEquivalentCodesAndPerformances++;
                  }
                }
                else { // no precalculated sum found
                  throw new Error("recursiveEvaluatePerformances: cannot find precalculated game and code (possible code): " + codeHandler.codeToString(cur_code));
                  // compute_sum = true;
                }
              }
            }

            if (compute_sum) { // compute_sum

              /* if (first_call) { // (traces useful for debug)
                console.log("assessed: " + codeHandler.codeToString(cur_code));
                write_me = true;
              } */
              // write_me_for_precalculation = true; // (precalculation mode)

              nextNbsCodes.fill(0); // (faster than (or close to) a loop on 0..nbMaxMarks-1)

              // (duplicated code from fillMark() for better performances (1/2) - begin)
              code1_colors[0] = (cur_code & 0x0000000F);
              code1_colors[1] = ((cur_code >> 4) & 0x0000000F);
              code1_colors[2] = ((cur_code >> 8) & 0x0000000F);
              code1_colors[3] = ((cur_code >> 12) & 0x0000000F);
              code1_colors[4] = ((cur_code >> 16) & 0x0000000F);
              code1_colors[5] = ((cur_code >> 20) & 0x0000000F);
              code1_colors[6] = ((cur_code >> 24) & 0x0000000F);
              // (duplicated code from fillMark() for better performances (1/2) - end)

              // Determine all possible marks for cur code
              for (idx2 = 0; idx2 < nbCodes; idx2++) {
                other_code = listOfCodes[idx2];

                if (cur_code != other_code) {
                  // codeHandler.fillMark(cur_code, other_code, mark_perf_tmp);

                  // (duplicated code from fillMark() for better performances (2/2) - begin)
                  let code1 = cur_code;
                  let code2 = other_code;

                  // Marks optimization (1/2) - begin
                  // Notes: - Hash key computing shall be symetrical wrt code1 and code2 and very fast.
                  //        - Bit operations are done on 32 bits in javascript (so for example 'x >> y', with x > 0 on 64 bits, may be negative).
                  //        - The final hash key will anyway always be in the range [0, marks_optimization_mask] after bit mask application with the '&' operator.
                  let sum_codes = code1 + code2;
                  let key = ( (sum_codes /* (use LSBs) */
                              + (sum_codes >> 9) /* (use MSBs) */
                              + code1 * code2 /* (mix LSBs) */) & marks_optimization_mask ); // (duplicated code)
                  marks_already_computed_table_cell = marks_already_computed_table[key];
                  codeX = marks_already_computed_table_cell.code1a;
                  codeY = marks_already_computed_table_cell.code2a;
                  if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
                    mark_perf_tmp.nbBlacks = marks_already_computed_table_cell.nbBlacksa;
                    mark_perf_tmp.nbWhites = marks_already_computed_table_cell.nbWhitesa;
                  }
                  else {
                    codeX = marks_already_computed_table_cell.code1b;
                    codeY = marks_already_computed_table_cell.code2b;
                    if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
                      mark_perf_tmp.nbBlacks = marks_already_computed_table_cell.nbBlacksb;
                      mark_perf_tmp.nbWhites = marks_already_computed_table_cell.nbWhitesb;
                    }
                    else {
                      codeX = marks_already_computed_table_cell.code1c;
                      codeY = marks_already_computed_table_cell.code2c;
                      if ( ((codeX == code1) && (codeY == code2)) || ((codeX == code2) && (codeY == code1)) ) {
                        mark_perf_tmp.nbBlacks = marks_already_computed_table_cell.nbBlacksc;
                        mark_perf_tmp.nbWhites = marks_already_computed_table_cell.nbWhitesc;
                      }
                      // Marks optimization (1/2) - end
                      else {
                        let nbBlacks = 0;
                        let nbWhites = 0;
                        let col1, col2;

                        // The below operations are unrolled for better performances
                        colors_int[0] = true;
                        colors_int[1] = true;
                        colors_int[2] = true;
                        colors_int[3] = true;
                        colors_int[4] = true;
                        colors_int[5] = true;
                        colors_int[6] = true;
                        code2_colors[0] = (code2 & 0x0000000F);
                        code2_colors[1] = ((code2 >> 4) & 0x0000000F);
                        code2_colors[2] = ((code2 >> 8) & 0x0000000F);
                        code2_colors[3] = ((code2 >> 12) & 0x0000000F);
                        code2_colors[4] = ((code2 >> 16) & 0x0000000F);
                        code2_colors[5] = ((code2 >> 20) & 0x0000000F);
                        code2_colors[6] = ((code2 >> 24) & 0x0000000F);

                        for (col1 = 0; col1 < nbColumns; col1++) {
                          if (code1_colors[col1] == code2_colors[col1]) {
                            nbBlacks++;
                          }
                          else {
                            for (col2 = 0; col2 < nbColumns; col2++) {
                              if ((code1_colors[col1] == code2_colors[col2]) && (code1_colors[col2] != code2_colors[col2]) && colors_int[col2]) {
                                colors_int[col2] = false;
                                nbWhites++;
                                break;
                              }
                            }
                          }
                        }

                        mark_perf_tmp.nbBlacks = nbBlacks;
                        mark_perf_tmp.nbWhites = nbWhites;

                        // Marks optimization (2/2) - begin
                        if (marks_already_computed_table_cell.write_index == 0) {
                          marks_already_computed_table_cell.code1a = code1;
                          marks_already_computed_table_cell.code2a = code2;
                          marks_already_computed_table_cell.nbBlacksa = nbBlacks;
                          marks_already_computed_table_cell.nbWhitesa = nbWhites;
                          marks_already_computed_table_cell.write_index = 1;
                        }
                        else if (marks_already_computed_table_cell.write_index == 1) {
                          marks_already_computed_table_cell.code1b = code1;
                          marks_already_computed_table_cell.code2b = code2;
                          marks_already_computed_table_cell.nbBlacksb = nbBlacks;
                          marks_already_computed_table_cell.nbWhitesb = nbWhites;
                          marks_already_computed_table_cell.write_index = 2;
                        }
                        else if (marks_already_computed_table_cell.write_index == 2) {
                          marks_already_computed_table_cell.code1c = code1;
                          marks_already_computed_table_cell.code2c = code2;
                          marks_already_computed_table_cell.nbBlacksc = nbBlacks;
                          marks_already_computed_table_cell.nbWhitesc = nbWhites;
                          marks_already_computed_table_cell.write_index = 0;
                        }
                        else {
                          throw new Error("recursiveEvaluatePerformances: wrong write_index: " + marks_already_computed_table_cell.write_index);
                        }
                        // Marks optimization (2/2) - end
                      }
                    }
                  }
                  // (duplicated code from fillMark() for better performances (2/2) - end)

                  mark_perf_tmp_idx = marksTable_MarkToNb[mark_perf_tmp.nbBlacks][mark_perf_tmp.nbWhites];
                  nextListsOfCodes[mark_perf_tmp_idx][nextNbsCodes[mark_perf_tmp_idx]] = other_code;
                  nextNbsCodes[mark_perf_tmp_idx]++;
                }
                else {
                  nextListsOfCodes[best_mark_idx][nextNbsCodes[best_mark_idx]] = other_code;
                  nextNbsCodes[best_mark_idx]++;
                }

              }

              // Assess cur code
              sum = 0.0;
              sum_marks = 0;

              // Precalculation optimization (3/4): skip "very inefficient" cur code if acceptable
              /* if ( (next_cur_game_idx == 1)
                   && (!(idx1 < nbCodes)) // (no impact on actual computations)
                   && (!(codeHandler.nbDifferentColors(curGame[0]) <= 2)) ) { // (***) (precalculation mode)
                let very_inefficient_cur_code = false;
                for (mark_idx = nbMaxMarks-1; mark_idx >= 0; mark_idx--) {
                  let nextNbCodes = nextNbsCodes[mark_idx];
                  // Go through all sets of possible marks
                  if (nextNbCodes > 0) {
                    // At least one mark with a very high number of remaining possible codes and no further precalculation planned => this code is considered as "very inefficient"
                    if (!(nextNbCodes <= nbCodesForPrecalculationThreshold)) { // (***)
                      very_inefficient_cur_code = true;
                      break;
                    }
                  }
                }
                if (very_inefficient_cur_code) { // (precalculation mode)
                  if (idx1 < nbCodes) {
                    throw new Error("recursiveEvaluatePerformances: very_inefficient_cur_code");
                  }
                  continue; // skip "very inefficient" cur code
                }
              } */

              // let useless_cur_code = false; // (precalculation mode)
              for (mark_idx = nbMaxMarks-1; mark_idx >= 0; mark_idx--) {
                let nextNbCodes = nextNbsCodes[mark_idx];
                // Go through all sets of possible marks
                if (nextNbCodes > 0) {

                  /* if (nextNbCodes == nbCodes) { // (precalculation mode)
                    useless_cur_code = true;
                    break;
                  } */

                  sum_marks += nextNbCodes;
                  if (mark_idx == best_mark_idx) {
                    // sum = sum + 0.0; // 1.0 * 0.0 = 0.0
                    if (sum_marks == nbCodes) break;
                  }
                  else if (nextNbCodes == 1) {
                    sum = sum + 1.0; // 1.0 * 1.0 = 1.0
                    if (sum_marks == nbCodes) break;
                  }
                  else if (nextNbCodes == 2) {
                    sum = sum + 3.0; // 2 * 1.5 = 3.0
                    if (sum_marks == nbCodes) break;
                  }
                  else if (nextNbCodes == 3) {
                    let nextListOfCodesToConsider = nextListsOfCodes[mark_idx];
                    codeHandler.fillMark(nextListOfCodesToConsider[0], nextListOfCodesToConsider[1], mark_perf_tmpa);
                    codeHandler.fillMark(nextListOfCodesToConsider[0], nextListOfCodesToConsider[2], mark_perf_tmpb);
                    if ((mark_perf_tmpa.nbBlacks == mark_perf_tmpb.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpb.nbWhites)) {
                      codeHandler.fillMark(nextListOfCodesToConsider[1], nextListOfCodesToConsider[2], mark_perf_tmpc);
                      if ((mark_perf_tmpa.nbBlacks == mark_perf_tmpc.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpc.nbWhites)) {
                        sum = sum + 6.0; // 3 * ((1+2+3)/3.0) = 6.0
                      }
                      else {
                        sum = sum + 5.0; // 3 * ((1+2+2)/3.0) = 5.0
                      }
                    }
                    else {
                      sum = sum + 5.0; // 3 * ((1+2+2)/3.0) = 5.0
                    }
                    if (sum_marks == nbCodes) break;
                  }
                  else if (nextNbCodes == 4) {

                    // An optimal code being played, if it is not the secret code, can lead to:
                    // a) 3 groups of 1 code => obviously optimal (performance will be 1+2+2+2=7).
                    // b) 1 group of 3 codes => at best, the performance will be 1+2+3+3=9. Thus there can't be any other c) case for the other codes
                    //    (because performance would be 8 < 9), which means all marks are equal for the 6 pairs of codes (performance will be 1+2+3+4=10).
                    // c) 1 group of 1 code and 1 group of 2 codes (performance will be 1+2+2+3=8).

                    let nextListOfCodesToConsider = nextListsOfCodes[mark_idx];
                    codeHandler.fillMark(nextListOfCodesToConsider[0], nextListOfCodesToConsider[1], mark_perf_tmpa); // a
                    codeHandler.fillMark(nextListOfCodesToConsider[0], nextListOfCodesToConsider[2], mark_perf_tmpb); // b
                    codeHandler.fillMark(nextListOfCodesToConsider[0], nextListOfCodesToConsider[3], mark_perf_tmpc); // c
                    let a_b = ((mark_perf_tmpa.nbBlacks == mark_perf_tmpb.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpb.nbWhites));
                    let a_c = ((mark_perf_tmpa.nbBlacks == mark_perf_tmpc.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpc.nbWhites));
                    let b_c = ((mark_perf_tmpb.nbBlacks == mark_perf_tmpc.nbBlacks) && (mark_perf_tmpb.nbWhites == mark_perf_tmpc.nbWhites));
                    if ((!a_b) && (!a_c) && (!b_c)) { // a) 3 different marks when code 0 is played
                      sum = sum + 7.0; // 4 * ((1+2+2+2)/4.0)
                    }
                    else {
                      codeHandler.fillMark(nextListOfCodesToConsider[1], nextListOfCodesToConsider[2], mark_perf_tmpd); // d
                      codeHandler.fillMark(nextListOfCodesToConsider[1], nextListOfCodesToConsider[3], mark_perf_tmpe); // e
                      codeHandler.fillMark(nextListOfCodesToConsider[2], nextListOfCodesToConsider[3], mark_perf_tmpf); // f
                      let a_d = ((mark_perf_tmpa.nbBlacks == mark_perf_tmpd.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpd.nbWhites));
                      let a_e = ((mark_perf_tmpa.nbBlacks == mark_perf_tmpe.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpe.nbWhites));
                      let a_f = ((mark_perf_tmpa.nbBlacks == mark_perf_tmpf.nbBlacks) && (mark_perf_tmpa.nbWhites == mark_perf_tmpf.nbWhites));
                      if (a_b && a_c && a_d && a_e && a_f) { // b) all marks are equal
                        sum = sum + 10.0; // 4 * ((1+2+3+4)/4.0)
                      }
                      else {
                        let d_e = ((mark_perf_tmpd.nbBlacks == mark_perf_tmpe.nbBlacks) && (mark_perf_tmpd.nbWhites == mark_perf_tmpe.nbWhites));
                        if ((!a_d) && (!a_e) && (!d_e)) { // a) 3 different marks when code 1 is played
                          sum = sum + 7.0; // 4 * ((1+2+2+2)/4.0)
                        }
                        else {
                          let c_e = ((mark_perf_tmpc.nbBlacks == mark_perf_tmpe.nbBlacks) && (mark_perf_tmpc.nbWhites == mark_perf_tmpe.nbWhites));
                          let c_f = ((mark_perf_tmpc.nbBlacks == mark_perf_tmpf.nbBlacks) && (mark_perf_tmpc.nbWhites == mark_perf_tmpf.nbWhites));
                          let e_f = ((mark_perf_tmpe.nbBlacks == mark_perf_tmpf.nbBlacks) && (mark_perf_tmpe.nbWhites == mark_perf_tmpf.nbWhites));
                          if ((!c_e) && (!c_f) && (!e_f)) { // a) 3 different marks when code 3 is played
                            sum = sum + 7.0; // 4 * ((1+2+2+2)/4.0)
                          }
                          else {
                            let b_d = ((mark_perf_tmpb.nbBlacks == mark_perf_tmpd.nbBlacks) && (mark_perf_tmpb.nbWhites == mark_perf_tmpd.nbWhites));
                            let b_f = ((mark_perf_tmpb.nbBlacks == mark_perf_tmpf.nbBlacks) && (mark_perf_tmpb.nbWhites == mark_perf_tmpf.nbWhites));
                            let d_f = ((mark_perf_tmpd.nbBlacks == mark_perf_tmpf.nbBlacks) && (mark_perf_tmpd.nbWhites == mark_perf_tmpf.nbWhites));
                            if ((!b_d) && (!b_f) && (!d_f)) { // a) 3 different marks when code 2 is played
                              sum = sum + 7.0; // 4 * ((1+2+2+2)/4.0)
                            }
                            else {
                              // c) after an optimal code is played, if it is not the secret code, there will be 1 group of 1 code and 1 group of 2 codes
                              sum = sum + 8.0; // 4 * ((1+2+2+3)/4.0)
                            }
                          }
                        }
                      }
                    }
                    if (sum_marks == nbCodes) break;

                  }
                  else { // (nextNbCodes >= 5). Note: from 5 codes, "leaf algos" would be very long to write & to optimize

                    // 1) Update cur game
                    // **********************

                    curGame[next_cur_game_idx] = cur_code;
                    marksIdxs[next_cur_game_idx] = mark_idx;

                    // 2) Update possible permutations
                    // *******************************

                    if (nextNbCodes > nbCodesLimitForEquivalentCodesCheck) { // this computing would be useless otherwise
                      let new_perm_cnt = 0;
                      for (let perm_idx = 0; perm_idx < cur_permutations_table_size[next_cur_game_idx]; perm_idx++) {
                        if (areCodesEquivalent(0, 0, next_cur_game_idx+1, true /* assess cur game only */, cur_permutations_table[next_cur_game_idx][perm_idx], null) /* forced permutation */) { // determine which permutations are still valid for cur game
                          if ((cur_permutations_table[next_cur_game_idx][perm_idx] < 0) || (cur_permutations_table[next_cur_game_idx][perm_idx] >= all_permutations_table_size[nbColumns])) {
                            throw new Error("recursiveEvaluatePerformances: invalid permutation index: " + perm_idx);
                          }
                          cur_permutations_table[next_cur_game_idx+1][new_perm_cnt] = cur_permutations_table[next_cur_game_idx][perm_idx];
                          new_perm_cnt++;
                        }
                      }
                      if (new_perm_cnt <= 0) { // identity shall always be valid
                        throw new Error("recursiveEvaluatePerformances: invalid new_perm_cnt value: " + new_perm_cnt);
                      }
                      cur_permutations_table_size[next_cur_game_idx+1] = new_perm_cnt;
                    }
                    else {
                      cur_permutations_table_size[next_cur_game_idx+1] = 0; // (defensive setting)
                    }

                    // 3) Recursive call
                    // *****************

                    sum = sum + nextNbCodes * recursiveEvaluatePerformances(next_depth, nextListsOfCodes[mark_idx], nextNbCodes /*, ((idx1 < nbCodes) && possibleGame) (precalculation mode) */); // (Note: possibleGame = ((idx1 < nbCodes) && possibleGame))
                    if (sum_marks == nbCodes) break;

                  }
                }
              }
              /*
              // Precalculation optimization (4/4): skip useless cur code if acceptable
              if (useless_cur_code) { // (precalculation mode)
                if (idx1 < nbCodes) {
                  throw new Error("recursiveEvaluatePerformances: useless_cur_code");
                }
                continue; // skip useless cur code
              } */

              if (sum_marks != nbCodes) {
                throw new Error("recursiveEvaluatePerformances: invalid sum_marks value (1) (depth=" + depth + ", sum_marks=" + sum_marks + ", sum_marks=" + sum_marks + ")");
              }

              if (!compute_sum_ini) {
                listOfEquivalentCodesAndPerformances[next_depth][nbOfEquivalentCodesAndPerformances].equiv_code = cur_code;
                listOfEquivalentCodesAndPerformances[next_depth][nbOfEquivalentCodesAndPerformances].equiv_sum = sum;
                nbOfEquivalentCodesAndPerformances++;
              }

            } // compute_sum

            // Max possible value of sum = 24 bits (10.000.000 for 7 columns case) + 20 bits (for value 999999 so that < 1/10000 precision) = 44 bits << 52 mantissa bits of double type
            // To simplify, no optimization is done to exit the previous loop when "sum >= best_sum" (after some reordering of the codes and/or marks), recursively or not. The gains
            // were indeed assessed to be low. Such an optimization would moreover not be applied to the first depth, as it is targeted to evaluate all possible codes.
            /* if ((sum < best_sum) && (idx1 < nbCodes)) { // (precalculation mode)
              best_sum = sum;
            } */
            if (sum < best_sum) {
              best_sum = sum;
            }

            // Fill output in case of first call
            // if ((depth <= 1) && (idx1 < nbCodes)) { // (precalculation mode)
            if (depth <= 1) {

              if (first_call) {

                if ((!compute_sum_ini) && (nbCodes > 100)) {

                  let time_elapsed = new Date().getTime() - evaluatePerformancesStartTime;

                  if (compute_sum || precalculated_sum) { // a new class has been evaluated
                    nb_classes_cnt++;
                    /* if (precalculation_mode) { // (precalculation mode)
                      send_trace_msg("______________________________ END OF CLASS ______________________________ " + time_elapsed + " ms");
                    } */
                  }

                  let idxToConsider;
                  let totalNbToConsider;
                  idxToConsider = nb_classes_cnt;
                  totalNbToConsider = curNbClasses;

                  // Processing is aborted when too long
                  if (time_elapsed > maxPerformanceEvaluationTime) {
                    console.log("(processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%))");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }

                  // Anticipation of processing abortion
                  // To simplify, it is assumed here that processing times of all classes are "relatively" close to each other
                  if ( (time_elapsed > 3000) && (time_elapsed > maxPerformanceEvaluationTime*7/100) && (idxToConsider < Math.floor(totalNbToConsider*1.25/100)) ) { // (0.179 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #0)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*10/100) && (idxToConsider < Math.floor(totalNbToConsider*2/100)) ) { // (0.20 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #1)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*15/100) && (idxToConsider < Math.floor(totalNbToConsider*3.75/100)) ) { // (0.25 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #2)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*20/100) && (idxToConsider < Math.floor(totalNbToConsider*6/100)) ) { // (0.30 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #3)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*30/100) && (idxToConsider < Math.floor(totalNbToConsider*12/100)) ) { // (0.40 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #4)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*40/100) && (idxToConsider < Math.floor(totalNbToConsider*20/100)) ) { // (0.50 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #5)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*50/100) && (idxToConsider < Math.floor(totalNbToConsider*30/100)) ) { // (0.60 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #6)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*60/100) && (idxToConsider < Math.floor(totalNbToConsider*42/100)) ) { // (0.70 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #7)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*70/100) && (idxToConsider < Math.floor(totalNbToConsider*56/100)) ) { // (0.80 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #8)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }
                  if ( (time_elapsed > maxPerformanceEvaluationTime*80/100) && (idxToConsider < Math.floor(totalNbToConsider*72/100)) ) { // (0.90 ratio)
                    console.log("(anticipation of processing abortion after " + time_elapsed + "ms (" + Math.round(100*idxToConsider/totalNbToConsider) + "%) #9)");
                    listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                    listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                    particularCodeGlobalPerformance = PerformanceNA; // output
                    recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN;
                  }

                  if (idx1+1 == nbCodes) { // last loop
                    if (idxToConsider != totalNbToConsider) { // not 100%
                      throw new Error("recursiveEvaluatePerformances: invalid code numbers (" + idxToConsider + " != " + totalNbToConsider + ")");
                    }
                  }

                }

                listOfGlobalPerformances[idx1] = 1.0 + sum / nbCodes; // output
                /* if (write_me) { // (traces useful for debug)
                  let time_elapsed = new Date().getTime() - evaluatePerformancesStartTime;
                  console.log("perf #" + idx1 + ": " + listOfGlobalPerformances[idx1] + " / " + time_elapsed + "ms");
                } */

              }
              else if ((depth == 0) || (depth == 1)) { // first and second levels of recursivity
                let time_elapsed = new Date().getTime() - evaluatePerformancesStartTime;

                // Processing is aborted when too long
                if (time_elapsed > maxPerformanceEvaluationTime) {
                  listOfGlobalPerformances[0] = PerformanceNA; // output (basic reset)
                  listOfGlobalPerformances[nbCodes-1] = PerformanceNA; // output (basic reset)
                  particularCodeGlobalPerformance = PerformanceNA; // output
                  recursiveEvaluatePerformancesWasAborted = true; return PerformanceUNKNOWN; // (final returned value will be invalid)
                }
                time_elapsed = undefined;
              }
              else {
                throw new Error("recursiveEvaluatePerformances: internal error (1)");
              }

            } // (depth <= 1)

            /* if (precalculation_mode && write_me_for_precalculation) { // (precalculation mode)
              str = str + codeHandler.compressCodeToString(cur_code) + ":" + Math.round(sum).toString(16).toUpperCase() + ",";
            } */

          } // (loop on idx1)

          /* if (precalculation_mode) { // (precalculation mode)
            if (!str.endsWith(",")) {
              throw new Error("recursiveEvaluatePerformances: internal error (2)");
            }
            str = "\"" + str.substring(0, str.length-1) + ".\" +"; // remove last ','
            // console.log(str);
            let precalculation_time = new Date().getTime() - precalculation_start_time;
            if (precalculation_time >= 2700) { // 2700 = 2.7 seconds on i5 processor or on Linux VB running on i7 processor
              send_trace_msg(str);
            }
            else {
              send_trace_msg("skipped (" + precalculation_time + "ms)");
            }
          } */

          // Evaluate performance of impossible code if needed
          // *************************************************

          if (first_call && (particularCodeToAssess != 0 /* empty code */)) {

            cur_code = particularCodeToAssess;

            let particular_precalculated_sum = false;
            if ( (precalculated_cur_game_or_code > 0) // both game and code were precalculated
                 && (!compute_sum_ini) /* && (!precalculation_mode) */ ) { // (precalculation mode)
              sum = lookForCodeInPrecalculatedGames(cur_code, next_cur_game_idx, nbCodes);
              if (sum > 0) { // precalculated sum found
                particular_precalculated_sum = true;
              }
              else {
                throw new Error("recursiveEvaluatePerformances: cannot find precalculated game and code (impossible code): " + codeHandler.codeToString(cur_code));
              }
            }

            if (!particular_precalculated_sum) {

              nextNbsCodes.fill(0); // (faster than (or close to) a loop on 0..nbMaxMarks-1)

              // Determine all possible marks for cur code
              for (idx2 = 0; idx2 < nbCodes; idx2++) {
                other_code = listOfCodes[idx2];
                codeHandler.fillMark(cur_code, other_code, mark_perf_tmp);
                mark_perf_tmp_idx = marksTable_MarkToNb[mark_perf_tmp.nbBlacks][mark_perf_tmp.nbWhites];
                nextListsOfCodes[mark_perf_tmp_idx][nextNbsCodes[mark_perf_tmp_idx]] = other_code;
                nextNbsCodes[mark_perf_tmp_idx]++;
              }

              // Assess cur code
              sum = 0.0;
              sum_marks = 0;
              for (mark_idx = nbMaxMarks-1; mark_idx >= 0; mark_idx--) {
                let nextNbCodes = nextNbsCodes[mark_idx];
                // Go through all sets of possible marks
                if (nextNbCodes > 0) {
                  sum_marks += nextNbCodes;
                  if (mark_idx == best_mark_idx) {
                    throw new Error("recursiveEvaluatePerformances: impossible code is possible");
                  }
                  else if (nextNbCodes == 1) {
                    sum = sum + 1.0; // 1.0 * 1.0 = 1.0
                  }
                  else if (nextNbCodes == 2) {
                    sum = sum + 3.0; // 2 * 1.5 = 3.0
                  }
                  else {

                    // 1) Update cur game
                    // **********************

                    curGame[next_cur_game_idx] = cur_code;
                    marksIdxs[next_cur_game_idx] = mark_idx;

                    // 2) Update possible permutations
                    // *******************************

                    if (nextNbCodes > nbCodesLimitForEquivalentCodesCheck) { // this computing would be useless otherwise
                      let new_perm_cnt = 0;
                      for (let perm_idx = 0; perm_idx < cur_permutations_table_size[next_cur_game_idx]; perm_idx++) {
                        if (areCodesEquivalent(0, 0, next_cur_game_idx+1, true /* assess cur game only */, cur_permutations_table[next_cur_game_idx][perm_idx], null) /* forced permutation */) { // determine which permutations are still valid for cur game
                          if ((cur_permutations_table[next_cur_game_idx][perm_idx] < 0) || (cur_permutations_table[next_cur_game_idx][perm_idx] >= all_permutations_table_size[nbColumns])) {
                            throw new Error("recursiveEvaluatePerformances: invalid permutation index: " + perm_idx);
                          }
                          cur_permutations_table[next_cur_game_idx+1][new_perm_cnt] = cur_permutations_table[next_cur_game_idx][perm_idx];
                          new_perm_cnt++;
                        }
                      }
                      if (new_perm_cnt <= 0) { // identity shall always be valid
                        throw new Error("recursiveEvaluatePerformances: invalid new_perm_cnt value: " + new_perm_cnt);
                      }
                      cur_permutations_table_size[next_cur_game_idx+1] = new_perm_cnt;
                    }
                    else {
                      cur_permutations_table_size[next_cur_game_idx+1] = 0; // (defensive setting)
                    }

                    // 3) Recursive call
                    // *****************

                    sum = sum + nextNbCodes * recursiveEvaluatePerformances(next_depth, nextListsOfCodes[mark_idx], nextNbCodes /*, false (precalculation mode) */);

                  }
                }
              }
              if (sum_marks != nbCodes) {
                throw new Error("recursiveEvaluatePerformances: invalid sum_marks value (2) (depth=" + depth + ", sum_marks=" + sum_marks + ", sum_marks=" + sum_marks + ")");
              }

            } // !particular_precalculated_sum

            // Fill output
            particularCodeGlobalPerformance = 1.0 + sum / nbCodes; // output

          }

          return 1.0 + best_sum / nbCodes;

        }

        // ********************************
        // Handle messages from main thread
        // ********************************

        self.onmessage = function(e) {

          if (abort_worker_process) { // Avoid cumulative errors
            return;
          }

          try {

            if (message_processing_ongoing) {
              throw new Error("GameSolver event handling error (message_processing_ongoing is true)");
            }
            message_processing_ongoing = true;

            if (e.data == undefined) {
              throw new Error("data is undefined");
            }
            let data = e.data;

            if (data.req_type == undefined) {
              throw new Error("req_type is undefined");
            }

            // **************
            // Initialization
            // **************

            if (data.req_type == 'INIT') {

              if (!IAmAliveMessageSent) {
                self.postMessage({'rsp_type': 'I_AM_ALIVE'}); // first message sent
                IAmAliveMessageSent = true;
              }

              // *******************
              // Read message fields
              // *******************

              if (init_done) {
                throw new Error("INIT phase / double initialization");
              }

              if (data.nbColumns == undefined) {
                throw new Error("INIT phase / nbColumns is undefined");
              }
              nbColumns = Number(data.nbColumns);
              if ( isNaN(nbColumns) || (nbColumns < nbMinColumns) || (nbColumns > nbMaxColumns) ) {
                throw new Error("INIT phase / invalid nbColumns: " + nbColumns);
              }

              if (data.nbColors == undefined) {
                throw new Error("INIT phase / nbColors is undefined");
              }
              nbColors = Number(data.nbColors);
              if ( isNaN(nbColors) || (nbColors < nbMinColors) || (nbColors > nbMaxColors) ) {
                throw new Error("INIT phase / invalid nbColors: " + nbColors);
              }

              if (data.nbMaxAttempts == undefined) {
                throw new Error("INIT phase / nbMaxAttempts is undefined");
              }
              nbMaxAttempts = Number(data.nbMaxAttempts);
              if ( isNaN(nbMaxAttempts) || (nbMaxAttempts < overallNbMinAttempts) || (nbMaxAttempts > overallNbMaxAttempts) ) {
                throw new Error("INIT phase / invalid nbMaxAttempts: " + nbMaxAttempts);
              }

              if (data.nbMaxPossibleCodesShown == undefined) {
                throw new Error("INIT phase / nbMaxPossibleCodesShown is undefined");
              }
              nbMaxPossibleCodesShown = Number(data.nbMaxPossibleCodesShown);
              if ( isNaN(nbMaxPossibleCodesShown) || (nbMaxPossibleCodesShown < 5) || (nbMaxPossibleCodesShown > 100) ) {
                throw new Error("INIT phase / invalid nbMaxPossibleCodesShown: " + nbMaxPossibleCodesShown);
              }
              possibleCodesShown = new Array(nbMaxPossibleCodesShown);
              globalPerformancesShown = new Array(nbMaxPossibleCodesShown);
              for (let i = 0; i < nbMaxPossibleCodesShown; i++) {
                globalPerformancesShown[i] = PerformanceNA;
              }

              if (data.first_session_game == undefined) {
                throw new Error("INIT phase / first_session_game is undefined");
              }
              let first_session_game = data.first_session_game;

              if (data.game_id == undefined) {
                throw new Error("INIT phase / game_id is undefined");
              }
              game_id = Number(data.game_id);
              if ( isNaN(game_id) || (game_id < 0) ) {
                throw new Error("INIT phase / invalid game_id: " + game_id);
              }

              if (data.debug_mode == undefined) {
                throw new Error("INIT phase / debug_mode is undefined");
              }
              if (data.debug_mode != "") {
                if (data.debug_mode == "dbg") {
                  for (let i = 0; i == i; i++) {
                    // if (i % 2 == 0) {console.log(" ");} else {console.log("  ")};
                  }
                }
              }

              // ********************
              // Initialize variables
              // ********************

              codesPlayed = new Array(nbMaxAttempts);
              for (let i = 0; i < nbMaxAttempts; i++) {
                codesPlayed[i] = 0;
              }
              marks = new Array(nbMaxAttempts);
              for (let i = 0; i < nbMaxAttempts; i++) {
                marks[i] = {nbBlacks:0, nbWhites:0};
              }

              codeHandler = new CodeHandler(nbColumns, nbColors, nbMinColumns, nbMaxColumns, emptyColor)

              initialNbPossibleCodes = Math.round(Math.pow(nbColors,nbColumns));
              previousNbOfPossibleCodes = initialNbPossibleCodes;
              nextNbOfPossibleCodes = initialNbPossibleCodes;

              minNbColorsTable = new Array(nbColors+1);
              maxNbColorsTable = new Array(nbColors+1);
              nbColorsTableForMinMaxNbColors = new Array(nbColors+1);

              switch (nbColumns) {
                case 3:
                  // ******************************************
                  // * Maximum number of marks for 3 columns: *
                  // * 0 black  => 0..3 whites => 4 marks     *
                  // * 1 black  => 0..2 whites => 3 marks     *
                  // * 2 blacks => 0 white     => 1 mark      *
                  // * 3 blacks => 0 white     => 1 mark      *
                  // *                *** TOTAL:  9 marks *** *
                  // ******************************************
                  nbMaxMarks = 9;
                  maxPerformanceEvaluationTime = baseOfMaxPerformanceEvaluationTime*10/30; // (short games)
                  nbOfCodesForSystematicEvaluation = initialNbPossibleCodes; // systematic performance evaluation
                  nbOfCodesForSystematicEvaluation_ForMemAlloc = initialNbPossibleCodes;
                  initialNbClasses = 3; // {111, 112, 123}
                  maxDepth = Math.min(11, overallMaxDepth);
                  marks_optimization_mask = 0x1FFF;
                  maxDepthForGamePrecalculation = -1; // no game precalculation needed (-1 or 3)
                  break;
                case 4:
                  nbMaxMarks = 14;
                  maxPerformanceEvaluationTime = baseOfMaxPerformanceEvaluationTime*20/30; // (short games)
                  nbOfCodesForSystematicEvaluation = initialNbPossibleCodes; // systematic performance evaluation
                  nbOfCodesForSystematicEvaluation_ForMemAlloc = initialNbPossibleCodes; // game precalculation (*)
                  initialNbClasses = 5; // {1111, 1112, 1122, 1123, 1234}
                  maxDepth = Math.min(12, overallMaxDepth);
                  marks_optimization_mask = 0x3FFF;
                  maxDepthForGamePrecalculation = 3; // game precalculation (-1 or 3) (*)
                  break;
                case 5:
                  nbMaxMarks = 20;
                  maxPerformanceEvaluationTime = baseOfMaxPerformanceEvaluationTime*44/30;
                  nbOfCodesForSystematicEvaluation = Math.min(refNbOfCodesForSystematicEvaluation, initialNbPossibleCodes); // initialNbPossibleCodes in (precalculation mode)
                  nbOfCodesForSystematicEvaluation_ForMemAlloc = initialNbPossibleCodes; // game precalculation (*)
                  initialNbClasses = 7; // {11111, 11112, 11122, 11123, 11223, 11234, 12345}
                  maxDepth = Math.min(13, overallMaxDepth);
                  marks_optimization_mask = 0xFFFF; // (do not consume too much memory)
                  maxDepthForGamePrecalculation = 3; // game precalculation (-1 or 3) (*)
                  break;
                case 6:
                  nbMaxMarks = 27;
                  maxPerformanceEvaluationTime = baseOfMaxPerformanceEvaluationTime*52/30;
                  nbOfCodesForSystematicEvaluation = Math.min(refNbOfCodesForSystematicEvaluation, initialNbPossibleCodes);
                  nbOfCodesForSystematicEvaluation_ForMemAlloc = nbOfCodesForSystematicEvaluation;
                  initialNbClasses = 11; // {111111, 111112, 111122, 111123, 111222, 111223, 111234, 112233, 112234, 112345, 123456}
                  maxDepth = Math.min(14, overallMaxDepth);
                  marks_optimization_mask = 0xFFFF; // (do not consume too much memory)
                  maxDepthForGamePrecalculation = -1; // no game precalculation as precalculation would be too long (-1 or 3)
                  break;
                case 7:
                  // ******************************************
                  // * Maximum number of marks for 7 columns: *
                  // * 0 black  => 0..7 whites => 8 marks     *
                  // * 1 black  => 0..6 whites => 7 marks     *
                  // * 2 blacks => 0..5 whites => 6 marks     *
                  // * ...                                    *
                  // * 5 blacks => 0..2 whites => 3 marks     *
                  // * 6 blacks => 0 white     => 1 mark      *
                  // * 7 blacks => 0 white     => 1 mark      *
                  // *                *** TOTAL: 35 marks *** *
                  // ******************************************
                  nbMaxMarks = 35;
                  maxPerformanceEvaluationTime = baseOfMaxPerformanceEvaluationTime*60/30;
                  nbOfCodesForSystematicEvaluation = Math.min(refNbOfCodesForSystematicEvaluation, initialNbPossibleCodes);
                  nbOfCodesForSystematicEvaluation_ForMemAlloc = nbOfCodesForSystematicEvaluation;
                  initialNbClasses = 15; // {1111111, 1111112, 1111122, 1111123, 1111222, 1111223, 1111234, 1112223, 1112233, 1112234, 1112345, 1122334, 1122345, 1123456, 1234567}
                  maxDepth = Math.min(16, overallMaxDepth);
                  marks_optimization_mask = 0xFFFF; // (do not consume too much memory)
                  maxDepthForGamePrecalculation = -1; // no game precalculation as precalculation would be too long (-1 or 3)
                  break;
                default:
                  throw new Error("INIT phase / invalid nbColumns: " + nbColumns);
              }

              if (nbOfCodesForSystematicEvaluation > nbOfCodesForSystematicEvaluation_ForMemAlloc) {
                throw new Error("INIT phase / internal error: nbOfCodesForSystematicEvaluation");
              }
              if ( (maxDepthForGamePrecalculation > maxDepthForGamePrecalculation_ForMemAlloc)
                   || ((maxDepthForGamePrecalculation != -1) && (maxDepthForGamePrecalculation != 3)) ) { // (-1 or 3)
                throw new Error("INIT phase / internal error (maxDepthForGamePrecalculation: " + maxDepthForGamePrecalculation + ")");
              }
              if (minNbCodesForPrecalculation <= nbCodesLimitForEquivalentCodesCheck) {
                throw new Error("INIT phase / internal error: minNbCodesForPrecalculation");
              }

              marksTable_MarkToNb = new Array(nbColumns+1); // nbBlacks in 0..nbColumns
              for (let i = 0; i <= nbColumns; i++) { // nbBlacks
                marksTable_MarkToNb[i] = new Array(nbColumns+1); // nbWhites in 0..nbColumns
                for (let j = 0; j <= nbColumns; j++) { // nbWhites
                  marksTable_MarkToNb[i][j] = -1; // N.A.
                }
              }
              marksTable_NbToMark = new Array(nbMaxMarks); // mark indexes in 0..nbMaxMarks-1
              for (let i = 0; i < nbMaxMarks; i++) { // mark indexes
                marksTable_NbToMark[i] = {nbBlacks:-1, nbWhites:-1}; // N.A.
              }
              let mark_cnt = 0;
              for (let i = 0; i <= nbColumns; i++) { // nbBlacks
                for (let j = 0; j <= nbColumns; j++) { // nbWhites
                  let mark_tmp = {nbBlacks:i, nbWhites:j};
                  if (codeHandler.isMarkValid(mark_tmp)) { // go through all valid marks
                    if (mark_cnt >= nbMaxMarks) {
                      throw new Error("INIT phase / internal error (mark_cnt: " + mark_cnt + ") (1)");
                    }
                    marksTable_NbToMark[mark_cnt] = mark_tmp;
                    marksTable_MarkToNb[i][j] = mark_cnt;
                    mark_cnt++;
                  }
                }
              }
              if (mark_cnt != nbMaxMarks) {
                throw new Error("INIT phase / internal error (mark_cnt: " + mark_cnt + ") (2)");
              }
              if (marksTable_NbToMark.length != nbMaxMarks) {
                throw new Error("INIT phase / internal error (marksTable_NbToMark length: " + marksTable_NbToMark.length + ")");
              }
              if (marksTable_MarkToNb.length != nbColumns+1) {
                throw new Error("INIT phase / internal error (marksTable_MarkToNb length: " + marksTable_MarkToNb.length + ") (1)");
              }
              for (let i = 0; i <= nbColumns; i++) { // nbBlacks
                if (marksTable_MarkToNb[i].length != nbColumns+1) {
                  throw new Error("INIT phase / internal error (marksTable_MarkToNb length: " + marksTable_MarkToNb.length + ") (2)");
                }
              }

              best_mark_idx = marksTable_MarkToNb[nbColumns][0];
              worst_mark_idx = marksTable_MarkToNb[0][0];

              possibleCodesForPerfEvaluation = new Array(2);
              possibleCodesForPerfEvaluation[0] = new Array(nbOfCodesForSystematicEvaluation_ForMemAlloc);
              possibleCodesForPerfEvaluation[1] = new Array(nbOfCodesForSystematicEvaluation_ForMemAlloc);
              // initialCodeListForPrecalculatedMode = new Array(nbOfCodesForSystematicEvaluation_ForMemAlloc); // (precalculation mode)

              // **********
              // Update GUI
              // **********

              colorsFoundCode = codeHandler.setAllColorsIdentical(emptyColor); // value at game start
              for (let color = 1; color <= nbColors; color++) { // values at game start
                minNbColorsTable[color] = 0;
                maxNbColorsTable[color] = nbColumns;
              }

              self.postMessage({'rsp_type': 'NB_POSSIBLE_CODES', 'nbOfPossibleCodes_p': initialNbPossibleCodes, 'colorsFoundCode_p': colorsFoundCode, 'minNbColorsTable_p': minNbColorsTable.toString(), 'maxNbColorsTable_p': maxNbColorsTable.toString(), 'attempt_nb': 1, 'game_id': game_id});

              let nb_possible_codes_listed = fillShortInitialPossibleCodesTable(possibleCodesForPerfEvaluation[1], nbOfCodesForSystematicEvaluation_ForMemAlloc);
              if (possibleCodesForPerfEvaluation_lastIndexWritten != -1) {
                throw new Error("INIT phase / inconsistent writing into possibleCodesForPerfEvaluation");
              }
              possibleCodesForPerfEvaluation_lastIndexWritten = 1;

              /* if (8*8*8*8*8 != fillShortInitialPossibleCodesTable(initialCodeListForPrecalculatedMode, nbOfCodesForSystematicEvaluation_ForMemAlloc)) { // (precalculation mode)
                throw new Error("INIT phase / internal error");
              } */

              init_done = true;

            }

            // ***********
            // New attempt
            // ***********

            else if (init_done && (data.req_type == 'NEW_ATTEMPT')) {

              // *******************
              // Read message fields
              // *******************

              if (data.curAttemptNumber == undefined) {
                throw new Error("NEW_ATTEMPT phase / curAttemptNumber is undefined");
              }
              let curAttemptNumber_tmp = Number(data.curAttemptNumber);
              if ( isNaN(curAttemptNumber_tmp) || (curAttemptNumber_tmp < 0) || (curAttemptNumber_tmp > nbMaxAttempts) ) {
                throw new Error("NEW_ATTEMPT phase / invalid curAttemptNumber: " + curAttemptNumber_tmp);
              }
              if (curAttemptNumber_tmp != curAttemptNumber+1) { // attempt numbers shall be consecutive
                throw new Error("NEW_ATTEMPT phase / non consecutive curAttemptNumber values: " + curAttemptNumber + ", " + curAttemptNumber_tmp);
              }
              curAttemptNumber = curAttemptNumber_tmp;

              if (data.nbMaxAttemptsForEndOfGame == undefined) {
                throw new Error("NEW_ATTEMPT phase / nbMaxAttemptsForEndOfGame is undefined");
              }
              nbMaxAttemptsForEndOfGame = Number(data.nbMaxAttemptsForEndOfGame);
              if ( isNaN(nbMaxAttemptsForEndOfGame) || (nbMaxAttemptsForEndOfGame < 0) || (nbMaxAttemptsForEndOfGame > nbMaxAttempts) || (nbMaxAttemptsForEndOfGame < curAttemptNumber) ) {
                throw new Error("NEW_ATTEMPT phase / invalid nbMaxAttemptsForEndOfGame: " + nbMaxAttemptsForEndOfGame + ", " + curAttemptNumber);
              }

              if (data.code == undefined) {
                throw new Error("NEW_ATTEMPT phase / code is undefined");
              }
              codesPlayed[curAttemptNumber-1] = Number(data.code);
              if ( isNaN(codesPlayed[curAttemptNumber-1]) || !codeHandler.isFullAndValid(codesPlayed[curAttemptNumber-1]) ) {
                throw new Error("NEW_ATTEMPT phase / invalid code: " + codesPlayed[curAttemptNumber-1]);
              }

              if (data.mark_nbBlacks == undefined) {
                throw new Error("NEW_ATTEMPT phase / mark_nbBlacks is undefined");
              }
              let mark_nbBlacks = Number(data.mark_nbBlacks);
              if ( isNaN(mark_nbBlacks) || (mark_nbBlacks < 0) || (mark_nbBlacks > nbColumns) ) {
                throw new Error("NEW_ATTEMPT phase / invalid mark_nbBlacks: " + mark_nbBlacks + ", " + nbColumns);
              }
              let gameWon = (mark_nbBlacks == nbColumns);
              if (data.mark_nbWhites == undefined) {
                throw new Error("NEW_ATTEMPT phase / mark_nbWhites is undefined");
              }
              let mark_nbWhites = Number(data.mark_nbWhites);
              if ( isNaN(mark_nbWhites) || (mark_nbWhites < 0) || (mark_nbWhites > nbColumns) ) {
                throw new Error("NEW_ATTEMPT phase / invalid mark_nbWhites: " + mark_nbWhites + ", " + nbColumns);
              }
              marks[curAttemptNumber-1] = {nbBlacks:mark_nbBlacks, nbWhites:mark_nbWhites};
              if (!codeHandler.isMarkValid(marks[curAttemptNumber-1])) {
                throw new Error("NEW_ATTEMPT phase / invalid mark: " + mark_nbBlacks + "B, " + mark_nbWhites + "W, " + nbColumns);
              }

              if (data.precalculated_games == undefined) {
                throw new Error("NEW_ATTEMPT phase / precalculated_games is undefined");
              }
              if (data.precalculated_games != "") {
                if ( (nbColumns != 5) || (curAttemptNumber != 1) ) { // precalculated_games is only expected at the first attempt of 5 columns games
                  throw new Error("NEW_ATTEMPT phase / unexpected precalculated_games: " + nbColumns + ", " + curAttemptNumber);
                }
                precalculated_games_5columns = precalculated_games_5columns + data.precalculated_games;
              }

              if (data.game_id == undefined) {
                throw new Error("NEW_ATTEMPT phase / game_id is undefined");
              }
              let attempt_game_id = Number(data.game_id);
              if ( isNaN(attempt_game_id) || (attempt_game_id < 0) || (attempt_game_id != game_id) ) {
                throw new Error("NEW_ATTEMPT phase / invalid game_id: " + attempt_game_id + " (" + game_id + ")");
              }

              // ***************
              // Initializations
              // ***************

              // 1) Update cur game
              // **********************

              if (!initialInitDone) {
                initialInitDone = true;
                curGame = new Array(nbMaxAttempts+maxDepth);
                curGame.fill(0); /* empty code */
                marksIdxs = new Array(nbMaxAttempts+maxDepth);
                marksIdxs.fill(-1);
                generateAllPermutations();
              }

              if (curAttemptNumber >= 2) {
                // Notes on "future-based" criteria:
                // - to simplify, useless codes (likely to be played near game end) are not excluded from cur game.
                // - to simplify, codes with a 0 black + 0 white mark (likely to be played at game beginning, whose performances are targeted
                //   to be precalculated) are not excluded from cur game. More generally, the fact that impossible colors are interchangeable
                //   is not exploited (as mostly covered by 0 black + 0 white mark cases at game beginning / as difficult to take into account
                //   recursively at small cost / as bijections would have to be calculated in some specific way(s) for those cases).
                // - handling a "dynamic dictionary of games" containing sets of (k to k+n, k >= 5) possible remaining codes and their associated
                //   performance was assessed and does not allow to reach any gain for long evaluations (too low percentage of repetitive games).
                curGame[curAttemptNumber-2] = codesPlayed[curAttemptNumber-2];
                marksIdxs[curAttemptNumber-2] = marksTable_MarkToNb[marks[curAttemptNumber-2].nbBlacks][marks[curAttemptNumber-2].nbWhites];
              }
              curGameSize = curAttemptNumber-1; // (equal to 0 at first attempt)

              // Check cur game (useful for subsequent equivalent codes processing - duplicated code)
              if (curGameSize != curAttemptNumber-1) {
                throw new Error("NEW_ATTEMPT phase / invalid curGameSize");
              }
              for (let idx = 0; idx < curGameSize; idx++) {
                if ( (curGame[idx] != codesPlayed[idx]) || (!codeHandler.isFullAndValid(curGame[idx])) ) {
                  throw new Error("NEW_ATTEMPT phase / invalid cur game (" + idx + ")");
                }
                if ( (!codeHandler.marksEqual(marksTable_NbToMark[marksIdxs[idx]], marks[idx])) || (!codeHandler.isMarkValid(marksTable_NbToMark[marksIdxs[idx]])) )  {
                  throw new Error("NEW_ATTEMPT phase /  invalid cur marks (" + idx + ")");
                }
              }

              // 2) Update possible permutations
              // *******************************

              // Note: to simplify, more complex algorithms are not used to update possible permutations. For instance: games {[1 1 2] [1 3 4]}, {[1 1 2] [3 4 3]}
              //       and {[1 2 3] [1 1 1]} lead to numbers of possible permutations which are underestimated.

              if (curAttemptNumber >= 2) {
                if (cur_permutations_table_size[curGameSize-1] <= 0) {
                  throw new Error("NEW_ATTEMPT phase / invalid cur_permutations_table_size value: " + cur_permutations_table_size[curGameSize-1]);
                }
                let new_perm_cnt = 0;
                for (let perm_idx = 0; perm_idx < cur_permutations_table_size[curGameSize-1]; perm_idx++) {
                  if (areCodesEquivalent(0, 0, curGameSize, true /* assess cur game only */, cur_permutations_table[curGameSize-1][perm_idx], null) /* forced permutation */) { // determine which permutations are still valid for cur game
                    if ((cur_permutations_table[curGameSize-1][perm_idx] < 0) || (cur_permutations_table[curGameSize-1][perm_idx] >= all_permutations_table_size[nbColumns])) {
                      throw new Error("NEW_ATTEMPT phase / invalid permutation index: " + perm_idx);
                    }
                    cur_permutations_table[curGameSize][new_perm_cnt] = cur_permutations_table[curGameSize-1][perm_idx];
                    new_perm_cnt++;
                  }
                }
                if (new_perm_cnt <= 0) { // identity shall always be valid
                  throw new Error("NEW_ATTEMPT phase / invalid new_perm_cnt value: " + new_perm_cnt);
                }
                cur_permutations_table_size[curGameSize] = new_perm_cnt;
              }

              // **************************************************
              // A.1) Compute number and list of new possible codes
              // **************************************************

              console.log(String(curAttemptNumber) + ": " + codeHandler.markToString(marks[curAttemptNumber-1]) + " " + codeHandler.codeToString(codesPlayed[curAttemptNumber-1]));

              if (marks_already_computed_table == null) {
                marks_already_computed_table = new Array(marks_optimization_mask+1);
                for (let i = 0; i < marks_already_computed_table.length; i++) {
                  marks_already_computed_table[i] = { code1a:0, code2a:0, nbBlacksa:-1, nbWhitesa:-1,
                                                      code1b:0, code2b:0, nbBlacksb:-1, nbWhitesb:-1,
                                                      code1c:0, code2c:0, nbBlacksc:-1, nbWhitesc:-1,
                                                      write_index:0};
                }
              }

              if (curAttemptNumber == 1) { // first attempt
                possibleCodesAfterNAttempts = new OptimizedArrayList(Math.max(1 + Math.floor(initialNbPossibleCodes/nb_max_internal_lists), 5*nb_max_internal_lists));
              }

              previousNbOfPossibleCodes = nextNbOfPossibleCodes;
              nextNbOfPossibleCodes = computeNbOfPossibleCodes(curAttemptNumber+1, nbOfCodesForSystematicEvaluation_ForMemAlloc, possibleCodesForPerfEvaluation[(curAttemptNumber+1)%2]);
              if (possibleCodesForPerfEvaluation_lastIndexWritten != (curAttemptNumber%2)) {
                throw new Error("NEW_ATTEMPT phase / inconsistent writing into possibleCodesForPerfEvaluation");
              }
              possibleCodesForPerfEvaluation_lastIndexWritten = (curAttemptNumber+1)%2;
              if (nextNbOfPossibleCodes > previousNbOfPossibleCodes) {
                throw new Error("NEW_ATTEMPT phase / inconsistent numbers of possible codes: " + nextNbOfPossibleCodes + " > " + previousNbOfPossibleCodes);
              }

              // ***************
              // A.2) Update GUI
              // ***************

              if (curAttemptNumber+1 <= nbMaxAttemptsForEndOfGame) { // not last game attempt
                self.postMessage({'rsp_type': 'NB_POSSIBLE_CODES', 'nbOfPossibleCodes_p': nextNbOfPossibleCodes, 'colorsFoundCode_p': colorsFoundCode, 'minNbColorsTable_p': minNbColorsTable.toString(), 'maxNbColorsTable_p': maxNbColorsTable.toString(), 'attempt_nb': (curAttemptNumber+1), 'game_id': game_id});
              }

              // ***************************************
              // B.1) Compute performance of code played
              // ***************************************

              let best_global_performance = PerformanceNA;
              let code_played_relative_perf = PerformanceNA;
              let relative_perf_evaluation_done = false;

              // a) Useless code
              // ***************

              if ((nextNbOfPossibleCodes == previousNbOfPossibleCodes) && (!gameWon)) {
                // To simplify, for an useless code, performances will be computed at next useful code
                best_global_performance = PerformanceUNKNOWN;
                code_played_relative_perf = -1.00;
                relative_perf_evaluation_done = true;
              }

              // b) Useful code
              // **************

              else {

                // Check if cur game and code (whether possible or impossible) were precalculated
                // **********************************************************************************

                let precalculated_cur_game_or_code = -1; // nothing was precalculated
                // precalculated_cur_game_or_code shall keep being -1 in precalculation mode => below code to comment in (precalculation mode)
                if ( (previousNbOfPossibleCodes >= minNbCodesForPrecalculation) // (**) only games for which there may not be enough CPU capacity / time to calculate performances online
                     && (curGameSize <= maxDepthForGamePrecalculation) ) { // (-1 or 3)
                  precalculated_cur_game_or_code = lookForCodeInPrecalculatedGames(codesPlayed[curAttemptNumber-1], curGameSize, previousNbOfPossibleCodes);
                }

                // Main useful code processing
                // ***************************

                if ( (precalculated_cur_game_or_code > 0) // both game and code were precalculated
                     || ((precalculated_cur_game_or_code == 0) && (previousNbOfPossibleCodes <= nbOfCodesForSystematicEvaluation)) // only game was precalculated and number of possible codes is not too high
                     || (previousNbOfPossibleCodes <= nbOfCodesForSystematicEvaluation) ) { // number of possible codes is not too high (general case)

                  if (previousNbOfPossibleCodes > nbOfCodesForSystematicEvaluation_ForMemAlloc) {
                    throw new Error("NEW_ATTEMPT phase / inconsistent previousNbOfPossibleCodes or nbOfCodesForSystematicEvaluation_ForMemAlloc value (1): " + previousNbOfPossibleCodes + ", " +  nbOfCodesForSystematicEvaluation_ForMemAlloc);
                  }

                  // Initializations
                  // ***************

                  // ***** First evaluation phase in a game *****
                  if (precalculated_cur_game_or_code > 0) { // both game and code were precalculated
                    if (performanceListsInitDone) {
                      throw new Error("NEW_ATTEMPT phase / inconsistent game precalculation");
                    }
                    // - Array allocations
                    if (!performanceListsInitDoneForPrecalculatedGames) {
                      performanceListsInitDoneForPrecalculatedGames = true;
                      arraySizeAtInit = Math.ceil((3*previousNbOfPossibleCodes + nbOfCodesForSystematicEvaluation_ForMemAlloc)/4); // (overestimated for low values of previousNbOfPossibleCodes to ensure proper subsequent mem_reduc_factor application)
                      listOfGlobalPerformances = new Array(arraySizeAtInit);
                      maxDepthApplied = 1; // "one-recursive-depth computing of performances" for cur game and code (whether possible or impossible) => memory optimization
                      listsOfPossibleCodes = undefined;
                      listsOfPossibleCodes = new3DArray(maxDepthApplied, nbMaxMarks, arraySizeAtInit, mem_reduc_factor);
                      nbOfPossibleCodes = undefined;
                      nbOfPossibleCodes = new2DArray(maxDepthApplied, nbMaxMarks);
                      listOfClassesFirstCall = new Array(arraySizeAtInit);
                      listOfEquivalentCodesAndPerformances = undefined;
                      listOfEquivalentCodesAndPerformances = new2DArray(maxDepthApplied, arraySizeAtInit);
                      for (let idx1 = 0; idx1 < maxDepthApplied; idx1++) { // structure allocation
                        for (let idx2 = 0; idx2 < arraySizeAtInit; idx2++) {
                          listOfEquivalentCodesAndPerformances[idx1][idx2] = {equiv_code:0, equiv_sum:PerformanceNA};
                        }
                      }
                      if ((marks_already_computed_table == null) || (marks_already_computed_table.length != marks_optimization_mask+1)) {
                        throw new Error("NEW_ATTEMPT phase / inconsistent marks_already_computed_table (1)");
                      }
                    }
                  }
                  // ***** Second evaluation phase in a game *****
                  else if ( ((precalculated_cur_game_or_code == 0) && (previousNbOfPossibleCodes <= nbOfCodesForSystematicEvaluation)) // only game was precalculated and number of possible codes is not too high
                            || (previousNbOfPossibleCodes <= nbOfCodesForSystematicEvaluation) ) { // number of possible codes is not too high (general case)
                    if (precalculated_cur_game_or_code > 0) {
                      throw new Error("NEW_ATTEMPT phase / internal error (precalculated_cur_game_or_code)");
                    }
                    // - Array allocations
                    if (!performanceListsInitDone) {
                      performanceListsInitDone = true;
                      arraySizeAtInit = Math.ceil((3*previousNbOfPossibleCodes + nbOfCodesForSystematicEvaluation)/4); // (overestimated for low values of previousNbOfPossibleCodes to ensure proper subsequent mem_reduc_factor application)
                      listOfGlobalPerformances = new Array(arraySizeAtInit);
                      maxDepthApplied = maxDepth;
                      listsOfPossibleCodes = undefined;
                      listsOfPossibleCodes = new3DArray(maxDepthApplied, nbMaxMarks, arraySizeAtInit, mem_reduc_factor);
                      nbOfPossibleCodes = undefined;
                      nbOfPossibleCodes = new2DArray(maxDepthApplied, nbMaxMarks);
                      listOfClassesFirstCall = new Array(arraySizeAtInit);
                      listOfEquivalentCodesAndPerformances = undefined;
                      listOfEquivalentCodesAndPerformances = new2DArray(maxDepthApplied, arraySizeAtInit);
                      for (let idx1 = 0; idx1 < maxDepthApplied; idx1++) { // structure allocation
                        for (let idx2 = 0; idx2 < arraySizeAtInit; idx2++) {
                          listOfEquivalentCodesAndPerformances[idx1][idx2] = {equiv_code:0, equiv_sum:PerformanceNA};
                        }
                      }
                      if ((marks_already_computed_table == null) || (marks_already_computed_table.length != marks_optimization_mask+1)) {
                        throw new Error("NEW_ATTEMPT phase / inconsistent marks_already_computed_table (2)");
                      }
                    }
                  }
                  else {
                    throw new Error("NEW_ATTEMPT phase / inconsistent performance evaluation case");
                  }

                  // - Other initializations
                  for (let i = 0; i < arraySizeAtInit; i++) {
                    listOfGlobalPerformances[i] = PerformanceNA;
                  }
                  // listsOfPossibleCodes is not initialized as this array may be very large
                  for (let i = 0; i < maxDepthApplied; i++) {
                    for (let j = 0; j < nbMaxMarks; j++) {
                      nbOfPossibleCodes[i][j] = 0;
                    }
                  }

                  // Compute performances
                  // ********************

                  let code_played_global_performance = PerformanceNA;
                  let index = (curAttemptNumber%2);
                  if (0 == isAttemptPossibleinGameSolver(curAttemptNumber)) { // code played is possible
                    // Evaluate performances for possibleCodesForPerfEvaluation[curAttemptNumber%2]:
                    let startTime = (new Date()).getTime();
                    best_global_performance = evaluatePerformances(-1 /* first depth */, possibleCodesForPerfEvaluation[index], previousNbOfPossibleCodes, 0 /* empty code */, precalculated_cur_game_or_code);
                    if (best_global_performance != PerformanceUNKNOWN) { // performance evaluation succeeded
                      let code_played_found = false;
                      for (let i = 0; i < previousNbOfPossibleCodes; i++) {
                        if ( (possibleCodesForPerfEvaluation[index][i] == codesPlayed[curAttemptNumber-1]) && (listOfGlobalPerformances[i] != PerformanceNA) ) {
                          code_played_global_performance = listOfGlobalPerformances[i];
                          code_played_found = true;
                          break;
                        }
                      }
                      if (!code_played_found) { // error to test
                        throw new Error("NEW_ATTEMPT phase / performance of possible code played was not evaluated (" + codeHandler.codeToString(codesPlayed[curAttemptNumber-1]) + ", " + curAttemptNumber + ")");
                      }
                      console.log("(perfeval#1: best performance: " + best_global_performance
                                  + " / code performance: " + code_played_global_performance
                                  + " / " + ((new Date()).getTime() - startTime) + "ms / " + previousNbOfPossibleCodes + ((previousNbOfPossibleCodes > 1) ? " codes" : " code") + " / " + curNbClasses + ((curNbClasses > 1) ? " classes" : " class")
                                  + ((precalculated_cur_game_or_code >= 0) ? ((precalculated_cur_game_or_code > 0) ? " / precalculated" : " / ~precalculated") : "") + ")");
                    }
                    else {
                      console.log("(perfeval#1 failed in " + ((new Date()).getTime() - startTime) + "ms / " + previousNbOfPossibleCodes + ((previousNbOfPossibleCodes > 1) ? " codes" : " code") + " / " + curNbClasses + ((curNbClasses > 1) ? " classes" : " class") + ")");
                    }
                  }
                  else { // code played is not possible
                    // Evaluate performances for possibleCodesForPerfEvaluation[curAttemptNumber%2]:
                    let startTime = (new Date()).getTime();
                    best_global_performance = evaluatePerformances(-1 /* first depth */, possibleCodesForPerfEvaluation[index], previousNbOfPossibleCodes, codesPlayed[curAttemptNumber-1], precalculated_cur_game_or_code);
                    if (best_global_performance != PerformanceUNKNOWN) { // performance evaluation succeeded
                      if ((particularCodeGlobalPerformance == PerformanceNA) || (particularCodeGlobalPerformance == PerformanceUNKNOWN) || (particularCodeGlobalPerformance <= 0.01)) {
                        throw new Error("NEW_ATTEMPT phase / invalid particularCodeGlobalPerformance: " + particularCodeGlobalPerformance);
                      }
                      code_played_global_performance = particularCodeGlobalPerformance;
                      console.log("(perfeval#2: best performance: " + best_global_performance
                                  + " / code performance: " + particularCodeGlobalPerformance
                                  + " / " + ((new Date()).getTime() - startTime) + "ms / " + previousNbOfPossibleCodes + ((previousNbOfPossibleCodes > 1) ? " codes" : " code") + " / " + curNbClasses + ((curNbClasses > 1) ? " classes" : " class")
                                  + ((precalculated_cur_game_or_code >= 0) ? ((precalculated_cur_game_or_code > 0) ? " / precalculated" : " / ~precalculated") : "") + ")");
                    }
                    else {
                      console.log("(perfeval#2 failed in " + ((new Date()).getTime() - startTime) + "ms / " + previousNbOfPossibleCodes + ((previousNbOfPossibleCodes > 1) ? " codes" : " code") + " / " + curNbClasses + ((curNbClasses > 1) ? " classes" : " class") + ")");
                    }
                  }

                  if (best_global_performance != PerformanceUNKNOWN) { // performance evaluation succeeded
                    if ((best_global_performance == PerformanceNA) || (best_global_performance <= 0.01)) {
                      throw new Error("NEW_ATTEMPT phase / invalid best_global_performance: " + best_global_performance);
                    }
                    for (let i = 0; i < previousNbOfPossibleCodes; i++) {
                      let global_performance = listOfGlobalPerformances[i];
                      if ( (global_performance == PerformanceNA) || (global_performance == PerformanceUNKNOWN) || (global_performance <= 0.01) ) {
                        throw new Error("invalid global performance in listOfGlobalPerformances (1): " + global_performance + ", " + best_global_performance + ", " + previousNbOfPossibleCodes + ", " + i);
                      }
                      if ( (best_global_performance - global_performance < (PerformanceMinValidValue-1)/2) || (best_global_performance - global_performance >= +0.0001) ) {
                        throw new Error("invalid global performance in listOfGlobalPerformances (2): " + global_performance + ", " + best_global_performance + ", " + previousNbOfPossibleCodes + ", " + i);
                      }
                    }
                    if ((code_played_global_performance == PerformanceNA) || (code_played_global_performance == PerformanceUNKNOWN) || (code_played_global_performance <= 0.01)) {
                      throw new Error("NEW_ATTEMPT phase / invalid code_played_global_performance: " + code_played_global_performance);
                    }
                    code_played_relative_perf = best_global_performance - code_played_global_performance;
                    if ( (code_played_relative_perf < PerformanceMinValidValue) || (code_played_relative_perf > PerformanceMaxValidValue) ) {
                      throw new Error("NEW_ATTEMPT phase / invalid relative performance: " + code_played_relative_perf + ", " + best_global_performance + ", " + code_played_global_performance);
                    }
                    relative_perf_evaluation_done = true;
                  }
                  else { // performance evaluation failed
                    best_global_performance = PerformanceUNKNOWN;
                    code_played_relative_perf = PerformanceUNKNOWN;
                    relative_perf_evaluation_done = false;
                  }

                  // Post-processing checks
                  // **********************

                  if (listOfGlobalPerformances.length != arraySizeAtInit) {
                    throw new Error("NEW_ATTEMPT phase / listOfGlobalPerformances allocation was modified");
                  }
                  if (!check3DArraySizes(listsOfPossibleCodes, maxDepthApplied, nbMaxMarks, arraySizeAtInit, mem_reduc_factor)) {
                    throw new Error("NEW_ATTEMPT phase / listsOfPossibleCodes allocation was modified");
                  }
                  if (!check2DArraySizes(nbOfPossibleCodes, maxDepthApplied, nbMaxMarks)) {
                    throw new Error("NEW_ATTEMPT phase / nbOfPossibleCodes allocation was modified");
                  }
                  if (curGame.length != nbMaxAttempts+maxDepth) {
                    throw new Error("NEW_ATTEMPT phase / curGame allocation was modified");
                  }
                  if (marksIdxs.length != nbMaxAttempts+maxDepth) {
                    throw new Error("NEW_ATTEMPT phase / marksIdxs allocation was modified");
                  }
                  if (listOfClassesFirstCall.length != arraySizeAtInit) {
                    throw new Error("NEW_ATTEMPT phase / listOfClassesFirstCall allocation was modified");
                  }
                  if (!check2DArraySizes(listOfEquivalentCodesAndPerformances, maxDepthApplied, arraySizeAtInit)) {
                    throw new Error("NEW_ATTEMPT phase / listOfEquivalentCodesAndPerformances allocation was modified");
                  }
                  if (cur_permutations_table_size.length != overallNbMaxAttempts+overallMaxDepth) {
                    throw new Error("NEW_ATTEMPT phase / cur_permutations_table_size allocation was modified");
                  }
                  if (!check2DArraySizes(cur_permutations_table, overallNbMaxAttempts+overallMaxDepth, cur_permutations_table_size[0])) {
                    throw new Error("NEW_ATTEMPT phase / cur_permutations_table allocation was modified");
                  }

                  if (code_colors.length != nbMaxColumns) {
                    throw new Error("NEW_ATTEMPT phase / code_colors allocation was modified");
                  }
                  if (other_code_colors.length != nbMaxColumns) {
                    throw new Error("NEW_ATTEMPT phase / other_code_colors allocation was modified");
                  }
                  if ( (!check2DArraySizes(cur_game_code_colors, overallNbMaxAttempts+overallMaxDepth, nbMaxColumns))
                       || (cur_game_code_colors.size < curGame.length) ) { // first dimension shall be >= curGame size
                    throw new Error("NEW_ATTEMPT phase / cur_game_code_colors allocation was modified or is invalid");
                  }
                  if ( (!check2DArraySizes(other_game_code_colors, overallNbMaxAttempts+overallMaxDepth, nbMaxColumns))
                       || (other_game_code_colors.size < curGame.length) ) { // first dimension shall be >= curGame size
                    throw new Error("NEW_ATTEMPT phase / other_game_code_colors allocation was modified or is invalid");
                  }
                  if (permuted_other_code_colors.length != nbMaxColumns) {
                    throw new Error("NEW_ATTEMPT phase / permuted_other_code_colors allocation was modified");
                  }
                  if (partial_bijection.length != nbMaxColors+1) {
                    throw new Error("NEW_ATTEMPT phase / partial_bijection allocation was modified");
                  }
                  if ( (curGameForGamePrecalculation.length != maxDepthForGamePrecalculation_ForMemAlloc)
                       || (marksIdxsForGamePrecalculation.length != maxDepthForGamePrecalculation_ForMemAlloc) ) {
                    throw new Error("NEW_ATTEMPT phase / curGameForGamePrecalculation or marksIdxsForGamePrecalculation allocation was modified");
                  }

                }
                else {
                  best_global_performance = PerformanceUNKNOWN;
                  code_played_relative_perf = PerformanceUNKNOWN;
                  relative_perf_evaluation_done = false;
                }

              }

              if (best_global_performance == PerformanceNA) {
                throw new Error("NEW_ATTEMPT phase / best_global_performance is NA");
              }
              if (code_played_relative_perf == PerformanceNA) {
                throw new Error("NEW_ATTEMPT phase / code_played_relative_perf is NA");
              }

              // ***************
              // B.2) Update GUI
              // ***************

              self.postMessage({'rsp_type': 'CODE_PLAYED_PERFORMANCE', 'relative_perf_p': code_played_relative_perf, 'best_global_performance_p': best_global_performance, 'relative_perf_evaluation_done_p': relative_perf_evaluation_done, 'code_p': codesPlayed[curAttemptNumber-1], 'attempt_nb': curAttemptNumber, 'game_id': game_id});

              // ************************************************
              // C.1) Organize performances of all possible codes
              // ************************************************

              if (nbMaxPossibleCodesShown > nbOfCodesForSystematicEvaluation) {
                throw new Error("NEW_ATTEMPT phase / inconsistent numbers of listed codes: " + nbMaxPossibleCodesShown + " > " + nbOfCodesForSystematicEvaluation);
              }
              let nb_codes_shown = Math.min(previousNbOfPossibleCodes, nbMaxPossibleCodesShown);
              if (nb_codes_shown > nbOfCodesForSystematicEvaluation_ForMemAlloc) {
                throw new Error("NEW_ATTEMPT phase / inconsistent nb_codes_shown or nbOfCodesForSystematicEvaluation_ForMemAlloc value: " + nb_codes_shown + ", " +  nbOfCodesForSystematicEvaluation_ForMemAlloc);
              }
              let cur_possible_code_list = possibleCodesForPerfEvaluation[curAttemptNumber%2];

              // Particular case of first attempt of Master Mind game
              // ****************************************************

              if ((curAttemptNumber == 1) && (nbColumns == 4)) { // first attempt
                if (nb_codes_shown <= 5) { // (initialNbClasses)
                  throw new Error("NEW_ATTEMPT phase / internal error (nb_codes_shown)");
                }
                if (previousNbOfPossibleCodes != initialNbPossibleCodes) {
                  throw new Error("NEW_ATTEMPT phase / internal error (previousNbOfPossibleCodes)");
                }
                if (previousNbOfPossibleCodes > nbOfCodesForSystematicEvaluation_ForMemAlloc) {
                  throw new Error("NEW_ATTEMPT phase / inconsistent previousNbOfPossibleCodes or nbOfCodesForSystematicEvaluation_ForMemAlloc value (2): " + previousNbOfPossibleCodes + ", " +  nbOfCodesForSystematicEvaluation_ForMemAlloc);
                }
                // Add simple codes
                possibleCodesShown[0] = codeHandler.uncompressStringToCode("1233");
                possibleCodesShown[1] = codeHandler.uncompressStringToCode("1234");
                possibleCodesShown[2] = codeHandler.uncompressStringToCode("1122");
                possibleCodesShown[3] = codeHandler.uncompressStringToCode("1222");
                possibleCodesShown[4] = codeHandler.uncompressStringToCode("1111");
                for (let i = 0; i < 5; i++) {
                  if (best_global_performance == PerformanceUNKNOWN) {
                    globalPerformancesShown[i] = PerformanceUNKNOWN;
                  }
                  else {
                    let simple_code_found = false;
                    for (let j = 0; j < previousNbOfPossibleCodes; j++) {
                      if (possibleCodesShown[i] == cur_possible_code_list[j]) {
                        if ((listOfGlobalPerformances[j] == PerformanceNA) || (listOfGlobalPerformances[j] == PerformanceUNKNOWN) || (listOfGlobalPerformances[j] <= 0.01)) {
                          throw new Error("NEW_ATTEMPT phase / invalid listOfGlobalPerformances (1) (index " + i + ")");
                        }
                        globalPerformancesShown[i] = listOfGlobalPerformances[j];
                        simple_code_found = true;
                        break;
                      }
                    }
                    if (!simple_code_found) {
                      throw new Error("NEW_ATTEMPT phase / internal error (simple_code_found)");
                    }
                  }
                }
                // Add other codes
                let cnt = 5;
                for (let i = 0; i < previousNbOfPossibleCodes; i++) {
                  let simple_code_already_present = false;
                  for (let j = 0; j < 5; j++) {
                    if (cur_possible_code_list[i] == possibleCodesShown[j]) {
                      simple_code_already_present = true;
                      break;
                    }
                  }
                  if (!simple_code_already_present) {
                    possibleCodesShown[cnt] = cur_possible_code_list[i];
                    if (best_global_performance == PerformanceUNKNOWN) {
                      globalPerformancesShown[cnt] = PerformanceUNKNOWN;
                    }
                    else {
                      if ((listOfGlobalPerformances[i] == PerformanceNA) || (listOfGlobalPerformances[i] == PerformanceUNKNOWN) || (listOfGlobalPerformances[i] <= 0.01)) {
                        throw new Error("NEW_ATTEMPT phase / invalid listOfGlobalPerformances (2) (index " + i + ")");
                      }
                      globalPerformancesShown[cnt] = listOfGlobalPerformances[i];
                    }
                    cnt++;
                    if (cnt == nb_codes_shown) {
                      break;
                    }
                  }
                }
              }

              // Particular case of first attempt of Super Master Mind game
              // **********************************************************

              else if ((curAttemptNumber == 1) && (nbColumns == 5)) { // first attempt
                if (nb_codes_shown <= 7) { // (initialNbClasses)
                  throw new Error("NEW_ATTEMPT phase / internal error (nb_codes_shown)");
                }
                if (previousNbOfPossibleCodes != initialNbPossibleCodes) {
                  throw new Error("NEW_ATTEMPT phase / internal error (previousNbOfPossibleCodes)");
                }
                if (previousNbOfPossibleCodes > nbOfCodesForSystematicEvaluation_ForMemAlloc) {
                  throw new Error("NEW_ATTEMPT phase / inconsistent previousNbOfPossibleCodes or nbOfCodesForSystematicEvaluation_ForMemAlloc value (3): " + previousNbOfPossibleCodes + ", " +  nbOfCodesForSystematicEvaluation_ForMemAlloc);
                }
                // Add simple codes
                possibleCodesShown[0] = codeHandler.uncompressStringToCode("12233");
                possibleCodesShown[1] = codeHandler.uncompressStringToCode("12344");
                possibleCodesShown[2] = codeHandler.uncompressStringToCode("12345");
                possibleCodesShown[3] = codeHandler.uncompressStringToCode("12333");
                possibleCodesShown[4] = codeHandler.uncompressStringToCode("11222");
                possibleCodesShown[5] = codeHandler.uncompressStringToCode("12222");
                possibleCodesShown[6] = codeHandler.uncompressStringToCode("11111");
                for (let i = 0; i < 7; i++) {
                  if (best_global_performance == PerformanceUNKNOWN) {
                    globalPerformancesShown[i] = PerformanceUNKNOWN;
                  }
                  else {
                    let simple_code_found = false;
                    for (let j = 0; j < previousNbOfPossibleCodes; j++) {
                      if (possibleCodesShown[i] == cur_possible_code_list[j]) {
                        if ((listOfGlobalPerformances[j] == PerformanceNA) || (listOfGlobalPerformances[j] == PerformanceUNKNOWN) || (listOfGlobalPerformances[j] <= 0.01)) {
                          throw new Error("NEW_ATTEMPT phase / invalid listOfGlobalPerformances (3) (index " + i + ")");
                        }
                        globalPerformancesShown[i] = listOfGlobalPerformances[j];
                        simple_code_found = true;
                        break;
                      }
                    }
                    if (!simple_code_found) {
                      throw new Error("NEW_ATTEMPT phase / internal error (simple_code_found)");
                    }
                  }
                }
                // Add other codes
                let cnt = 7;
                for (let i = 0; i < previousNbOfPossibleCodes; i++) {
                  let simple_code_already_present = false;
                  for (let j = 0; j < 7; j++) {
                    if (cur_possible_code_list[i] == possibleCodesShown[j]) {
                      simple_code_already_present = true;
                      break;
                    }
                  }
                  if (!simple_code_already_present) {
                    possibleCodesShown[cnt] = cur_possible_code_list[i];
                    if (best_global_performance == PerformanceUNKNOWN) {
                      globalPerformancesShown[cnt] = PerformanceUNKNOWN;
                    }
                    else {
                      if ((listOfGlobalPerformances[i] == PerformanceNA) || (listOfGlobalPerformances[i] == PerformanceUNKNOWN) || (listOfGlobalPerformances[i] <= 0.01)) {
                        throw new Error("NEW_ATTEMPT phase / invalid listOfGlobalPerformances (4) (index " + i + ")");
                      }
                      globalPerformancesShown[cnt] = listOfGlobalPerformances[i];
                    }
                    cnt++;
                    if (cnt == nb_codes_shown) {
                      break;
                    }
                  }
                }
              }

              // General case
              // ************

              else {
                for (let i = 0; i < nb_codes_shown; i++) {
                  possibleCodesShown[i] = cur_possible_code_list[i];
                  if (best_global_performance == PerformanceUNKNOWN) {
                    globalPerformancesShown[i] = PerformanceUNKNOWN;
                  }
                  else {
                    if ((listOfGlobalPerformances[i] == PerformanceNA) || (listOfGlobalPerformances[i] == PerformanceUNKNOWN) || (listOfGlobalPerformances[i] <= 0.01)) {
                      throw new Error("NEW_ATTEMPT phase / invalid listOfGlobalPerformances (5) (index " + i + ")");
                    }
                    globalPerformancesShown[i] = listOfGlobalPerformances[i];
                  }
                }
              }

              // ***************
              // C.2) Update GUI
              // ***************

              self.postMessage({'rsp_type': 'LIST_OF_POSSIBLE_CODES', 'possibleCodesList_p': possibleCodesShown.toString(), 'nb_possible_codes_listed': nb_codes_shown, 'globalPerformancesList_p': globalPerformancesShown.toString(), 'attempt_nb': curAttemptNumber, 'game_id': game_id});

              // ****************
              // Defensive checks
              // ****************

              // Check if errors occurred when writing into arrays
              if ( (possibleCodesForPerfEvaluation[0].length != nbOfCodesForSystematicEvaluation_ForMemAlloc)
                   || (possibleCodesForPerfEvaluation[1].length != nbOfCodesForSystematicEvaluation_ForMemAlloc) ) {
                throw new Error("inconsistent possibleCodesForPerfEvaluation length: " + possibleCodesForPerfEvaluation[0].length + ", " + possibleCodesForPerfEvaluation[1].length + ", " + nbOfCodesForSystematicEvaluation_ForMemAlloc);
              }

            }

            // **********
            // Error case
            // **********

            else {
              throw new Error("unexpected req_type: " + data.req_type);
            }

            message_processing_ongoing = false;

          }
          catch (exc) {
            abort_worker_process = true;
            throw new Error("gameSolver internal error (message): " + exc + ": " + exc.stack);
          }

        };

      }
      catch (exc) {
        abort_worker_process = true;
        throw new Error("gameSolver internal error (global): " + exc + ": " + exc.stack);
      }

      // ****************************
      // GameSolver worker code - end
      // ****************************

    </script>
    
    <script>
      let gamesolver_blob = new Blob([document.querySelector('#gamesolver_id').textContent], {type: "text/javascript"});
    </script>

    <!-- Run main Super Master Mind script -->    
    
    <script src='SuperMasterMind.js'></script>    
    
  </body>

</html>
